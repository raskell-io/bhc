# FFI Guidelines

**Rule ID:** BHC-RULE-010
**Applies to:** Foreign function interface, external library bindings

---

## FFI Principles

1. **Safety by default** — Assume foreign code is unsafe
2. **Pin what you share** — Foreign pointers must be pinned
3. **Explicit lifetimes** — Clear ownership at boundaries
4. **Minimal surface** — Small, well-defined FFI boundaries

---

## Safe vs Unsafe FFI

### Safe FFI (Default)

```haskell
-- Safe: May trigger GC, slower but safe
foreign import ccall safe "cblas_dgemm"
  c_dgemm :: CInt -> CInt -> CInt
          -> CDouble -> Ptr CDouble -> CInt
          -> Ptr CDouble -> CInt
          -> CDouble -> Ptr CDouble -> CInt
          -> IO ()
```

**Use safe FFI when:**
- Function may take significant time
- Function may allocate Haskell memory
- Function may call back into Haskell
- You're unsure

### Unsafe FFI

```haskell
-- Unsafe: No GC, faster but dangerous
foreign import ccall unsafe "fast_sin"
  c_fast_sin :: CDouble -> CDouble
```

**Use unsafe FFI only when:**
- Function is very fast (<1μs)
- Function will never call back to Haskell
- Function will never block
- Performance is critical

### Interruptible FFI

```haskell
-- Can be interrupted by async exceptions
foreign import ccall interruptible "blocking_read"
  c_blocking_read :: CInt -> Ptr CChar -> CSize -> IO CSSize
```

**Use interruptible for:**
- Blocking I/O operations
- Operations that should respect cancellation

---

## Memory Management at FFI Boundary

### Pinned Buffers

**All buffers passed to foreign code MUST be pinned.**

```haskell
-- Good: Explicit pinning
withPinnedTensor :: Tensor a -> (Ptr a -> IO b) -> IO b
withPinnedTensor tensor action = do
  ensurePinned tensor
  ptr <- tensorDataPtr tensor
  action ptr

-- Good: Allocate as pinned
allocPinnedArray :: Storable a => Int -> IO (Ptr a)
allocPinnedArray n = mallocBytes (n * sizeOf (undefined :: a))
```

### Why Pinning Matters

```
Without pinning (WRONG):
  ┌───────────────┐
  │ GC may move   │
  │ memory during │──→ ptr becomes invalid!
  │ foreign call  │
  └───────────────┘

With pinning (CORRECT):
  ┌───────────────┐
  │ Pinned memory │
  │ stays in      │──→ ptr remains valid
  │ place         │
  └───────────────┘
```

### Ownership Transfer

```haskell
-- BHC owns memory, C borrows
withBorrowedBuffer :: Buffer -> (Ptr a -> IO b) -> IO b
withBorrowedBuffer buf action = do
  -- Buffer valid only during action
  ptr <- getBufferPtr buf
  action ptr
  -- Buffer may be freed after

-- C owns memory, BHC borrows
data ForeignBuffer = ForeignBuffer
  { fbPtr  :: !(ForeignPtr a)
  , fbSize :: !Int
  }

wrapForeignBuffer :: Ptr a -> Int -> IO () -> IO ForeignBuffer
wrapForeignBuffer ptr size finalizer = do
  fp <- newForeignPtr finalizerPtr ptr
  addForeignPtrFinalizer fp finalizer
  pure $ ForeignBuffer fp size
```

---

## Type Marshalling

### Primitive Types

```haskell
-- Standard C type mappings
type CInt    = Int32
type CDouble = Double
type CFloat  = Float
type CSize   = Word64  -- Platform dependent
type CSSize  = Int64   -- Platform dependent

-- Haskell to C
toCInt :: Int -> CInt
toCInt = fromIntegral

-- C to Haskell
fromCInt :: CInt -> Int
fromCInt = fromIntegral
```

### Array Marshalling

```haskell
-- Pass array to C
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
withArrayLen xs action = do
  let len = length xs
  allocaArray len $ \ptr -> do
    pokeArray ptr xs
    action len ptr

-- Receive array from C
peekArrayLen :: Storable a => Int -> Ptr a -> IO [a]
peekArrayLen len ptr = peekArray len ptr
```

### Struct Marshalling

```haskell
-- C struct
-- struct TensorDesc {
--     int rank;
--     int64_t* shape;
--     int64_t* strides;
-- };

data TensorDesc = TensorDesc
  { tdRank    :: !CInt
  , tdShape   :: !(Ptr Int64)
  , tdStrides :: !(Ptr Int64)
  }

instance Storable TensorDesc where
  sizeOf _ = 24  -- sizeof(struct TensorDesc)
  alignment _ = 8

  peek ptr = TensorDesc
    <$> peekByteOff ptr 0
    <*> peekByteOff ptr 8
    <*> peekByteOff ptr 16

  poke ptr (TensorDesc r s st) = do
    pokeByteOff ptr 0 r
    pokeByteOff ptr 8 s
    pokeByteOff ptr 16 st
```

---

## Error Handling

### Return Code Checking

```haskell
-- Check C return codes
checkRC :: CInt -> IO ()
checkRC rc
  | rc == 0   = pure ()
  | otherwise = throwIO $ FFIError rc (describeError rc)

-- Usage
foreign import ccall safe "some_function"
  c_some_function :: Ptr a -> IO CInt

callSomeFunction :: Ptr a -> IO ()
callSomeFunction ptr = do
  rc <- c_some_function ptr
  checkRC rc
```

### Errno Handling

```haskell
-- Get errno after system call
foreign import ccall "errno.h value errno" getErrno :: IO CInt

withErrno :: IO a -> IO (Either CInt a)
withErrno action = do
  result <- action
  err <- getErrno
  if err == 0
    then pure (Right result)
    else pure (Left err)
```

### Error Translation

```haskell
-- Translate C errors to Haskell exceptions
data FFIException
  = FFIError CInt String
  | FFINullPointer
  | FFIBufferTooSmall Int Int
  deriving (Show, Exception)

translateError :: CInt -> FFIException
translateError 1  = FFIError 1 "Invalid argument"
translateError 2  = FFIError 2 "Out of memory"
translateError rc = FFIError rc "Unknown error"
```

---

## BLAS Integration

### BLAS Provider Interface

```haskell
-- Abstract BLAS interface
class BLASProvider backend where
  gemm :: backend
       -> Transpose -> Transpose
       -> Int -> Int -> Int  -- M, N, K
       -> Double -> Tensor Double -> Int  -- alpha, A, lda
       -> Tensor Double -> Int            -- B, ldb
       -> Double -> Tensor Double -> Int  -- beta, C, ldc
       -> IO ()

-- OpenBLAS implementation
data OpenBLAS = OpenBLAS

instance BLASProvider OpenBLAS where
  gemm _ transA transB m n k alpha a lda b ldb beta c ldc =
    withPinnedTensor a $ \ptrA ->
    withPinnedTensor b $ \ptrB ->
    withPinnedTensor c $ \ptrC ->
      c_cblas_dgemm
        (toCBlasOrder CblasRowMajor)
        (toCBlasTrans transA)
        (toCBlasTrans transB)
        (fromIntegral m) (fromIntegral n) (fromIntegral k)
        alpha ptrA (fromIntegral lda)
        ptrB (fromIntegral ldb)
        beta ptrC (fromIntegral ldc)
```

### Fallback Implementation

```haskell
-- Pure Haskell fallback when no BLAS available
data PureBLAS = PureBLAS

instance BLASProvider PureBLAS where
  gemm _ transA transB m n k alpha a lda b ldb beta c ldc = do
    -- Pure Haskell implementation
    forM_ [0..m-1] $ \i ->
      forM_ [0..n-1] $ \j -> do
        sum <- newIORef (beta * c!(i,j))
        forM_ [0..k-1] $ \l ->
          modifyIORef' sum $ \acc ->
            acc + alpha * a!(i,l) * b!(l,j)
        s <- readIORef sum
        writeArray c (i,j) s
```

---

## Callback Handling

### Exporting Haskell Functions

```haskell
-- Export Haskell function for C callback
type ProgressCallback = CInt -> CInt -> IO ()

foreign export ccall "bhc_progress_callback"
  progressCallback :: ProgressCallback

progressCallback :: ProgressCallback
progressCallback current total = do
  let pct = (fromIntegral current / fromIntegral total) * 100
  putStrLn $ "Progress: " ++ show pct ++ "%"
```

### Function Pointers

```haskell
-- Create function pointer from Haskell closure
type CFunPtr a = FunPtr (a -> IO ())

foreign import ccall "wrapper"
  mkCallback :: (CDouble -> IO CDouble) -> IO (FunPtr (CDouble -> IO CDouble))

withCallback :: (Double -> Double) -> (FunPtr (CDouble -> IO CDouble) -> IO a) -> IO a
withCallback f action = do
  let wrapped x = pure $ realToFrac (f (realToFrac x))
  fptr <- mkCallback wrapped
  result <- action fptr
  freeHaskellFunPtr fptr
  pure result
```

---

## Thread Safety

### FFI and Haskell Threads

```haskell
-- Bound thread for FFI that uses thread-local state
runInBoundThread :: IO a -> IO a
runInBoundThread action = do
  mv <- newEmptyMVar
  forkOS $ action >>= putMVar mv
  takeMVar mv

-- Usage with OpenGL (thread-local context)
withGLContext :: IO a -> IO a
withGLContext = runInBoundThread
```

### Global State

```haskell
-- Initialize library once
{-# NOINLINE libraryInitialized #-}
libraryInitialized :: IORef Bool
libraryInitialized = unsafePerformIO $ newIORef False

ensureInitialized :: IO ()
ensureInitialized = do
  initialized <- readIORef libraryInitialized
  unless initialized $ do
    c_library_init
    writeIORef libraryInitialized True
```

---

## Best Practices

### Do

- Pin all memory passed to foreign code
- Check return codes
- Use safe FFI by default
- Document ownership semantics
- Clean up foreign resources promptly

### Don't

- Pass unpinned memory to foreign code
- Ignore error codes
- Use unsafe FFI without profiling justification
- Let foreign pointers escape their scope
- Assume C code is thread-safe

### Checklist for New FFI Bindings

- [ ] Memory passed is pinned
- [ ] Error handling is implemented
- [ ] Ownership is clearly documented
- [ ] Safe/unsafe is justified
- [ ] Thread safety is considered
- [ ] Resources are properly cleaned up
- [ ] Tests cover error paths
