//! Core Runtime System for the Basel Haskell Compiler.
//!
//! This crate is the main entry point for the BHC Runtime System (RTS).
//! It integrates and coordinates all RTS components:
//!
//! - **Memory Management** (`bhc-rts-alloc`, `bhc-rts-arena`, `bhc-rts-gc`)
//! - **Concurrency** (`bhc-rts-scheduler`)
//!
//! # Architecture
//!
//! The RTS provides the execution environment for compiled BHC programs.
//! It implements the runtime contract specified in the H26 specification,
//! supporting multiple profiles with different performance characteristics.
//!
//! ```text
//! +-------------------+
//! |   BHC Compiler    |
//! +-------------------+
//!          |
//!          | generates code that calls
//!          v
//! +-------------------+-------------------+
//! |              bhc-rts                  |
//! |         (Core RTS - this crate)       |
//! +-------------------+-------------------+
//!          |
//!          +----------+----------+----------+
//!          |          |          |          |
//!          v          v          v          v
//!     +---------+ +--------+ +------+ +-----------+
//!     |rts-alloc| |rts-arena| |rts-gc| |rts-scheduler|
//!     +---------+ +--------+ +------+ +-----------+
//! ```
//!
//! # Profiles
//!
//! The RTS supports different execution profiles as specified in H26-SPEC:
//!
//! | Profile   | Characteristics                           |
//! |-----------|-------------------------------------------|
//! | Default   | Lazy evaluation, GC managed               |
//! | Server    | Bounded latency, incremental GC           |
//! | Numeric   | Strict, minimal GC, arena allocation      |
//! | Edge      | Minimal footprint, no GC                  |
//!
//! # Usage
//!
//! The RTS is typically initialized automatically by the entry point
//! generated by the BHC compiler. For manual initialization:
//!
//! ```ignore
//! use bhc_rts::{Runtime, RuntimeConfig};
//!
//! fn main() {
//!     let config = RuntimeConfig::default();
//!     let runtime = Runtime::new(config);
//!
//!     runtime.run(|| {
//!         // Your program here
//!     });
//! }
//! ```

#![warn(missing_docs)]
#![deny(unsafe_op_in_unsafe_fn)]

// FFI entry points for C interop
pub mod ffi;

// Re-export RTS components
pub use bhc_rts_alloc as alloc;
pub use bhc_rts_arena as arena;
pub use bhc_rts_gc as gc;
pub use bhc_rts_scheduler as scheduler;

use bhc_rts_gc::{GarbageCollector, GcConfig};
use bhc_rts_scheduler::{Scheduler, SchedulerConfig};
use parking_lot::RwLock;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

/// Execution profile for the runtime.
///
/// Profiles define behavioral and performance contracts per H26-SPEC.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Profile {
    /// Default profile: lazy evaluation, GC managed.
    #[default]
    Default,
    /// Server profile: bounded latency, incremental GC, observability.
    Server,
    /// Numeric profile: strict-by-default, minimal GC, arena allocation.
    Numeric,
    /// Edge profile: minimal runtime footprint, no GC.
    Edge,
}

impl Profile {
    /// Get the recommended GC configuration for this profile.
    #[must_use]
    pub fn gc_config(&self) -> GcConfig {
        match self {
            Self::Default => GcConfig::default(),
            Self::Server => GcConfig {
                incremental: true,
                max_pause_us: 500,
                ..GcConfig::default()
            },
            Self::Numeric => GcConfig {
                nursery_size: 1024 * 1024,  // Smaller nursery
                ..GcConfig::default()
            },
            Self::Edge => GcConfig {
                nursery_size: 256 * 1024,   // Minimal
                survivor_size: 128 * 1024,
                old_gen_size: 1024 * 1024,
                ..GcConfig::default()
            },
        }
    }

    /// Get the recommended scheduler configuration for this profile.
    #[must_use]
    pub fn scheduler_config(&self) -> SchedulerConfig {
        match self {
            Self::Default => SchedulerConfig::default(),
            Self::Server => SchedulerConfig {
                work_stealing: true,
                ..SchedulerConfig::default()
            },
            Self::Numeric => SchedulerConfig {
                work_stealing: true,
                ..SchedulerConfig::default()
            },
            Self::Edge => SchedulerConfig {
                num_workers: 1,  // Single-threaded for minimal footprint
                stack_size: 512 * 1024,
                work_stealing: false,
            },
        }
    }
}

/// Configuration for the runtime system.
#[derive(Debug, Clone)]
pub struct RuntimeConfig {
    /// Execution profile.
    pub profile: Profile,
    /// Custom GC configuration (overrides profile default if set).
    pub gc_config: Option<GcConfig>,
    /// Custom scheduler configuration (overrides profile default if set).
    pub scheduler_config: Option<SchedulerConfig>,
    /// Enable debug mode with additional checks.
    pub debug_mode: bool,
    /// Enable statistics collection.
    pub collect_stats: bool,
}

impl Default for RuntimeConfig {
    fn default() -> Self {
        Self {
            profile: Profile::Default,
            gc_config: None,
            scheduler_config: None,
            debug_mode: false,
            collect_stats: true,
        }
    }
}

impl RuntimeConfig {
    /// Create a new configuration for the given profile.
    #[must_use]
    pub fn for_profile(profile: Profile) -> Self {
        Self {
            profile,
            ..Self::default()
        }
    }

    /// Get the effective GC configuration.
    #[must_use]
    pub fn effective_gc_config(&self) -> GcConfig {
        self.gc_config.clone().unwrap_or_else(|| self.profile.gc_config())
    }

    /// Get the effective scheduler configuration.
    #[must_use]
    pub fn effective_scheduler_config(&self) -> SchedulerConfig {
        self.scheduler_config.clone().unwrap_or_else(|| self.profile.scheduler_config())
    }
}

/// Runtime statistics.
#[derive(Debug, Clone, Default)]
pub struct RuntimeStats {
    /// Total time spent in RTS (microseconds).
    pub total_rts_time_us: u64,
    /// Time spent in GC (microseconds).
    pub gc_time_us: u64,
    /// Time spent in scheduler overhead (microseconds).
    pub scheduler_overhead_us: u64,
    /// Number of RTS entry points called.
    pub rts_entries: u64,
}

/// The core runtime system.
///
/// This struct coordinates all RTS components and provides the main
/// interface for running BHC programs.
pub struct Runtime {
    config: RuntimeConfig,
    gc: Arc<GarbageCollector>,
    scheduler: Arc<Scheduler>,
    stats: RwLock<RuntimeStats>,
    initialized: AtomicBool,
}

impl Runtime {
    /// Create a new runtime with the given configuration.
    #[must_use]
    pub fn new(config: RuntimeConfig) -> Self {
        let gc_config = config.effective_gc_config();
        let scheduler_config = config.effective_scheduler_config();

        Self {
            config,
            gc: Arc::new(GarbageCollector::new(gc_config)),
            scheduler: Arc::new(Scheduler::with_config(scheduler_config)),
            stats: RwLock::new(RuntimeStats::default()),
            initialized: AtomicBool::new(true),
        }
    }

    /// Create a new runtime with default configuration.
    #[must_use]
    pub fn with_default_config() -> Self {
        Self::new(RuntimeConfig::default())
    }

    /// Create a new runtime for the specified profile.
    #[must_use]
    pub fn for_profile(profile: Profile) -> Self {
        Self::new(RuntimeConfig::for_profile(profile))
    }

    /// Get the runtime configuration.
    #[must_use]
    pub fn config(&self) -> &RuntimeConfig {
        &self.config
    }

    /// Get the garbage collector.
    #[must_use]
    pub fn gc(&self) -> &GarbageCollector {
        &self.gc
    }

    /// Get the scheduler.
    #[must_use]
    pub fn scheduler(&self) -> &Scheduler {
        &self.scheduler
    }

    /// Get runtime statistics.
    #[must_use]
    pub fn stats(&self) -> RuntimeStats {
        self.stats.read().clone()
    }

    /// Check if the runtime is initialized.
    #[must_use]
    pub fn is_initialized(&self) -> bool {
        self.initialized.load(Ordering::Acquire)
    }

    /// Run a function within the runtime context.
    ///
    /// This is the main entry point for executing BHC programs.
    pub fn run<F, R>(&self, f: F) -> R
    where
        F: FnOnce() -> R,
    {
        if self.config.collect_stats {
            let mut stats = self.stats.write();
            stats.rts_entries += 1;
        }

        // Set up the runtime context
        // In a full implementation, this would:
        // 1. Initialize thread-local state
        // 2. Set up signal handlers
        // 3. Initialize GC roots

        f()
    }

    /// Run a function with a hot arena for temporary allocations.
    ///
    /// This is optimized for numeric kernels where intermediate
    /// allocations have well-defined lifetimes.
    pub fn run_with_arena<F, R>(&self, arena_size: usize, f: F) -> R
    where
        F: FnOnce(&arena::HotArena) -> R,
    {
        arena::with_arena(arena_size, f)
    }

    /// Spawn a task on the scheduler.
    pub fn spawn<F, T>(&self, f: F) -> scheduler::Task<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        self.scheduler.spawn(f)
    }

    /// Force a garbage collection.
    pub fn force_gc(&self) {
        let roots = gc::RootSet::new();
        self.gc.major_collect(&roots);
    }

    /// Shutdown the runtime.
    ///
    /// This should be called when the program is done executing.
    pub fn shutdown(self) {
        self.initialized.store(false, Ordering::Release);
        // Scheduler will be shutdown on drop
    }
}

impl Default for Runtime {
    fn default() -> Self {
        Self::with_default_config()
    }
}

/// Global runtime instance for simple usage.
///
/// For more control, create a `Runtime` instance directly.
static GLOBAL_RUNTIME: parking_lot::Mutex<Option<Arc<Runtime>>> = parking_lot::Mutex::new(None);

/// Initialize the global runtime with the given configuration.
///
/// This should be called once at program startup.
///
/// # Panics
///
/// Panics if the global runtime is already initialized.
pub fn init(config: RuntimeConfig) {
    let mut global = GLOBAL_RUNTIME.lock();
    if global.is_some() {
        panic!("global runtime already initialized");
    }
    *global = Some(Arc::new(Runtime::new(config)));
}

/// Initialize the global runtime with default configuration.
///
/// # Panics
///
/// Panics if the global runtime is already initialized.
pub fn init_default() {
    init(RuntimeConfig::default());
}

/// Get the global runtime, initializing with defaults if necessary.
#[must_use]
pub fn global() -> Arc<Runtime> {
    let mut global = GLOBAL_RUNTIME.lock();
    if let Some(ref runtime) = *global {
        Arc::clone(runtime)
    } else {
        let runtime = Arc::new(Runtime::with_default_config());
        *global = Some(Arc::clone(&runtime));
        runtime
    }
}

/// Run a function with the global runtime.
pub fn run<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    global().run(f)
}

/// Spawn a task on the global scheduler.
pub fn spawn<F, T>(f: F) -> scheduler::Task<T>
where
    F: FnOnce() -> T + Send + 'static,
    T: Send + 'static,
{
    global().spawn(f)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_runtime_creation() {
        let runtime = Runtime::with_default_config();
        assert!(runtime.is_initialized());
        assert_eq!(runtime.config().profile, Profile::Default);
    }

    #[test]
    fn test_runtime_profiles() {
        for profile in [Profile::Default, Profile::Server, Profile::Numeric, Profile::Edge] {
            let runtime = Runtime::for_profile(profile);
            assert_eq!(runtime.config().profile, profile);
        }
    }

    #[test]
    fn test_runtime_run() {
        let runtime = Runtime::with_default_config();
        let result = runtime.run(|| 42);
        assert_eq!(result, 42);
    }

    #[test]
    fn test_runtime_spawn() {
        let runtime = Runtime::with_default_config();
        let task = runtime.spawn(|| 42);
        let result = task.await_result();
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 42);
    }

    #[test]
    fn test_runtime_with_arena() {
        let runtime = Runtime::with_default_config();
        let result = runtime.run_with_arena(4096, |arena| {
            let x = arena.alloc(42i32).unwrap();
            *x * 2
        });
        assert_eq!(result, 84);
    }

    #[test]
    fn test_profile_gc_config() {
        let default_config = Profile::Default.gc_config();
        let server_config = Profile::Server.gc_config();
        let numeric_config = Profile::Numeric.gc_config();
        let edge_config = Profile::Edge.gc_config();

        assert!(!default_config.incremental);
        assert!(server_config.incremental);
        assert!(numeric_config.nursery_size < default_config.nursery_size);
        assert!(edge_config.old_gen_size < default_config.old_gen_size);
    }

    #[test]
    fn test_profile_scheduler_config() {
        let edge_config = Profile::Edge.scheduler_config();
        let default_config = Profile::Default.scheduler_config();

        assert_eq!(edge_config.num_workers, 1);
        assert!(!edge_config.work_stealing);
        assert!(default_config.work_stealing);
    }

    #[test]
    fn test_runtime_stats() {
        let runtime = Runtime::with_default_config();

        let _ = runtime.run(|| 1);
        let _ = runtime.run(|| 2);

        let stats = runtime.stats();
        assert!(stats.rts_entries >= 2);
    }

    #[test]
    fn test_global_runtime() {
        // Get global runtime (creates if needed)
        let rt1 = global();
        let rt2 = global();

        // Should be the same instance
        assert!(Arc::ptr_eq(&rt1, &rt2));
    }
}
