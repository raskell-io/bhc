//! Lowering from Core IR to LLVM IR.
//!
//! This module implements the translation from BHC's Core IR to LLVM IR.
//! The lowering handles:
//!
//! - Literals: Int, Double, Char, String
//! - Variables: Mapped to LLVM SSA values
//! - Function applications: Compiled to calls
//! - Lambdas: Compiled to closures or direct functions
//! - Let bindings: Compiled to LLVM allocas/phis
//! - Case expressions: Compiled to switch/branch

use crate::{CodegenError, CodegenResult};
use bhc_core::{Alt, AltCon, Bind, CoreModule, DataCon, Expr, Literal, Var, VarId};
use bhc_intern::Symbol;
use rustc_hash::FxHashSet;

/// Primitive operations that compile directly to LLVM instructions.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PrimOp {
    // Arithmetic
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Rem,
    Quot,

    // Comparison
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,

    // Boolean
    And,
    Or,
    Not,

    // Unary numeric
    Negate,
    Abs,
    Signum,

    // Bitwise
    BitAnd,
    BitOr,
    BitXor,
    ShiftL,
    ShiftR,
    Complement,
}
use bhc_index::Idx;
use bhc_types::Ty;
use inkwell::builder::Builder;
use inkwell::context::Context;
use inkwell::types::{BasicType, BasicTypeEnum};
use inkwell::values::{BasicValueEnum, FloatValue, FunctionValue, IntValue, PointerValue};
use rustc_hash::FxHashMap;

use super::context::LlvmContext;
use super::module::LlvmModule;
use super::types::TypeMapper;

/// Metadata about a data constructor, used for code generation.
#[derive(Clone, Debug)]
pub struct ConstructorMeta {
    /// The constructor's tag (0-based index within the data type).
    pub tag: u32,
    /// The number of fields this constructor has.
    pub arity: u32,
}

/// A symbol exported by an already-compiled module, used for cross-module linking.
#[derive(Clone, Debug)]
pub struct CompiledSymbol {
    /// The source-level name (interned).
    pub name: Symbol,
    /// The LLVM symbol name (module-qualified).
    pub llvm_name: String,
    /// Number of parameters the function takes.
    pub param_count: usize,
}

/// Which monad's bind/return semantics to use during lowering.
#[derive(Clone, Copy, Debug, PartialEq)]
enum MonadContext {
    IO,
    ReaderT,
    StateT,
    ExceptT,
    WriterT,
}

/// State for lowering Core IR to LLVM IR.
///
/// The struct has two lifetimes:
/// - `'ctx`: The LLVM context lifetime (for types and values)
/// - `'m`: The module reference lifetime (can be shorter than 'ctx)
pub struct Lowering<'ctx, 'm> {
    /// The underlying LLVM context (borrowed from LlvmContext).
    llvm_ctx: &'ctx Context,
    /// The LLVM module being generated.
    module: &'m LlvmModule<'ctx>,
    /// Mapping from Core variables to LLVM values.
    env: FxHashMap<VarId, BasicValueEnum<'ctx>>,
    /// Mapping from Core variables to LLVM functions (for top-level bindings).
    functions: FxHashMap<VarId, FunctionValue<'ctx>>,
    /// Counter for generating unique closure names.
    closure_counter: u32,
    /// Mapping from constructor names to metadata (tag, arity).
    /// This is populated from DataCon entries in case alternatives.
    constructor_metadata: FxHashMap<String, ConstructorMeta>,
    /// Whether we're currently lowering an expression in tail position.
    /// Used for tail call optimization.
    in_tail_position: bool,
    /// Optional module name for symbol mangling in multi-module compilation.
    module_name: Option<String>,
    /// External functions imported from other compiled modules.
    external_functions: FxHashMap<Symbol, FunctionValue<'ctx>>,
    /// Stack tracking which monad's bind/return to use.
    /// Pushed when entering transformer runners (runReaderT, evalStateT, etc.).
    monad_context_stack: Vec<MonadContext>,
    /// Set of function names whose bodies use StateT operations.
    /// Used to detect monad context when these functions appear in bind chains.
    state_t_functions: FxHashSet<String>,
    /// Set of function names whose bodies use ReaderT operations.
    reader_t_functions: FxHashSet<String>,
    /// Set of function names whose bodies use ExceptT operations.
    except_t_functions: FxHashSet<String>,
    /// Set of function names whose bodies use WriterT operations.
    writer_t_functions: FxHashSet<String>,
}

impl<'ctx, 'm> Lowering<'ctx, 'm> {
    /// Create a new lowering context.
    pub fn new(ctx: &'ctx LlvmContext, module: &'m LlvmModule<'ctx>) -> Self {
        let mut lowering = Self {
            llvm_ctx: ctx.llvm_context(),
            module,
            env: FxHashMap::default(),
            functions: FxHashMap::default(),
            closure_counter: 0,
            constructor_metadata: FxHashMap::default(),
            in_tail_position: false,
            module_name: None,
            external_functions: FxHashMap::default(),
            monad_context_stack: vec![MonadContext::IO],
            state_t_functions: FxHashSet::default(),
            reader_t_functions: FxHashSet::default(),
            except_t_functions: FxHashSet::default(),
            writer_t_functions: FxHashSet::default(),
        };
        lowering.declare_rts_functions();
        lowering
    }

    /// Create a new lowering context for multi-module compilation.
    ///
    /// Accepts a module name for symbol mangling and a list of imported symbols
    /// from already-compiled modules to declare as external.
    pub fn new_multimodule(
        ctx: &'ctx LlvmContext,
        module: &'m LlvmModule<'ctx>,
        module_name: &str,
        imported_symbols: &[CompiledSymbol],
    ) -> CodegenResult<Self> {
        let mut lowering = Self {
            llvm_ctx: ctx.llvm_context(),
            module,
            env: FxHashMap::default(),
            functions: FxHashMap::default(),
            closure_counter: 0,
            constructor_metadata: FxHashMap::default(),
            in_tail_position: false,
            module_name: Some(module_name.to_string()),
            external_functions: FxHashMap::default(),
            monad_context_stack: vec![MonadContext::IO],
            state_t_functions: FxHashSet::default(),
            reader_t_functions: FxHashSet::default(),
            except_t_functions: FxHashSet::default(),
            writer_t_functions: FxHashSet::default(),
        };
        lowering.declare_rts_functions();
        lowering.declare_external_symbols(imported_symbols)?;
        Ok(lowering)
    }

    /// Push a monad context onto the stack (e.g. when entering a transformer runner).
    fn push_monad_context(&mut self, ctx: MonadContext) {
        self.monad_context_stack.push(ctx);
    }

    /// Pop the monad context stack (e.g. when leaving a transformer runner).
    fn pop_monad_context(&mut self) {
        self.monad_context_stack.pop();
    }

    /// Return the current monad context (top of stack, defaults to IO).
    fn current_monad_context(&self) -> MonadContext {
        self.monad_context_stack.last().copied().unwrap_or(MonadContext::IO)
    }

    /// Detect the monad context from an expression by inspecting its head symbol.
    /// This handles the case where `>>=` is used with transformer operations
    /// (e.g. `ask >>= \n -> return n`) outside of an explicit runner call.
    fn detect_monad_from_expr(&self, expr: &Expr) -> MonadContext {
        match expr {
            Expr::Var(v, _) => {
                let name = v.name.as_str();
                match name {
                    "ask" | "asks" | "local"
                    | "ReaderT.>>=" | "ReaderT.>>" | "ReaderT.pure"
                    | "ReaderT.fmap" | "ReaderT.<*>"
                    | "ReaderT.lift" | "ReaderT.liftIO" => MonadContext::ReaderT,
                    "get" | "put" | "modify" | "gets"
                    | "StateT.>>=" | "StateT.>>" | "StateT.pure"
                    | "StateT.fmap" | "StateT.<*>"
                    | "StateT.lift" | "StateT.liftIO" => MonadContext::StateT,
                    "throwE" | "catchE"
                    | "ExceptT.>>=" | "ExceptT.>>" | "ExceptT.pure"
                    | "ExceptT.fmap" | "ExceptT.<*>"
                    | "ExceptT.lift" | "ExceptT.liftIO" => MonadContext::ExceptT,
                    "tell"
                    | "WriterT.>>=" | "WriterT.>>" | "WriterT.pure"
                    | "WriterT.fmap" | "WriterT.<*>"
                    | "WriterT.lift" | "WriterT.liftIO" => MonadContext::WriterT,
                    _ => {
                        // Check if this is a user-defined function that was detected
                        // as using StateT/ReaderT/ExceptT/WriterT operations in its body.
                        if self.state_t_functions.contains(name) {
                            MonadContext::StateT
                        } else if self.reader_t_functions.contains(name) {
                            MonadContext::ReaderT
                        } else if self.except_t_functions.contains(name) {
                            MonadContext::ExceptT
                        } else if self.writer_t_functions.contains(name) {
                            MonadContext::WriterT
                        } else {
                            self.current_monad_context()
                        }
                    }
                }
            }
            Expr::App(func, _, _) => self.detect_monad_from_expr(func),
            _ => self.current_monad_context(),
        }
    }

    /// Check whether an expression tree contains StateT/ReaderT/ExceptT/WriterT operations.
    /// Used to determine the monad context for top-level function definitions
    /// that are used as transformer computations.
    fn detect_monad_context_for_body(&self, expr: &Expr) -> Option<MonadContext> {
        match expr {
            Expr::Var(v, _) => {
                let name = v.name.as_str();
                match name {
                    "get" | "put" | "modify" | "gets"
                    | "StateT.>>=" | "StateT.>>" | "StateT.pure" => Some(MonadContext::StateT),
                    "ask" | "asks" | "local"
                    | "ReaderT.>>=" | "ReaderT.>>" | "ReaderT.pure" => Some(MonadContext::ReaderT),
                    "throwE" | "catchE"
                    | "ExceptT.>>=" | "ExceptT.>>" | "ExceptT.pure" => Some(MonadContext::ExceptT),
                    "tell"
                    | "WriterT.>>=" | "WriterT.>>" | "WriterT.pure" => Some(MonadContext::WriterT),
                    _ => None,
                }
            }
            Expr::App(func, arg, _) => {
                self.detect_monad_context_for_body(func)
                    .or_else(|| self.detect_monad_context_for_body(arg))
            }
            Expr::Lam(_, body, _) => self.detect_monad_context_for_body(body),
            Expr::Let(bind, body, _) => {
                let in_bind = match bind.as_ref() {
                    Bind::NonRec(_, e) => self.detect_monad_context_for_body(e),
                    Bind::Rec(bindings) => bindings
                        .iter()
                        .find_map(|(_, e)| self.detect_monad_context_for_body(e)),
                };
                in_bind.or_else(|| self.detect_monad_context_for_body(body))
            }
            Expr::Case(scrut, alts, _, _) => {
                self.detect_monad_context_for_body(scrut).or_else(|| {
                    alts.iter()
                        .find_map(|alt| self.detect_monad_context_for_body(&alt.rhs))
                })
            }
            Expr::TyApp(e, _, _) => self.detect_monad_context_for_body(e),
            _ => None,
        }
    }

    /// Mangle a function name with the module name for multi-module compilation.
    ///
    /// In multi-module mode, function names are qualified as `Module.name` to avoid
    /// collisions. The entry point wrapper (C `main`) is created separately by the
    /// driver, so the Haskell `main` gets mangled to `Main.main` like any other function.
    fn mangle_name(&self, name: &str) -> String {
        if let Some(ref mod_name) = self.module_name {
            format!("{}.{}", mod_name, name)
        } else {
            name.to_string()
        }
    }

    /// Declare external symbols from already-compiled modules.
    ///
    /// For each imported symbol, we add a function declaration (extern) to the
    /// current LLVM module so that references to cross-module functions can be
    /// resolved at link time.
    fn declare_external_symbols(
        &mut self,
        symbols: &[CompiledSymbol],
    ) -> CodegenResult<()> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        for sym in symbols {
            // All BHC functions use uniform calling convention with an env/closure
            // pointer as the first parameter. param_count from CompiledSymbol counts
            // only the Haskell-level params (lambdas), so we add 1 for the env pointer.
            let total_params = sym.param_count + 1;
            let param_types: Vec<inkwell::types::BasicMetadataTypeEnum> = (0..total_params)
                .map(|_| ptr_type.into())
                .collect();
            let fn_type = ptr_type.fn_type(&param_types, false);
            let fn_val = self.module.add_function(&sym.llvm_name, fn_type);
            self.external_functions.insert(sym.name, fn_val);
        }
        Ok(())
    }

    /// Register a constructor's metadata for later use.
    pub fn register_constructor(&mut self, name: &str, tag: u32, arity: u32) {
        self.constructor_metadata
            .insert(name.to_string(), ConstructorMeta { tag, arity });
    }

    /// Declare external RTS functions.
    fn declare_rts_functions(&mut self) {
        // Get all types upfront to avoid borrow conflicts
        let void_type = self.llvm_ctx.void_type();
        let i64_type = self.type_mapper().i64_type();
        let f64_type = self.type_mapper().f64_type();
        let i32_type = self.type_mapper().i32_type();
        let i8_ptr_type = self.llvm_ctx.ptr_type(inkwell::AddressSpace::default());

        // bhc_print_int_ln(i64) -> void
        let print_int_ln_type = void_type.fn_type(&[i64_type.into()], false);
        let print_int_ln =
            self.module
                .llvm_module()
                .add_function("bhc_print_int_ln", print_int_ln_type, None);
        self.functions.insert(VarId::new(1000000), print_int_ln); // Base 1_000_000 to avoid collisions with user DefIds

        // bhc_print_double_ln(f64) -> void
        let print_double_ln_type = void_type.fn_type(&[f64_type.into()], false);
        let print_double_ln = self.module.llvm_module().add_function(
            "bhc_print_double_ln",
            print_double_ln_type,
            None,
        );
        self.functions.insert(VarId::new(1000001), print_double_ln);

        // bhc_print_string_ln(*i8) -> void
        let print_string_ln_type = void_type.fn_type(&[i8_ptr_type.into()], false);
        let print_string_ln = self.module.llvm_module().add_function(
            "bhc_print_string_ln",
            print_string_ln_type,
            None,
        );
        self.functions.insert(VarId::new(1000002), print_string_ln);

        // bhc_print_int(i64) -> void
        let print_int_type = void_type.fn_type(&[i64_type.into()], false);
        let print_int =
            self.module
                .llvm_module()
                .add_function("bhc_print_int", print_int_type, None);
        self.functions.insert(VarId::new(1000003), print_int);

        // bhc_print_string(*i8) -> void
        let print_string_type = void_type.fn_type(&[i8_ptr_type.into()], false);
        let print_string =
            self.module
                .llvm_module()
                .add_function("bhc_print_string", print_string_type, None);
        self.functions.insert(VarId::new(1000004), print_string);

        // bhc_alloc(size: i64) -> ptr - allocate heap memory
        let alloc_type = i8_ptr_type.fn_type(&[i64_type.into()], false);
        let alloc_fn = self
            .module
            .llvm_module()
            .add_function("bhc_alloc", alloc_type, None);
        self.functions.insert(VarId::new(1000005), alloc_fn);

        // bhc_error(*i8) -> void - runtime error (does not return)
        let error_type = void_type.fn_type(&[i8_ptr_type.into()], false);
        let error_fn = self
            .module
            .llvm_module()
            .add_function("bhc_error", error_type, None);
        self.functions.insert(VarId::new(1000006), error_fn);

        // bhc_print_bool(i64) -> void - print True/False
        let print_bool_type = void_type.fn_type(&[i64_type.into()], false);
        let print_bool =
            self.module
                .llvm_module()
                .add_function("bhc_print_bool", print_bool_type, None);
        self.functions.insert(VarId::new(1000007), print_bool);

        // bhc_print_bool_ln(i64) -> void - print True/False with newline
        let print_bool_ln_type = void_type.fn_type(&[i64_type.into()], false);
        let print_bool_ln =
            self.module
                .llvm_module()
                .add_function("bhc_print_bool_ln", print_bool_ln_type, None);
        self.functions.insert(VarId::new(1000008), print_bool_ln);

        // bhc_print_char(i32) -> void - print a character
        let print_char_type = void_type.fn_type(&[i32_type.into()], false);
        let print_char =
            self.module
                .llvm_module()
                .add_function("bhc_print_char", print_char_type, None);
        self.functions.insert(VarId::new(1000009), print_char);

        // bhc_print_newline() -> void
        let print_newline_type = void_type.fn_type(&[], false);
        let print_newline =
            self.module
                .llvm_module()
                .add_function("bhc_print_newline", print_newline_type, None);
        self.functions.insert(VarId::new(1000010), print_newline);

        // bhc_force(ptr) -> ptr - Force thunk evaluation to WHNF
        let force_type = i8_ptr_type.fn_type(&[i8_ptr_type.into()], false);
        let force_fn = self
            .module
            .llvm_module()
            .add_function("bhc_force", force_type, None);
        self.functions.insert(VarId::new(1000011), force_fn);

        // bhc_is_thunk(ptr) -> i32 - Check if object is an unevaluated thunk
        let is_thunk_type = i32_type.fn_type(&[i8_ptr_type.into()], false);
        let is_thunk_fn =
            self.module
                .llvm_module()
                .add_function("bhc_is_thunk", is_thunk_type, None);
        self.functions.insert(VarId::new(1000012), is_thunk_fn);

        // === Math RTS functions ===
        let f64_to_f64 = f64_type.fn_type(&[f64_type.into()], false);
        let f32_type = self.llvm_ctx.f32_type();
        let f64_to_i64 = i64_type.fn_type(&[f64_type.into()], false);
        let f64_f64_to_f64 = f64_type.fn_type(&[f64_type.into(), f64_type.into()], false);
        let i64_to_i64 = i64_type.fn_type(&[i64_type.into()], false);

        // bhc_sqrt_double(f64) -> f64
        let sqrt_double = self.module.llvm_module().add_function("bhc_sqrt_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000013), sqrt_double);

        // bhc_exp_double(f64) -> f64
        let exp_double = self.module.llvm_module().add_function("bhc_exp_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000014), exp_double);

        // bhc_log_double(f64) -> f64
        let log_double = self.module.llvm_module().add_function("bhc_log_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000015), log_double);

        // bhc_sin_double(f64) -> f64
        let sin_double = self.module.llvm_module().add_function("bhc_sin_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000016), sin_double);

        // bhc_cos_double(f64) -> f64
        let cos_double = self.module.llvm_module().add_function("bhc_cos_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000017), cos_double);

        // bhc_tan_double(f64) -> f64
        let tan_double = self.module.llvm_module().add_function("bhc_tan_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000018), tan_double);

        // bhc_asin_double(f64) -> f64
        let asin_double = self.module.llvm_module().add_function("bhc_asin_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000019), asin_double);

        // bhc_acos_double(f64) -> f64
        let acos_double = self.module.llvm_module().add_function("bhc_acos_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000020), acos_double);

        // bhc_atan_double(f64) -> f64
        let atan_double = self.module.llvm_module().add_function("bhc_atan_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000021), atan_double);

        // bhc_atan2_double(f64, f64) -> f64
        let atan2_double = self.module.llvm_module().add_function("bhc_atan2_double", f64_f64_to_f64, None);
        self.functions.insert(VarId::new(1000022), atan2_double);

        // bhc_ceiling_double(f64) -> i64
        let ceiling_double = self.module.llvm_module().add_function("bhc_ceiling_double", f64_to_i64, None);
        self.functions.insert(VarId::new(1000023), ceiling_double);

        // bhc_floor_double(f64) -> i64
        let floor_double = self.module.llvm_module().add_function("bhc_floor_double", f64_to_i64, None);
        self.functions.insert(VarId::new(1000024), floor_double);

        // bhc_round_double(f64) -> i64
        let round_double = self.module.llvm_module().add_function("bhc_round_double", f64_to_i64, None);
        self.functions.insert(VarId::new(1000025), round_double);

        // bhc_truncate_double(f64) -> i64
        let truncate_double = self.module.llvm_module().add_function("bhc_truncate_double", f64_to_i64, None);
        self.functions.insert(VarId::new(1000026), truncate_double);

        // bhc_negate_int(i64) -> i64
        let negate_int = self.module.llvm_module().add_function("bhc_negate_int", i64_to_i64, None);
        self.functions.insert(VarId::new(1000027), negate_int);

        // bhc_abs_int(i64) -> i64
        let abs_int = self.module.llvm_module().add_function("bhc_abs_int", i64_to_i64, None);
        self.functions.insert(VarId::new(1000028), abs_int);

        // bhc_signum_int(i64) -> i64
        let signum_int = self.module.llvm_module().add_function("bhc_signum_int", i64_to_i64, None);
        self.functions.insert(VarId::new(1000029), signum_int);

        // === Character RTS functions ===
        let u32_type = self.llvm_ctx.i32_type();
        let u32_to_bool = self.llvm_ctx.bool_type().fn_type(&[u32_type.into()], false);
        let u32_to_u32 = u32_type.fn_type(&[u32_type.into()], false);
        let u32_to_i32 = i32_type.fn_type(&[u32_type.into()], false);
        let i32_to_u32 = u32_type.fn_type(&[i32_type.into()], false);

        // bhc_char_is_alpha(u32) -> bool
        let char_is_alpha = self.module.llvm_module().add_function("bhc_char_is_alpha", u32_to_bool, None);
        self.functions.insert(VarId::new(1000030), char_is_alpha);

        // bhc_char_is_digit(u32) -> bool
        let char_is_digit = self.module.llvm_module().add_function("bhc_char_is_digit", u32_to_bool, None);
        self.functions.insert(VarId::new(1000031), char_is_digit);

        // bhc_char_is_alphanumeric(u32) -> bool
        let char_is_alnum = self.module.llvm_module().add_function("bhc_char_is_alphanumeric", u32_to_bool, None);
        self.functions.insert(VarId::new(1000032), char_is_alnum);

        // bhc_char_is_space(u32) -> bool
        let char_is_space = self.module.llvm_module().add_function("bhc_char_is_space", u32_to_bool, None);
        self.functions.insert(VarId::new(1000033), char_is_space);

        // bhc_char_is_upper(u32) -> bool
        let char_is_upper = self.module.llvm_module().add_function("bhc_char_is_upper", u32_to_bool, None);
        self.functions.insert(VarId::new(1000034), char_is_upper);

        // bhc_char_is_lower(u32) -> bool
        let char_is_lower = self.module.llvm_module().add_function("bhc_char_is_lower", u32_to_bool, None);
        self.functions.insert(VarId::new(1000035), char_is_lower);

        // bhc_char_to_upper(u32) -> u32
        let char_to_upper = self.module.llvm_module().add_function("bhc_char_to_upper", u32_to_u32, None);
        self.functions.insert(VarId::new(1000036), char_to_upper);

        // bhc_char_to_lower(u32) -> u32
        let char_to_lower = self.module.llvm_module().add_function("bhc_char_to_lower", u32_to_u32, None);
        self.functions.insert(VarId::new(1000037), char_to_lower);

        // bhc_char_is_print(u32) -> bool
        let char_is_print = self.module.llvm_module().add_function("bhc_char_is_print", u32_to_bool, None);
        self.functions.insert(VarId::new(1000038), char_is_print);

        // bhc_char_is_ascii(u32) -> bool
        let char_is_ascii = self.module.llvm_module().add_function("bhc_char_is_ascii", u32_to_bool, None);
        self.functions.insert(VarId::new(1000039), char_is_ascii);

        // bhc_char_is_control(u32) -> bool
        let char_is_control = self.module.llvm_module().add_function("bhc_char_is_control", u32_to_bool, None);
        self.functions.insert(VarId::new(1000040), char_is_control);

        // bhc_char_is_hex_digit(u32) -> bool
        let char_is_hex = self.module.llvm_module().add_function("bhc_char_is_hex_digit", u32_to_bool, None);
        self.functions.insert(VarId::new(1000041), char_is_hex);

        // bhc_char_is_letter(u32) -> bool
        let char_is_letter = self.module.llvm_module().add_function("bhc_char_is_letter", u32_to_bool, None);
        self.functions.insert(VarId::new(1000042), char_is_letter);

        // bhc_char_is_number(u32) -> bool
        let char_is_number = self.module.llvm_module().add_function("bhc_char_is_number", u32_to_bool, None);
        self.functions.insert(VarId::new(1000043), char_is_number);

        // bhc_char_is_punctuation(u32) -> bool
        let char_is_punct = self.module.llvm_module().add_function("bhc_char_is_punctuation", u32_to_bool, None);
        self.functions.insert(VarId::new(1000044), char_is_punct);

        // bhc_char_is_symbol(u32) -> bool
        let char_is_symbol = self.module.llvm_module().add_function("bhc_char_is_symbol", u32_to_bool, None);
        self.functions.insert(VarId::new(1000045), char_is_symbol);

        // bhc_char_digit_to_int(u32) -> i32
        let char_digit_to_int = self.module.llvm_module().add_function("bhc_char_digit_to_int", u32_to_i32, None);
        self.functions.insert(VarId::new(1000046), char_digit_to_int);

        // bhc_char_int_to_digit(i32) -> u32
        let char_int_to_digit = self.module.llvm_module().add_function("bhc_char_int_to_digit", i32_to_u32, None);
        self.functions.insert(VarId::new(1000047), char_int_to_digit);

        // bhc_char_ord(u32) -> u32
        let char_ord = self.module.llvm_module().add_function("bhc_char_ord", u32_to_u32, None);
        self.functions.insert(VarId::new(1000048), char_ord);

        // bhc_char_chr(u32) -> u32
        let char_chr = self.module.llvm_module().add_function("bhc_char_chr", u32_to_u32, None);
        self.functions.insert(VarId::new(1000049), char_chr);

        // === IO/System RTS functions ===
        // bhc_readFile(*i8) -> *i8
        let ptr_to_ptr = i8_ptr_type.fn_type(&[i8_ptr_type.into()], false);
        let read_file = self.module.llvm_module().add_function("bhc_readFile", ptr_to_ptr, None);
        self.functions.insert(VarId::new(1000050), read_file);

        // bhc_writeFile(*i8, *i8) -> void
        let ptr_ptr_to_void = void_type.fn_type(&[i8_ptr_type.into(), i8_ptr_type.into()], false);
        let write_file = self.module.llvm_module().add_function("bhc_writeFile", ptr_ptr_to_void, None);
        self.functions.insert(VarId::new(1000051), write_file);

        // bhc_appendFile(*i8, *i8) -> void
        let append_file = self.module.llvm_module().add_function("bhc_appendFile", ptr_ptr_to_void, None);
        self.functions.insert(VarId::new(1000052), append_file);

        // bhc_open_file(*i8, i32) -> *i8 (handle)
        let ptr_i32_to_ptr = i8_ptr_type.fn_type(&[i8_ptr_type.into(), i32_type.into()], false);
        let open_file = self.module.llvm_module().add_function("bhc_open_file", ptr_i32_to_ptr, None);
        self.functions.insert(VarId::new(1000053), open_file);

        // bhc_close_handle(*i8) -> void
        let ptr_to_void = void_type.fn_type(&[i8_ptr_type.into()], false);
        let close_handle = self.module.llvm_module().add_function("bhc_close_handle", ptr_to_void, None);
        self.functions.insert(VarId::new(1000054), close_handle);

        // bhc_hGetChar(*i8) -> i32
        let ptr_to_i32 = i32_type.fn_type(&[i8_ptr_type.into()], false);
        let h_get_char = self.module.llvm_module().add_function("bhc_hGetChar", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000055), h_get_char);

        // bhc_hGetLine(*i8) -> *i8
        let h_get_line = self.module.llvm_module().add_function("bhc_hGetLine", ptr_to_ptr, None);
        self.functions.insert(VarId::new(1000056), h_get_line);

        // bhc_hPutStr(*i8, *i8) -> void
        let h_put_str = self.module.llvm_module().add_function("bhc_hPutStr", ptr_ptr_to_void, None);
        self.functions.insert(VarId::new(1000057), h_put_str);

        // bhc_hFlush(*i8) -> void
        let h_flush = self.module.llvm_module().add_function("bhc_hFlush", ptr_to_void, None);
        self.functions.insert(VarId::new(1000058), h_flush);

        // bhc_hIsEOF(*i8) -> i32 (bool)
        let h_is_eof = self.module.llvm_module().add_function("bhc_hIsEOF", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000059), h_is_eof);

        // bhc_stdin() -> *i8
        let void_to_ptr = i8_ptr_type.fn_type(&[], false);
        let stdin_fn = self.module.llvm_module().add_function("bhc_stdin", void_to_ptr, None);
        self.functions.insert(VarId::new(1000060), stdin_fn);

        // bhc_stdout() -> *i8
        let stdout_fn = self.module.llvm_module().add_function("bhc_stdout", void_to_ptr, None);
        self.functions.insert(VarId::new(1000061), stdout_fn);

        // bhc_stderr() -> *i8
        let stderr_fn = self.module.llvm_module().add_function("bhc_stderr", void_to_ptr, None);
        self.functions.insert(VarId::new(1000062), stderr_fn);

        // bhc_exists(*i8) -> i32 (bool) - doesFileExist
        let does_file_exist = self.module.llvm_module().add_function("bhc_exists", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000063), does_file_exist);

        // bhc_is_directory(*i8) -> i32 (bool) - doesDirectoryExist
        let does_dir_exist = self.module.llvm_module().add_function("bhc_is_directory", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000064), does_dir_exist);

        // bhc_exit(i32) -> void
        let i32_to_void = void_type.fn_type(&[i32_type.into()], false);
        let exit_fn = self.module.llvm_module().add_function("bhc_exit", i32_to_void, None);
        self.functions.insert(VarId::new(1000065), exit_fn);

        // bhc_exit_success() -> void
        let void_to_void = void_type.fn_type(&[], false);
        let exit_success = self.module.llvm_module().add_function("bhc_exit_success", void_to_void, None);
        self.functions.insert(VarId::new(1000066), exit_success);

        // bhc_exit_failure() -> void
        let exit_failure = self.module.llvm_module().add_function("bhc_exit_failure", void_to_void, None);
        self.functions.insert(VarId::new(1000067), exit_failure);

        // bhc_get_env(*i8) -> *i8
        let get_env = self.module.llvm_module().add_function("bhc_get_env", ptr_to_ptr, None);
        self.functions.insert(VarId::new(1000068), get_env);

        // bhc_argc() -> i32
        let void_to_i32 = i32_type.fn_type(&[], false);
        let argc_fn = self.module.llvm_module().add_function("bhc_argc", void_to_i32, None);
        self.functions.insert(VarId::new(1000069), argc_fn);

        // bhc_argv() -> *i8 (returns ptr to argv array)
        let argv_fn = self.module.llvm_module().add_function("bhc_argv", void_to_ptr, None);
        self.functions.insert(VarId::new(1000070), argv_fn);

        // bhc_getLine() -> *i8
        let get_line = self.module.llvm_module().add_function("bhc_getLine", void_to_ptr, None);
        self.functions.insert(VarId::new(1000071), get_line);

        // bhc_show_int(i64) -> *i8
        let i64_to_ptr = i8_ptr_type.fn_type(&[i64_type.into()], false);
        let show_int = self.module.llvm_module().add_function("bhc_show_int", i64_to_ptr, None);
        self.functions.insert(VarId::new(1000072), show_int);

        // bhc_show_double(f64) -> *i8
        let f64_to_ptr = i8_ptr_type.fn_type(&[f64_type.into()], false);
        let show_double = self.module.llvm_module().add_function("bhc_show_double", f64_to_ptr, None);
        self.functions.insert(VarId::new(1000073), show_double);

        // bhc_show_bool(i64) -> *i8
        let show_bool = self.module.llvm_module().add_function("bhc_show_bool", i64_to_ptr, None);
        self.functions.insert(VarId::new(1000075), show_bool);

        // bhc_show_char(i32) -> *i8
        let i32_to_ptr = i8_ptr_type.fn_type(&[i32_type.into()], false);
        let show_char = self.module.llvm_module().add_function("bhc_show_char", i32_to_ptr, None);
        self.functions.insert(VarId::new(1000074), show_char);

        // bhc_char_to_int(u32) -> i64 (ord)
        let u32_to_i64 = i64_type.fn_type(&[u32_type.into()], false);
        let char_to_int = self.module.llvm_module().add_function("bhc_char_to_int", u32_to_i64, None);
        self.functions.insert(VarId::new(1000075), char_to_int);

        // bhc_int_to_char(i64) -> u32 (chr)
        let i64_to_u32 = u32_type.fn_type(&[i64_type.into()], false);
        let int_to_char = self.module.llvm_module().add_function("bhc_int_to_char", i64_to_u32, None);
        self.functions.insert(VarId::new(1000076), int_to_char);

        // bhc_negate_double(f64) -> f64
        let negate_double = self.module.llvm_module().add_function("bhc_negate_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000077), negate_double);

        // bhc_abs_double(f64) -> f64
        let abs_double = self.module.llvm_module().add_function("bhc_abs_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000078), abs_double);

        // bhc_signum_double(f64) -> f64
        let signum_double = self.module.llvm_module().add_function("bhc_signum_double", f64_to_f64, None);
        self.functions.insert(VarId::new(1000079), signum_double);

        // Container RTS functions (Map, Set, IntMap, IntSet)
        let ptr_type = i8_ptr_type;

        // Map operations
        let map_empty = self.module.llvm_module().add_function("bhc_map_empty", ptr_type.fn_type(&[], false), None);
        self.functions.insert(VarId::new(1000100), map_empty);

        let map_singleton = self.module.llvm_module().add_function("bhc_map_singleton", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000101), map_singleton);

        let map_null = self.module.llvm_module().add_function("bhc_map_null", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000102), map_null);

        let map_size = self.module.llvm_module().add_function("bhc_map_size", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000103), map_size);

        let map_member = self.module.llvm_module().add_function("bhc_map_member", i64_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000104), map_member);

        let map_lookup = self.module.llvm_module().add_function("bhc_map_lookup", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000105), map_lookup);

        let map_fwd = self.module.llvm_module().add_function("bhc_map_find_with_default", ptr_type.fn_type(&[ptr_type.into(), i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000106), map_fwd);

        let map_insert = self.module.llvm_module().add_function("bhc_map_insert", ptr_type.fn_type(&[i64_type.into(), ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000107), map_insert);

        let map_delete = self.module.llvm_module().add_function("bhc_map_delete", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000108), map_delete);

        let map_union = self.module.llvm_module().add_function("bhc_map_union", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000109), map_union);

        let map_intersection = self.module.llvm_module().add_function("bhc_map_intersection", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000110), map_intersection);

        let map_difference = self.module.llvm_module().add_function("bhc_map_difference", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000111), map_difference);

        let map_is_submap = self.module.llvm_module().add_function("bhc_map_is_submap_of", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000112), map_is_submap);

        // Set operations
        let set_empty = self.module.llvm_module().add_function("bhc_set_empty", ptr_type.fn_type(&[], false), None);
        self.functions.insert(VarId::new(1000120), set_empty);

        let set_singleton = self.module.llvm_module().add_function("bhc_set_singleton", ptr_type.fn_type(&[i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000121), set_singleton);

        let set_null = self.module.llvm_module().add_function("bhc_set_null", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000122), set_null);

        let set_size = self.module.llvm_module().add_function("bhc_set_size", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000123), set_size);

        let set_member = self.module.llvm_module().add_function("bhc_set_member", i64_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000124), set_member);

        let set_insert = self.module.llvm_module().add_function("bhc_set_insert", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000125), set_insert);

        let set_delete = self.module.llvm_module().add_function("bhc_set_delete", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000126), set_delete);

        let set_union = self.module.llvm_module().add_function("bhc_set_union", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000127), set_union);

        let set_intersection = self.module.llvm_module().add_function("bhc_set_intersection", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000128), set_intersection);

        let set_difference = self.module.llvm_module().add_function("bhc_set_difference", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000129), set_difference);

        let set_is_subset = self.module.llvm_module().add_function("bhc_set_is_subset_of", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000130), set_is_subset);

        let set_is_proper_subset = self.module.llvm_module().add_function("bhc_set_is_proper_subset_of", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000131), set_is_proper_subset);

        let set_find_min = self.module.llvm_module().add_function("bhc_set_find_min", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000132), set_find_min);

        let set_find_max = self.module.llvm_module().add_function("bhc_set_find_max", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000133), set_find_max);

        let set_delete_min = self.module.llvm_module().add_function("bhc_set_delete_min", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000134), set_delete_min);

        let set_delete_max = self.module.llvm_module().add_function("bhc_set_delete_max", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000135), set_delete_max);

        // IntMap operations
        let intmap_empty = self.module.llvm_module().add_function("bhc_intmap_empty", ptr_type.fn_type(&[], false), None);
        self.functions.insert(VarId::new(1000140), intmap_empty);

        let intmap_singleton = self.module.llvm_module().add_function("bhc_intmap_singleton", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000141), intmap_singleton);

        let intmap_null = self.module.llvm_module().add_function("bhc_intmap_null", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000142), intmap_null);

        let intmap_insert = self.module.llvm_module().add_function("bhc_intmap_insert", ptr_type.fn_type(&[i64_type.into(), ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000143), intmap_insert);

        let intmap_delete = self.module.llvm_module().add_function("bhc_intmap_delete", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000144), intmap_delete);

        let intmap_lookup = self.module.llvm_module().add_function("bhc_intmap_lookup", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000145), intmap_lookup);

        let intmap_union = self.module.llvm_module().add_function("bhc_intmap_union", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000146), intmap_union);

        // IntSet operations
        let intset_empty = self.module.llvm_module().add_function("bhc_intset_empty", ptr_type.fn_type(&[], false), None);
        self.functions.insert(VarId::new(1000150), intset_empty);

        let intset_singleton = self.module.llvm_module().add_function("bhc_intset_singleton", ptr_type.fn_type(&[i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000151), intset_singleton);

        let intset_null = self.module.llvm_module().add_function("bhc_intset_null", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000152), intset_null);

        let intset_insert = self.module.llvm_module().add_function("bhc_intset_insert", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000153), intset_insert);

        let intset_delete = self.module.llvm_module().add_function("bhc_intset_delete", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000154), intset_delete);

        let intset_union = self.module.llvm_module().add_function("bhc_intset_union", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000155), intset_union);

        let intset_member = self.module.llvm_module().add_function("bhc_intset_member", i64_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000156), intset_member);

        let intset_intersection = self.module.llvm_module().add_function("bhc_intset_intersection", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000157), intset_intersection);

        let intset_difference = self.module.llvm_module().add_function("bhc_intset_difference", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000158), intset_difference);

        let intset_is_subset = self.module.llvm_module().add_function("bhc_intset_is_subset_of", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000159), intset_is_subset);

        // Container iteration helpers (for toList/fromList)
        // bhc_map_keys_count(map_ptr) -> i64
        let map_keys_count = self.module.llvm_module().add_function("bhc_map_keys_count", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000160), map_keys_count);
        // bhc_map_key_at(map_ptr, index) -> i64
        let map_key_at = self.module.llvm_module().add_function("bhc_map_key_at", i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000161), map_key_at);
        // bhc_map_value_at(map_ptr, index) -> ptr
        let map_value_at = self.module.llvm_module().add_function("bhc_map_value_at", ptr_type.fn_type(&[ptr_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000162), map_value_at);
        // bhc_set_elem_count(set_ptr) -> i64
        let set_elem_count = self.module.llvm_module().add_function("bhc_set_elem_count", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000163), set_elem_count);
        // bhc_set_elem_at(set_ptr, index) -> i64
        let set_elem_at = self.module.llvm_module().add_function("bhc_set_elem_at", i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000164), set_elem_at);

        // ---- List RTS functions (VarId 1170-1175) ----
        // bhc_list_sort(list_ptr) -> ptr
        let list_sort = self.module.llvm_module().add_function("bhc_list_sort", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000170), list_sort);
        // bhc_list_sort_by(closure_ptr, list_ptr) -> ptr
        let list_sort_by = self.module.llvm_module().add_function("bhc_list_sort_by", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000171), list_sort_by);
        // bhc_list_nub(list_ptr) -> ptr
        let list_nub = self.module.llvm_module().add_function("bhc_list_nub", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000172), list_nub);
        // bhc_list_group(list_ptr) -> ptr
        let list_group = self.module.llvm_module().add_function("bhc_list_group", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000173), list_group);
        // bhc_list_intercalate(sep_ptr, list_ptr) -> ptr
        let list_intercalate = self.module.llvm_module().add_function("bhc_list_intercalate", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000174), list_intercalate);
        // bhc_list_transpose(list_ptr) -> ptr
        let list_transpose = self.module.llvm_module().add_function("bhc_list_transpose", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000175), list_transpose);

        // ---- String RTS functions (VarId 1176-1179) ----
        // bhc_string_lines(str_ptr) -> ptr
        let string_lines = self.module.llvm_module().add_function("bhc_string_lines", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000176), string_lines);
        // bhc_string_unlines(list_ptr) -> ptr
        let string_unlines = self.module.llvm_module().add_function("bhc_string_unlines", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000177), string_unlines);
        // bhc_string_words(str_ptr) -> ptr
        let string_words = self.module.llvm_module().add_function("bhc_string_words", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000178), string_words);
        // bhc_string_unwords(list_ptr) -> ptr
        let string_unwords = self.module.llvm_module().add_function("bhc_string_unwords", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000179), string_unwords);
        // bhc_string_length(str_ptr) -> i64  (strlen wrapper for C strings)
        let string_length = self.module.llvm_module().add_function("bhc_string_length", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000180), string_length);

        // ---- Text RTS functions (VarId 1200-1227) ----
        // bhc_text_empty() -> ptr
        let text_empty = self.module.llvm_module().add_function("bhc_text_empty", ptr_type.fn_type(&[], false), None);
        self.functions.insert(VarId::new(1000200), text_empty);
        // bhc_text_singleton(i64) -> ptr
        let text_singleton = self.module.llvm_module().add_function("bhc_text_singleton", ptr_type.fn_type(&[i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000201), text_singleton);
        // bhc_text_null(ptr) -> i64
        let text_null = self.module.llvm_module().add_function("bhc_text_null", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000202), text_null);
        // bhc_text_length(ptr) -> i64
        let text_length = self.module.llvm_module().add_function("bhc_text_length", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000203), text_length);
        // bhc_text_eq(ptr, ptr) -> i64
        let text_eq = self.module.llvm_module().add_function("bhc_text_eq", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000204), text_eq);
        // bhc_text_compare(ptr, ptr) -> i64
        let text_compare = self.module.llvm_module().add_function("bhc_text_compare", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000205), text_compare);
        // bhc_text_head(ptr) -> i64
        let text_head = self.module.llvm_module().add_function("bhc_text_head", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000206), text_head);
        // bhc_text_last(ptr) -> i64
        let text_last = self.module.llvm_module().add_function("bhc_text_last", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000207), text_last);
        // bhc_text_tail(ptr) -> ptr
        let text_tail = self.module.llvm_module().add_function("bhc_text_tail", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000208), text_tail);
        // bhc_text_init(ptr) -> ptr
        let text_init = self.module.llvm_module().add_function("bhc_text_init", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000209), text_init);
        // bhc_text_append(ptr, ptr) -> ptr
        let text_append = self.module.llvm_module().add_function("bhc_text_append", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000210), text_append);
        // bhc_text_reverse(ptr) -> ptr
        let text_reverse = self.module.llvm_module().add_function("bhc_text_reverse", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000211), text_reverse);
        // bhc_text_take(i64, ptr) -> ptr
        let text_take = self.module.llvm_module().add_function("bhc_text_take", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000212), text_take);
        // bhc_text_take_end(i64, ptr) -> ptr
        let text_take_end = self.module.llvm_module().add_function("bhc_text_take_end", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000213), text_take_end);
        // bhc_text_drop(i64, ptr) -> ptr
        let text_drop = self.module.llvm_module().add_function("bhc_text_drop", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000214), text_drop);
        // bhc_text_drop_end(i64, ptr) -> ptr
        let text_drop_end = self.module.llvm_module().add_function("bhc_text_drop_end", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000215), text_drop_end);
        // bhc_text_is_prefix_of(ptr, ptr) -> i64
        let text_is_prefix = self.module.llvm_module().add_function("bhc_text_is_prefix_of", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000216), text_is_prefix);
        // bhc_text_is_suffix_of(ptr, ptr) -> i64
        let text_is_suffix = self.module.llvm_module().add_function("bhc_text_is_suffix_of", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000217), text_is_suffix);
        // bhc_text_is_infix_of(ptr, ptr) -> i64
        let text_is_infix = self.module.llvm_module().add_function("bhc_text_is_infix_of", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000218), text_is_infix);
        // bhc_text_to_lower(ptr) -> ptr
        let text_to_lower = self.module.llvm_module().add_function("bhc_text_to_lower", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000219), text_to_lower);
        // bhc_text_to_upper(ptr) -> ptr
        let text_to_upper = self.module.llvm_module().add_function("bhc_text_to_upper", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000220), text_to_upper);
        // bhc_text_to_case_fold(ptr) -> ptr
        let text_case_fold = self.module.llvm_module().add_function("bhc_text_to_case_fold", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000221), text_case_fold);
        // bhc_text_to_title(ptr) -> ptr
        let text_to_title = self.module.llvm_module().add_function("bhc_text_to_title", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000222), text_to_title);
        // bhc_text_pack(ptr) -> ptr  (list -> Text)
        let text_pack = self.module.llvm_module().add_function("bhc_text_pack", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000223), text_pack);
        // bhc_text_char_count(ptr) -> i64  (for unpack iteration)
        let text_char_count = self.module.llvm_module().add_function("bhc_text_char_count", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000224), text_char_count);
        // bhc_text_char_at(ptr, i64) -> i64  (for unpack iteration)
        let text_char_at = self.module.llvm_module().add_function("bhc_text_char_at", i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000225), text_char_at);
        // bhc_text_map(fn_ptr, env_ptr, text_ptr) -> ptr
        let text_map = self.module.llvm_module().add_function("bhc_text_map", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000226), text_map);

        // ---- ByteArray RTS functions (VarId 1250-1258) ----
        // bhc_bytearray_malloc(i64) -> ptr
        let ba_malloc = self.module.llvm_module().add_function("bhc_bytearray_malloc", ptr_type.fn_type(&[i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000250), ba_malloc);
        // bhc_bytearray_contents(ptr) -> ptr
        let ba_contents = self.module.llvm_module().add_function("bhc_bytearray_contents", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000251), ba_contents);
        // bhc_bytearray_index(ptr, i64) -> i64
        let ba_index = self.module.llvm_module().add_function("bhc_bytearray_index", i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000252), ba_index);
        // bhc_bytearray_copy(ptr, ptr, i64, i64) -> void
        let ba_copy = self.module.llvm_module().add_function("bhc_bytearray_copy", void_type.fn_type(&[ptr_type.into(), ptr_type.into(), i64_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000253), ba_copy);
        // bhc_ptr_plus(ptr, i64) -> ptr
        let ba_ptr_plus = self.module.llvm_module().add_function("bhc_ptr_plus", ptr_type.fn_type(&[ptr_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000254), ba_ptr_plus);
        // bhc_poke_byte(ptr, i64, i64) -> void
        let ba_poke = self.module.llvm_module().add_function("bhc_poke_byte", void_type.fn_type(&[ptr_type.into(), i64_type.into(), i64_type.into()], false), None);
        self.functions.insert(VarId::new(1000255), ba_poke);
        // bhc_cstring_length(ptr) -> i64
        let ba_strlen = self.module.llvm_module().add_function("bhc_cstring_length", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000256), ba_strlen);
        // bhc_peek_array(i64, ptr) -> ptr
        let ba_peek = self.module.llvm_module().add_function("bhc_peek_array", ptr_type.fn_type(&[i64_type.into(), ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000257), ba_peek);

        // ---- Bitcast RTS functions (VarId 1258-1261) ----
        // bhc_float_to_word32(f32) -> i32
        let f32_to_i32 = i32_type.fn_type(&[f32_type.into()], false);
        let float_to_word32 = self.module.llvm_module().add_function("bhc_float_to_word32", f32_to_i32, None);
        self.functions.insert(VarId::new(1000258), float_to_word32);
        // bhc_double_to_word64(f64) -> i64
        let f64_to_i64_bc = i64_type.fn_type(&[f64_type.into()], false);
        let double_to_word64 = self.module.llvm_module().add_function("bhc_double_to_word64", f64_to_i64_bc, None);
        self.functions.insert(VarId::new(1000259), double_to_word64);
        // bhc_word32_to_float(i32) -> f32
        let i32_to_f32 = f32_type.fn_type(&[i32_type.into()], false);
        let word32_to_float = self.module.llvm_module().add_function("bhc_word32_to_float", i32_to_f32, None);
        self.functions.insert(VarId::new(1000260), word32_to_float);
        // bhc_word64_to_double(i64) -> f64
        let i64_to_f64 = f64_type.fn_type(&[i64_type.into()], false);
        let word64_to_double = self.module.llvm_module().add_function("bhc_word64_to_double", i64_to_f64, None);
        self.functions.insert(VarId::new(1000261), word64_to_double);

        // ---- Exception RTS functions (VarId 1080-1091) ----
        // bhc_throw(ptr) -> ptr (stores exception in TLS, returns sentinel null)
        let throw_fn = self.module.llvm_module().add_function("bhc_throw", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000080), throw_fn);
        // bhc_catch(action_fn, action_env, handler_fn, handler_env) -> ptr
        let catch_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let catch_fn = self.module.llvm_module().add_function("bhc_catch", catch_type, None);
        self.functions.insert(VarId::new(1000081), catch_fn);
        // bhc_evaluate(ptr) -> ptr
        let evaluate_fn = self.module.llvm_module().add_function("bhc_evaluate", ptr_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000082), evaluate_fn);
        // bhc_mask(fn_ptr, env_ptr) -> ptr
        let mask_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let mask_fn = self.module.llvm_module().add_function("bhc_mask", mask_type, None);
        self.functions.insert(VarId::new(1000083), mask_fn);
        // bhc_unmask(fn_ptr, env_ptr) -> ptr
        let unmask_fn = self.module.llvm_module().add_function("bhc_unmask", mask_type, None);
        self.functions.insert(VarId::new(1000084), unmask_fn);
        // bhc_finally(action_fn, action_env, cleanup_fn, cleanup_env) -> ptr
        let finally_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let finally_fn = self.module.llvm_module().add_function("bhc_finally", finally_type, None);
        self.functions.insert(VarId::new(1000088), finally_fn);
        // bhc_on_exception(action_fn, action_env, handler_fn, handler_env) -> ptr
        let on_exception_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let on_exception_fn = self.module.llvm_module().add_function("bhc_on_exception", on_exception_type, None);
        self.functions.insert(VarId::new(1000089), on_exception_fn);
        // bhc_bracket(acquire_fn, acquire_env, release_fn, release_env, use_fn, use_env) -> ptr
        let bracket_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let bracket_fn = self.module.llvm_module().add_function("bhc_bracket", bracket_type, None);
        self.functions.insert(VarId::new(1000090), bracket_fn);

        // ---- Additional IO RTS functions (VarId 1300-1314) ----
        // NOTE: Previously used VarId 1085-1099 which collided with exception
        // functions (finally=1088, on_exception=1089, bracket=1090). Moved to
        // 1300+ range to avoid overwriting those entries.
        // bhc_hGetContents(*i8) -> *i8
        let h_get_contents = self.module.llvm_module().add_function("bhc_hGetContents", ptr_to_ptr, None);
        self.functions.insert(VarId::new(1000300), h_get_contents);
        // bhc_hSeek(*i8, i32, i64) -> void
        let h_seek_type = void_type.fn_type(&[ptr_type.into(), i32_type.into(), i64_type.into()], false);
        let h_seek = self.module.llvm_module().add_function("bhc_hSeek", h_seek_type, None);
        self.functions.insert(VarId::new(1000301), h_seek);
        // bhc_hTell(*i8) -> i64
        let h_tell = self.module.llvm_module().add_function("bhc_hTell", i64_type.fn_type(&[ptr_type.into()], false), None);
        self.functions.insert(VarId::new(1000302), h_tell);
        // bhc_hIsOpen(*i8) -> i32
        let h_is_open = self.module.llvm_module().add_function("bhc_hIsOpen", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000303), h_is_open);
        // bhc_hIsClosed(*i8) -> i32
        let h_is_closed = self.module.llvm_module().add_function("bhc_hIsClosed", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000304), h_is_closed);
        // bhc_hIsReadable(*i8) -> i32
        let h_is_readable = self.module.llvm_module().add_function("bhc_hIsReadable", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000305), h_is_readable);
        // bhc_hIsWritable(*i8) -> i32
        let h_is_writable = self.module.llvm_module().add_function("bhc_hIsWritable", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000306), h_is_writable);
        // bhc_hIsSeekable(*i8) -> i32
        let h_is_seekable = self.module.llvm_module().add_function("bhc_hIsSeekable", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000307), h_is_seekable);
        // bhc_hSetBuffering(*i8, i32) -> void
        let h_set_buf_type = void_type.fn_type(&[ptr_type.into(), i32_type.into()], false);
        let h_set_buffering = self.module.llvm_module().add_function("bhc_hSetBuffering", h_set_buf_type, None);
        self.functions.insert(VarId::new(1000308), h_set_buffering);
        // bhc_hGetBuffering(*i8) -> i32
        let h_get_buffering = self.module.llvm_module().add_function("bhc_hGetBuffering", ptr_to_i32, None);
        self.functions.insert(VarId::new(1000309), h_get_buffering);
        // bhc_hPutChar(*i8, i32) -> void
        let h_put_char_type = void_type.fn_type(&[ptr_type.into(), i32_type.into()], false);
        let h_put_char = self.module.llvm_module().add_function("bhc_hPutChar", h_put_char_type, None);
        self.functions.insert(VarId::new(1000310), h_put_char);
        // bhc_create_directory(*i8) -> void
        let create_dir = self.module.llvm_module().add_function("bhc_create_directory", ptr_to_void, None);
        self.functions.insert(VarId::new(1000311), create_dir);
        // bhc_remove_file(*i8) -> void
        let remove_file = self.module.llvm_module().add_function("bhc_remove_file", ptr_to_void, None);
        self.functions.insert(VarId::new(1000312), remove_file);
        // bhc_list_directory(*i8) -> *i8
        let list_dir = self.module.llvm_module().add_function("bhc_list_directory", ptr_to_ptr, None);
        self.functions.insert(VarId::new(1000313), list_dir);
        // bhc_lookupEnv(*i8) -> *i8
        let lookup_env = self.module.llvm_module().add_function("bhc_lookupEnv", ptr_to_ptr, None);
        self.functions.insert(VarId::new(1000314), lookup_env);
        // bhc_get_args() -> *i8 (returns cons-list of C strings)
        let get_args = self.module.llvm_module().add_function("bhc_get_args", void_to_ptr, None);
        self.functions.insert(VarId::new(1000315), get_args);
        // bhc_get_prog_name() -> *i8
        let get_prog_name = self.module.llvm_module().add_function("bhc_get_prog_name", void_to_ptr, None);
        self.functions.insert(VarId::new(1000316), get_prog_name);
        // bhc_get_current_directory() -> *i8
        let get_cur_dir = self.module.llvm_module().add_function("bhc_get_current_directory", void_to_ptr, None);
        self.functions.insert(VarId::new(1000317), get_cur_dir);
    }

    // ========================================================================
    // ADT (Algebraic Data Type) Value Representation
    // ========================================================================
    //
    // ADT values are represented as heap-allocated structs:
    //
    //   struct ADTValue {
    //       i64 tag;          // Constructor tag (0, 1, 2, ...)
    //       ptr fields[];     // Variable-length array of field pointers
    //   }
    //
    // For example, `Just 42` would be:
    //   { tag: 1, fields: [ptr_to_42] }
    //
    // And `Nothing` would be:
    //   { tag: 0, fields: [] }
    // ========================================================================

    /// Get the LLVM struct type for an ADT value with the given arity.
    fn adt_type(&self, arity: u32) -> inkwell::types::StructType<'ctx> {
        let tm = self.type_mapper();
        let tag_type = tm.i64_type();
        let ptr_type = tm.ptr_type();

        // Create array type for fields
        let fields_type = ptr_type.array_type(arity);

        // Struct: { i64 tag, [arity x ptr] fields }
        self.llvm_ctx
            .struct_type(&[tag_type.into(), fields_type.into()], false)
    }

    /// Allocate an ADT value with the given tag and arity.
    fn alloc_adt(&self, tag: u32, arity: u32) -> CodegenResult<PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let adt_ty = self.adt_type(arity);

        // Calculate size: sizeof(i64) + arity * sizeof(ptr)
        let size = 8 + (arity as u64) * 8;

        // Call bhc_alloc
        let alloc_fn = self
            .functions
            .get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;

        let size_val = tm.i64_type().const_int(size, false);
        let raw_ptr = self
            .builder()
            .build_call(*alloc_fn, &[size_val.into()], "adt_alloc")
            .map_err(|e| CodegenError::Internal(format!("failed to call bhc_alloc: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("bhc_alloc returned void".to_string()))?;

        let ptr = raw_ptr.into_pointer_value();

        // Store the tag at offset 0
        let tag_ptr = self
            .builder()
            .build_struct_gep(adt_ty, ptr, 0, "tag_ptr")
            .map_err(|e| CodegenError::Internal(format!("failed to get tag ptr: {:?}", e)))?;

        let tag_val = tm.i64_type().const_int(tag as u64, false);
        self.builder()
            .build_store(tag_ptr, tag_val)
            .map_err(|e| CodegenError::Internal(format!("failed to store tag: {:?}", e)))?;

        Ok(ptr)
    }

    /// Store a field value into an ADT at the given index.
    fn store_adt_field(
        &self,
        adt_ptr: PointerValue<'ctx>,
        arity: u32,
        field_index: u32,
        value: BasicValueEnum<'ctx>,
    ) -> CodegenResult<()> {
        let adt_ty = self.adt_type(arity);
        let tm = self.type_mapper();

        // Get pointer to fields array
        let fields_ptr = self
            .builder()
            .build_struct_gep(adt_ty, adt_ptr, 1, "fields_ptr")
            .map_err(|e| CodegenError::Internal(format!("failed to get fields ptr: {:?}", e)))?;

        // Get pointer to specific field
        let field_ptr = unsafe {
            self.builder()
                .build_in_bounds_gep(
                    tm.ptr_type().array_type(arity),
                    fields_ptr,
                    &[
                        tm.i64_type().const_zero(),
                        tm.i64_type().const_int(field_index as u64, false),
                    ],
                    &format!("field_{}", field_index),
                )
                .map_err(|e| CodegenError::Internal(format!("failed to get field ptr: {:?}", e)))?
        };

        // Convert value to pointer if needed
        let ptr_val = self.value_to_ptr(value)?;
        self.builder()
            .build_store(field_ptr, ptr_val)
            .map_err(|e| CodegenError::Internal(format!("failed to store field: {:?}", e)))?;

        Ok(())
    }

    /// Convert a basic value to a pointer (boxing primitives if needed).
    fn value_to_ptr(&self, value: BasicValueEnum<'ctx>) -> CodegenResult<PointerValue<'ctx>> {
        match value {
            BasicValueEnum::PointerValue(p) => Ok(p),
            BasicValueEnum::IntValue(i) => {
                // Box the integer: cast to pointer
                self.builder()
                    .build_int_to_ptr(i, self.type_mapper().ptr_type(), "box_int")
                    .map_err(|e| CodegenError::Internal(format!("failed to box int: {:?}", e)))
            }
            BasicValueEnum::FloatValue(f) => {
                // Box the float: cast bits to int, then to pointer
                let bits = self
                    .builder()
                    .build_bit_cast(f, self.type_mapper().i64_type(), "float_bits")
                    .map_err(|e| CodegenError::Internal(format!("failed to cast float: {:?}", e)))?
                    .into_int_value();
                self.builder()
                    .build_int_to_ptr(bits, self.type_mapper().ptr_type(), "box_float")
                    .map_err(|e| CodegenError::Internal(format!("failed to box float: {:?}", e)))
            }
            _ => Err(CodegenError::Unsupported(
                "cannot box this value type".to_string(),
            )),
        }
    }

    /// Coerce a value to match a target type.
    /// Used to ensure PHI node operands have consistent types.
    fn coerce_to_type(
        &self,
        value: BasicValueEnum<'ctx>,
        target_type: inkwell::types::BasicTypeEnum<'ctx>,
    ) -> CodegenResult<BasicValueEnum<'ctx>> {
        let value_type = value.get_type();

        // If types already match, no coercion needed
        if value_type == target_type {
            return Ok(value);
        }

        let tm = self.type_mapper();

        match (value, target_type) {
            // Pointer to integer: unbox (ptr_to_int)
            (BasicValueEnum::PointerValue(p), inkwell::types::BasicTypeEnum::IntType(int_ty)) => {
                let int_val = self
                    .builder()
                    .build_ptr_to_int(p, int_ty, "coerce_ptr_to_int")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to coerce ptr to int: {:?}", e))
                    })?;
                Ok(int_val.into())
            }
            // Integer to pointer: box (int_to_ptr)
            (BasicValueEnum::IntValue(i), inkwell::types::BasicTypeEnum::PointerType(_)) => {
                // First extend/truncate to i64 if needed, then convert to pointer
                let i64_val = if i.get_type().get_bit_width() < 64 {
                    self.builder()
                        .build_int_z_extend(i, tm.i64_type(), "extend_to_i64")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to extend int: {:?}", e))
                        })?
                } else if i.get_type().get_bit_width() > 64 {
                    self.builder()
                        .build_int_truncate(i, tm.i64_type(), "truncate_to_i64")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to truncate int: {:?}", e))
                        })?
                } else {
                    i
                };
                let ptr_val = self
                    .builder()
                    .build_int_to_ptr(i64_val, tm.ptr_type(), "coerce_int_to_ptr")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to coerce int to ptr: {:?}", e))
                    })?;
                Ok(ptr_val.into())
            }
            // Pointer to float: unbox (ptr_to_int then bit_cast)
            (
                BasicValueEnum::PointerValue(p),
                inkwell::types::BasicTypeEnum::FloatType(float_ty),
            ) => {
                let bits = self
                    .builder()
                    .build_ptr_to_int(p, tm.i64_type(), "coerce_ptr_to_bits")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to coerce ptr to bits: {:?}", e))
                    })?;
                // For f32, truncate to i32 first, then bit_cast
                let float_val = if float_ty == tm.f32_type() {
                    let bits32 = self
                        .builder()
                        .build_int_truncate(bits, tm.i32_type(), "truncate_bits_f32")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to truncate bits: {:?}", e))
                        })?;
                    self.builder()
                        .build_bit_cast(bits32, float_ty, "coerce_to_f32")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to coerce to f32: {:?}", e))
                        })?
                } else {
                    self.builder()
                        .build_bit_cast(bits, float_ty, "coerce_to_f64")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to coerce to f64: {:?}", e))
                        })?
                };
                Ok(float_val)
            }
            // Float to pointer: box (bit_cast then int_to_ptr)
            (BasicValueEnum::FloatValue(f), inkwell::types::BasicTypeEnum::PointerType(_)) => {
                let bits = self
                    .builder()
                    .build_bit_cast(f, tm.i64_type(), "float_to_bits")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to cast float to bits: {:?}", e))
                    })?
                    .into_int_value();
                let ptr_val = self
                    .builder()
                    .build_int_to_ptr(bits, tm.ptr_type(), "coerce_float_to_ptr")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to coerce float to ptr: {:?}", e))
                    })?;
                Ok(ptr_val.into())
            }
            // Integer width conversion
            (BasicValueEnum::IntValue(i), inkwell::types::BasicTypeEnum::IntType(int_ty)) => {
                let src_bits = i.get_type().get_bit_width();
                let dst_bits = int_ty.get_bit_width();
                let result = if src_bits < dst_bits {
                    self.builder()
                        .build_int_s_extend(i, int_ty, "sext")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to sign extend: {:?}", e))
                        })?
                } else {
                    self.builder()
                        .build_int_truncate(i, int_ty, "trunc")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to truncate: {:?}", e))
                        })?
                };
                Ok(result.into())
            }
            _ => {
                // Types don't match and we don't know how to coerce
                Err(CodegenError::Internal(format!(
                    "cannot coerce {:?} to {:?}",
                    value_type, target_type
                )))
            }
        }
    }

    /// Extract the tag from an ADT value.
    fn extract_adt_tag(&self, adt_ptr: PointerValue<'ctx>) -> CodegenResult<IntValue<'ctx>> {
        // We need to use a generic adt type for reading - use arity 0 since tag is always at offset 0
        let adt_ty = self.adt_type(0);

        let tag_ptr = self
            .builder()
            .build_struct_gep(adt_ty, adt_ptr, 0, "tag_ptr")
            .map_err(|e| CodegenError::Internal(format!("failed to get tag ptr: {:?}", e)))?;

        let tag = self
            .builder()
            .build_load(self.type_mapper().i64_type(), tag_ptr, "tag")
            .map_err(|e| CodegenError::Internal(format!("failed to load tag: {:?}", e)))?;

        Ok(tag.into_int_value())
    }

    /// Extract a field from an ADT value.
    fn extract_adt_field(
        &self,
        adt_ptr: PointerValue<'ctx>,
        arity: u32,
        field_index: u32,
    ) -> CodegenResult<PointerValue<'ctx>> {
        let adt_ty = self.adt_type(arity);
        let tm = self.type_mapper();

        // Get pointer to fields array
        let fields_ptr = self
            .builder()
            .build_struct_gep(adt_ty, adt_ptr, 1, "fields_ptr")
            .map_err(|e| CodegenError::Internal(format!("failed to get fields ptr: {:?}", e)))?;

        // Get pointer to specific field
        let field_ptr = unsafe {
            self.builder()
                .build_in_bounds_gep(
                    tm.ptr_type().array_type(arity),
                    fields_ptr,
                    &[
                        tm.i64_type().const_zero(),
                        tm.i64_type().const_int(field_index as u64, false),
                    ],
                    &format!("field_ptr_{}", field_index),
                )
                .map_err(|e| CodegenError::Internal(format!("failed to get field ptr: {:?}", e)))?
        };

        // Load the field value (which is a pointer)
        let field_val = self
            .builder()
            .build_load(tm.ptr_type(), field_ptr, &format!("field_{}", field_index))
            .map_err(|e| CodegenError::Internal(format!("failed to load field: {:?}", e)))?;

        Ok(field_val.into_pointer_value())
    }

    /// Get the RTS function ID for a builtin name.
    fn rts_function_id(&self, name: &str) -> Option<VarId> {
        match name {
            "print" => Some(VarId::new(1000000)),    // bhc_print_int_ln for Int
            "putStrLn" => Some(VarId::new(1000002)), // bhc_print_string_ln
            "putStr" => Some(VarId::new(1000004)),   // bhc_print_string
            _ => None,
        }
    }

    // ========================================================================
    // Builtin Functions
    // ========================================================================
    //
    // These are common Haskell functions that we implement directly in LLVM
    // for performance (avoiding function call overhead) or because they need
    // special handling.
    // ========================================================================

    /// Check if a name is a builtin function and return its arity.
    fn builtin_info(&self, name: &str) -> Option<u32> {
        match name {
            // List operations
            "head" => Some(1),
            "tail" => Some(1),
            "null" => Some(1),
            "length" => Some(1),
            "take" => Some(2),
            "drop" => Some(2),
            "reverse" => Some(1),
            "append" | "++" => Some(2),
            "enumFromTo" => Some(2),
            "replicate" => Some(2),
            "sum" => Some(1),
            "product" => Some(1),
            "map" => Some(2),
            "filter" => Some(2),
            "foldr" => Some(3),
            "foldl" => Some(3),
            "foldl'" => Some(3),
            "zipWith" => Some(3),
            "zip" => Some(2),
            "last" => Some(1),
            "init" => Some(1),
            "!!" => Some(2),
            "concatMap" => Some(2),
            "concat" => Some(1),

            // Tuple operations
            "fst" => Some(1),
            "snd" => Some(1),

            // Maybe operations
            "fromJust" => Some(1),
            "isJust" => Some(1),
            "isNothing" => Some(1),

            // Either operations
            "isLeft" => Some(1),
            "isRight" => Some(1),

            // Error / Exception handling
            "error" => Some(1),
            "undefined" => Some(0),
            "throw" | "throwIO" => Some(1),
            "catch" => Some(2),
            "try" => Some(1),
            "bracket" => Some(3),
            "finally" | "onException" => Some(2),

            // Misc
            "seq" => Some(2),
            "id" => Some(1),
            "const" => Some(2),
            "not" => Some(1),
            "otherwise" => Some(0),

            // IO operations
            "putStrLn" => Some(1),
            "putStr" => Some(1),
            "putChar" => Some(1),
            "print" => Some(1),
            "getLine" => Some(0),

            // Monadic operations
            ">>=" => Some(2),
            ">>" => Some(2),
            "return" => Some(1),
            "pure" => Some(1),

            // Numeric / math operations
            "negate" => Some(1),
            "abs" => Some(1),
            "signum" => Some(1),
            "sqrt" => Some(1),
            "exp" => Some(1),
            "log" => Some(1),
            "sin" => Some(1),
            "cos" => Some(1),
            "tan" => Some(1),
            "asin" => Some(1),
            "acos" => Some(1),
            "atan" => Some(1),
            "atan2" => Some(2),
            "ceiling" => Some(1),
            "floor" => Some(1),
            "round" => Some(1),
            "truncate" => Some(1),
            "fromIntegral" => Some(1),
            "toInteger" => Some(1),

            // Character operations
            "ord" => Some(1),
            "chr" => Some(1),
            "isAlpha" => Some(1),
            "isAlphaNum" => Some(1),
            "isAscii" => Some(1),
            "isControl" => Some(1),
            "isDigit" => Some(1),
            "isHexDigit" => Some(1),
            "isLetter" => Some(1),
            "isLower" => Some(1),
            "isNumber" => Some(1),
            "isPrint" => Some(1),
            "isPunctuation" => Some(1),
            "isSpace" => Some(1),
            "isSymbol" => Some(1),
            "isUpper" => Some(1),
            "toLower" => Some(1),
            "toUpper" => Some(1),
            "digitToInt" => Some(1),
            "intToDigit" => Some(1),

            // Advanced list operations
            "scanl" => Some(3),
            "scanl'" => Some(3),
            "scanr" => Some(3),
            "scanr1" => Some(2),
            "find" => Some(2),
            "elem" => Some(2),
            "notElem" => Some(2),
            "lookup" => Some(2),
            "partition" => Some(2),
            "span" => Some(2),
            "lines" => Some(1),
            "unlines" => Some(1),
            "words" => Some(1),
            "unwords" => Some(1),
            "nub" => Some(1),
            "delete" => Some(2),
            "union" => Some(2),
            "intersect" => Some(2),
            "sort" => Some(1),
            "sortBy" => Some(2),
            "intercalate" => Some(2),
            "intersperse" => Some(2),
            "transpose" => Some(1),
            "group" => Some(1),
            "splitAt" => Some(2),
            "break" => Some(2),
            "any" => Some(2),
            "all" => Some(2),
            "and" => Some(1),
            "or" => Some(1),
            "maximum" => Some(1),
            "minimum" => Some(1),
            "iterate" => Some(2),
            "unfoldr" => Some(2),
            "cycle" => Some(1),
            "repeat" => Some(1),
            "takeWhile" => Some(2),
            "dropWhile" => Some(2),
            "zipWith3" => Some(4),
            "zip3" => Some(3),
            "unzip" => Some(1),

            // IO & System operations
            "readFile" => Some(1),
            "writeFile" => Some(2),
            "appendFile" => Some(2),
            "openFile" => Some(2),
            "hClose" => Some(1),
            "hGetChar" => Some(1),
            "hGetLine" => Some(1),
            "hPutStr" => Some(2),
            "hPutStrLn" => Some(2),
            "hFlush" => Some(1),
            "hIsEOF" => Some(1),
            "hSetBuffering" => Some(2),
            "stdin" => Some(0),
            "stdout" => Some(0),
            "stderr" => Some(0),
            "doesFileExist" => Some(1),
            "doesDirectoryExist" => Some(1),
            "removeFile" => Some(1),
            "getArgs" => Some(0),
            "getProgName" => Some(0),
            "getEnv" => Some(1),
            "lookupEnv" => Some(1),
            "exitSuccess" => Some(0),
            "exitFailure" => Some(0),
            "exitWith" => Some(1),
            "hGetContents" => Some(1),
            "getCurrentDirectory" => Some(0),
            "createDirectory" => Some(1),
            "listDirectory" => Some(1),

            // Monadic / higher-order operations
            "fmap" => Some(2),
            "<$>" => Some(2),
            "<*>" => Some(2),
            "join" => Some(1),
            "=<<" => Some(2),
            "when" => Some(2),
            "unless" => Some(2),
            "void" => Some(1),
            "mapM" => Some(2),
            "mapM_" => Some(2),
            "forM" => Some(2),
            "forM_" => Some(2),
            "sequence" => Some(1),
            "sequence_" => Some(1),
            "forever" => Some(1),

            // Data.Function
            "flip" => Some(3),
            "on" => Some(4),
            "fix" => Some(1),
            "$" => Some(2),
            "." => Some(3),

            // Show
            "show" => Some(1),

                // Data.Map operations
                "Data.Map.empty" => Some(0),
                "Data.Map.singleton" => Some(2),
                "Data.Map.null" => Some(1),
                "Data.Map.size" => Some(1),
                "Data.Map.member" => Some(2),
                "Data.Map.notMember" => Some(2),
                "Data.Map.lookup" => Some(2),
                "Data.Map.findWithDefault" => Some(3),
                "Data.Map.!" => Some(2),
                "Data.Map.insert" => Some(3),
                "Data.Map.insertWith" => Some(4),
                "Data.Map.delete" => Some(2),
                "Data.Map.adjust" => Some(3),
                "Data.Map.update" => Some(3),
                "Data.Map.alter" => Some(3),
                "Data.Map.union" => Some(2),
                "Data.Map.unionWith" => Some(3),
                "Data.Map.unionWithKey" => Some(4),
                "Data.Map.unions" => Some(1),
                "Data.Map.intersection" => Some(2),
                "Data.Map.intersectionWith" => Some(3),
                "Data.Map.difference" => Some(2),
                "Data.Map.differenceWith" => Some(3),
                "Data.Map.map" => Some(2),
                "Data.Map.mapWithKey" => Some(2),
                "Data.Map.mapKeys" => Some(2),
                "Data.Map.filter" => Some(2),
                "Data.Map.filterWithKey" => Some(2),
                "Data.Map.foldr" => Some(3),
                "Data.Map.foldl" => Some(3),
                "Data.Map.foldrWithKey" => Some(3),
                "Data.Map.foldlWithKey" => Some(3),
                "Data.Map.keys" => Some(1),
                "Data.Map.elems" => Some(1),
                "Data.Map.assocs" => Some(1),
                "Data.Map.toList" => Some(1),
                "Data.Map.toAscList" => Some(1),
                "Data.Map.toDescList" => Some(1),
                "Data.Map.fromList" => Some(1),
                "Data.Map.fromListWith" => Some(2),
                "Data.Map.keysSet" => Some(1),
                "Data.Map.isSubmapOf" => Some(2),
                // Data.Set operations
                "Data.Set.empty" => Some(0),
                "Data.Set.singleton" => Some(1),
                "Data.Set.null" => Some(1),
                "Data.Set.size" => Some(1),
                "Data.Set.member" => Some(2),
                "Data.Set.notMember" => Some(2),
                "Data.Set.insert" => Some(2),
                "Data.Set.delete" => Some(2),
                "Data.Set.union" => Some(2),
                "Data.Set.unions" => Some(1),
                "Data.Set.intersection" => Some(2),
                "Data.Set.difference" => Some(2),
                "Data.Set.isSubsetOf" => Some(2),
                "Data.Set.isProperSubsetOf" => Some(2),
                "Data.Set.map" => Some(2),
                "Data.Set.filter" => Some(2),
                "Data.Set.partition" => Some(2),
                "Data.Set.foldr" => Some(3),
                "Data.Set.foldl" => Some(3),
                "Data.Set.toList" => Some(1),
                "Data.Set.toAscList" => Some(1),
                "Data.Set.toDescList" => Some(1),
                "Data.Set.fromList" => Some(1),
                "Data.Set.findMin" => Some(1),
                "Data.Set.findMax" => Some(1),
                "Data.Set.deleteMin" => Some(1),
                "Data.Set.deleteMax" => Some(1),
                "Data.Set.elems" => Some(1),
                "Data.Set.lookupMin" => Some(1),
                "Data.Set.lookupMax" => Some(1),
                // Data.IntMap operations
                "Data.IntMap.empty" => Some(0),
                "Data.IntMap.singleton" => Some(2),
                "Data.IntMap.null" => Some(1),
                "Data.IntMap.size" => Some(1),
                "Data.IntMap.member" => Some(2),
                "Data.IntMap.lookup" => Some(2),
                "Data.IntMap.findWithDefault" => Some(3),
                "Data.IntMap.insert" => Some(3),
                "Data.IntMap.insertWith" => Some(4),
                "Data.IntMap.delete" => Some(2),
                "Data.IntMap.adjust" => Some(3),
                "Data.IntMap.union" => Some(2),
                "Data.IntMap.unionWith" => Some(3),
                "Data.IntMap.intersection" => Some(2),
                "Data.IntMap.difference" => Some(2),
                "Data.IntMap.map" => Some(2),
                "Data.IntMap.mapWithKey" => Some(2),
                "Data.IntMap.filter" => Some(2),
                "Data.IntMap.foldr" => Some(3),
                "Data.IntMap.foldlWithKey" => Some(3),
                "Data.IntMap.keys" => Some(1),
                "Data.IntMap.elems" => Some(1),
                "Data.IntMap.toList" => Some(1),
                "Data.IntMap.toAscList" => Some(1),
                "Data.IntMap.fromList" => Some(1),
                // Data.IntSet operations
                "Data.IntSet.empty" => Some(0),
                "Data.IntSet.singleton" => Some(1),
                "Data.IntSet.null" => Some(1),
                "Data.IntSet.size" => Some(1),
                "Data.IntSet.member" => Some(2),
                "Data.IntSet.insert" => Some(2),
                "Data.IntSet.delete" => Some(2),
                "Data.IntSet.union" => Some(2),
                "Data.IntSet.intersection" => Some(2),
                "Data.IntSet.difference" => Some(2),
                "Data.IntSet.isSubsetOf" => Some(2),
                "Data.IntSet.filter" => Some(2),
                "Data.IntSet.foldr" => Some(3),
                "Data.IntSet.toList" => Some(1),
                "Data.IntSet.fromList" => Some(1),

            // Identity operations
            "Identity" => Some(1),
            "runIdentity" => Some(1),
            "Identity.fmap" => Some(2),
            "Identity.pure" => Some(1),
            "Identity.<*>" => Some(2),
            "Identity.>>=" => Some(2),
            "Identity.>>" => Some(2),

            // ReaderT operations
            "ReaderT" => Some(1),
            "runReaderT" => Some(2),
            "ReaderT.fmap" => Some(2),
            "ReaderT.pure" => Some(1),
            "ReaderT.<*>" => Some(2),
            "ReaderT.>>=" => Some(2),
            "ReaderT.>>" => Some(2),
            "ReaderT.lift" => Some(1),
            "ReaderT.liftIO" => Some(1),
            "ask" => Some(0),
            "asks" => Some(1),
            "local" => Some(2),

            // StateT operations
            "StateT" => Some(1),
            "runStateT" => Some(2),
            "StateT.fmap" => Some(2),
            "StateT.pure" => Some(1),
            "StateT.<*>" => Some(2),
            "StateT.>>=" => Some(2),
            "StateT.>>" => Some(2),
            "StateT.lift" => Some(1),
            "StateT.liftIO" => Some(1),
            "get" => Some(0),
            "put" => Some(1),
            "modify" => Some(1),
            "gets" => Some(1),
            "evalStateT" => Some(2),
            "execStateT" => Some(2),

            // ExceptT operations
            "ExceptT" => Some(1),
            "runExceptT" => Some(1),
            "ExceptT.fmap" => Some(2),
            "ExceptT.pure" => Some(1),
            "ExceptT.<*>" => Some(2),
            "ExceptT.>>=" => Some(2),
            "ExceptT.>>" => Some(2),
            "ExceptT.lift" => Some(1),
            "ExceptT.liftIO" => Some(1),
            "throwE" => Some(1),
            "catchE" => Some(2),

            // WriterT operations
            "WriterT" => Some(1),
            "runWriterT" => Some(1),
            "WriterT.fmap" => Some(2),
            "WriterT.pure" => Some(1),
            "WriterT.<*>" => Some(2),
            "WriterT.>>=" => Some(2),
            "WriterT.>>" => Some(2),
            "WriterT.lift" => Some(1),
            "WriterT.liftIO" => Some(1),
            "tell" => Some(1),
            "execWriterT" => Some(1),

            _ => {
                // Check for field selector pattern: $sel_N where N is a digit
                if name.starts_with("$sel_") {
                    if let Ok(_) = name[5..].parse::<usize>() {
                        return Some(1); // Field selectors take one argument (the tuple/dict)
                    }
                }
                None
            }
        }
    }

    /// Check if an expression is a saturated builtin function application.
    fn is_saturated_builtin<'a>(&self, expr: &'a Expr) -> Option<(&'a str, Vec<&'a Expr>)> {
        // Collect arguments while unwrapping applications
        let mut args = Vec::new();
        let mut current = expr;

        while let Expr::App(func, arg, _) = current {
            args.push(arg.as_ref());
            current = func.as_ref();
        }

        // Check if the head is a builtin function
        if let Expr::Var(var, _) = current {
            let name = var.name.as_str();
            if let Some(arity) = self.builtin_info(name) {
                args.reverse();
                if args.len() == arity as usize {
                    return Some((name, args));
                }
            }
        }

        None
    }

    /// Lower a builtin function application.
    fn lower_builtin(
        &mut self,
        name: &str,
        args: &[&Expr],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        match name {
            // List operations
            "head" => self.lower_builtin_head(args[0]),
            "tail" => self.lower_builtin_tail(args[0]),
            "null" => self.lower_builtin_null(args[0]),
            "length" => self.lower_builtin_length(args[0]),
            "take" => self.lower_builtin_take(args[0], args[1]),
            "drop" => self.lower_builtin_drop(args[0], args[1]),
            "reverse" => self.lower_builtin_reverse(args[0]),
            "append" | "++" => self.lower_builtin_append(args[0], args[1]),
            "enumFromTo" => self.lower_builtin_enum_from_to(args[0], args[1]),
            "replicate" => self.lower_builtin_replicate(args[0], args[1]),
            "sum" => self.lower_builtin_sum(args[0]),
            "product" => self.lower_builtin_product(args[0]),
            "map" => self.lower_builtin_map(args[0], args[1]),
            "filter" => self.lower_builtin_filter(args[0], args[1]),
            "foldr" => self.lower_builtin_foldr(args[0], args[1], args[2]),
            "foldl" => self.lower_builtin_foldl(args[0], args[1], args[2]),
            "foldl'" => self.lower_builtin_foldl_strict(args[0], args[1], args[2]),
            "zipWith" => self.lower_builtin_zipwith(args[0], args[1], args[2]),
            "zip" => self.lower_builtin_zip(args[0], args[1]),
            "last" => self.lower_builtin_last(args[0]),
            "init" => self.lower_builtin_init(args[0]),
            "!!" => self.lower_builtin_index(args[0], args[1]),
            "concatMap" => self.lower_builtin_concat_map(args[0], args[1]),
            "concat" => self.lower_builtin_concat(args[0]),

            // Tuple operations
            "fst" => self.lower_builtin_fst(args[0]),
            "snd" => self.lower_builtin_snd(args[0]),

            // Maybe operations
            "fromJust" => self.lower_builtin_from_just(args[0]),
            "isJust" => self.lower_builtin_is_just(args[0]),
            "isNothing" => self.lower_builtin_is_nothing(args[0]),

            // Either operations
            "isLeft" => self.lower_builtin_is_left(args[0]),
            "isRight" => self.lower_builtin_is_right(args[0]),

            // Error / Exception handling
            "error" => self.lower_builtin_error(args[0]),
            "undefined" => self.lower_builtin_undefined(),
            "throw" | "throwIO" => self.lower_builtin_throw(args[0]),
            "catch" => self.lower_builtin_catch(args[0], args[1]),
            "try" => self.lower_builtin_try(args[0]),
            "bracket" => self.lower_builtin_bracket(args[0], args[1], args[2]),
            "finally" => self.lower_builtin_finally(args[0], args[1]),
            "onException" => self.lower_builtin_on_exception(args[0], args[1]),

            // Misc
            "seq" => self.lower_builtin_seq(args[0], args[1]),
            "id" => self.lower_expr(args[0]),
            "const" => self.lower_expr(args[0]),
            "not" => self.lower_builtin_not(args[0]),
            "otherwise" => Ok(Some(
                self.type_mapper().i64_type().const_int(1, false).into(),
            )),

            // IO operations
            "putStrLn" => self.lower_builtin_put_str_ln(args[0]),
            "putStr" => self.lower_builtin_put_str(args[0]),
            "putChar" => self.lower_builtin_put_char(args[0]),
            "print" => self.lower_builtin_print(args[0]),
            "getLine" => self.lower_builtin_get_line(),

            // Monadic operations  dispatch based on monad context.
            // Push the detected context so that nested operations (e.g. return
            // inside a bind continuation) also dispatch to the correct monad.
            ">>=" => {
                let monad = self.detect_monad_from_expr(args[0]);
                self.push_monad_context(monad);
                let result = match monad {
                    MonadContext::ReaderT => self.lower_builtin_reader_t_bind(args[0], args[1]),
                    MonadContext::StateT => self.lower_builtin_state_t_bind(args[0], args[1]),
                    MonadContext::ExceptT => self.lower_builtin_except_t_bind(args[0], args[1]),
                    MonadContext::WriterT => self.lower_builtin_writer_t_bind(args[0], args[1]),
                    MonadContext::IO => self.lower_builtin_bind(args[0], args[1]),
                };
                self.pop_monad_context();
                result
            }
            ">>" => {
                let monad = self.detect_monad_from_expr(args[0]);
                self.push_monad_context(monad);
                let result = match monad {
                    MonadContext::ReaderT => self.lower_builtin_reader_t_then(args[0], args[1]),
                    MonadContext::StateT => self.lower_builtin_state_t_then(args[0], args[1]),
                    MonadContext::ExceptT => self.lower_builtin_except_t_then(args[0], args[1]),
                    MonadContext::WriterT => self.lower_builtin_writer_t_then(args[0], args[1]),
                    MonadContext::IO => self.lower_builtin_then(args[0], args[1]),
                };
                self.pop_monad_context();
                result
            }
            "return" | "pure" => {
                match self.current_monad_context() {
                    MonadContext::ReaderT => self.lower_builtin_reader_t_pure(args[0]),
                    MonadContext::StateT => self.lower_builtin_state_t_pure(args[0]),
                    MonadContext::ExceptT => self.lower_builtin_except_t_pure(args[0]),
                    MonadContext::WriterT => self.lower_builtin_writer_t_pure(args[0]),
                    MonadContext::IO => self.lower_builtin_return(args[0]),
                }
            }

            // Numeric / Math operations
            "negate" => self.lower_builtin_negate(args[0]),
            "abs" => self.lower_builtin_abs(args[0]),
            "signum" => self.lower_builtin_signum(args[0]),
            "sqrt" => self.lower_builtin_math_unary(args[0], 1013, "sqrt"),
            "exp" => self.lower_builtin_math_unary(args[0], 1014, "exp"),
            "log" => self.lower_builtin_math_unary(args[0], 1015, "log"),
            "sin" => self.lower_builtin_math_unary(args[0], 1016, "sin"),
            "cos" => self.lower_builtin_math_unary(args[0], 1017, "cos"),
            "tan" => self.lower_builtin_math_unary(args[0], 1018, "tan"),
            "asin" => self.lower_builtin_math_unary(args[0], 1019, "asin"),
            "acos" => self.lower_builtin_math_unary(args[0], 1020, "acos"),
            "atan" => self.lower_builtin_math_unary(args[0], 1021, "atan"),
            "atan2" => self.lower_builtin_math_binary(args[0], args[1], 1022, "atan2"),
            "ceiling" => self.lower_builtin_float_to_int(args[0], 1023, "ceiling"),
            "floor" => self.lower_builtin_float_to_int(args[0], 1024, "floor"),
            "round" => self.lower_builtin_float_to_int(args[0], 1025, "round"),
            "truncate" => self.lower_builtin_float_to_int(args[0], 1026, "truncate"),

            // Character operations
            "ord" => self.lower_builtin_ord(args[0]),
            "chr" => self.lower_builtin_chr(args[0]),
            "isAlpha" => self.lower_builtin_char_pred(args[0], 1030, "is_alpha"),
            "isDigit" => self.lower_builtin_char_pred(args[0], 1031, "is_digit"),
            "isAlphaNum" => self.lower_builtin_char_pred(args[0], 1032, "is_alnum"),
            "isSpace" => self.lower_builtin_char_pred(args[0], 1033, "is_space"),
            "isUpper" => self.lower_builtin_char_pred(args[0], 1034, "is_upper"),
            "isLower" => self.lower_builtin_char_pred(args[0], 1035, "is_lower"),
            "isPrint" => self.lower_builtin_char_pred(args[0], 1038, "is_print"),
            "isAscii" => self.lower_builtin_char_pred(args[0], 1039, "is_ascii"),
            "isControl" => self.lower_builtin_char_pred(args[0], 1040, "is_control"),
            "isHexDigit" => self.lower_builtin_char_pred(args[0], 1041, "is_hex"),
            "isLetter" => self.lower_builtin_char_pred(args[0], 1042, "is_letter"),
            "isNumber" => self.lower_builtin_char_pred(args[0], 1043, "is_number"),
            "isPunctuation" => self.lower_builtin_char_pred(args[0], 1044, "is_punct"),
            "isSymbol" => self.lower_builtin_char_pred(args[0], 1045, "is_symbol"),
            "toLower" => self.lower_builtin_char_conv(args[0], 1037, "to_lower"),
            "toUpper" => self.lower_builtin_char_conv(args[0], 1036, "to_upper"),
            "digitToInt" => self.lower_builtin_digit_to_int(args[0]),
            "intToDigit" => self.lower_builtin_int_to_digit(args[0]),

            // IO & System operations
            "readFile" => self.lower_builtin_read_file(args[0]),
            "writeFile" => self.lower_builtin_write_file(args[0], args[1]),
            "appendFile" => self.lower_builtin_append_file(args[0], args[1]),
            "openFile" => self.lower_builtin_open_file(args[0], args[1]),
            "hClose" => self.lower_builtin_hclose(args[0]),
            "hGetChar" => self.lower_builtin_hgetchar(args[0]),
            "hGetLine" => self.lower_builtin_hgetline(args[0]),
            "hPutStr" => self.lower_builtin_hputstr(args[0], args[1]),
            "hPutStrLn" => self.lower_builtin_hputstrln(args[0], args[1]),
            "hFlush" => self.lower_builtin_hflush(args[0]),
            "hIsEOF" => self.lower_builtin_hiseof(args[0]),
            "hSetBuffering" => self.lower_builtin_hset_buffering(args[0], args[1]),
            "stdin" => self.lower_builtin_std_handle(1060, "stdin"),
            "stdout" => self.lower_builtin_std_handle(1061, "stdout"),
            "stderr" => self.lower_builtin_std_handle(1062, "stderr"),
            "doesFileExist" => self.lower_builtin_file_pred(args[0], 1000063, "exists"),
            "doesDirectoryExist" => self.lower_builtin_file_pred(args[0], 1000064, "is_dir"),
            "removeFile" => self.lower_builtin_remove_file(args[0]),
            "getArgs" => self.lower_builtin_get_args(),
            "getProgName" => self.lower_builtin_get_prog_name(),
            "getEnv" => self.lower_builtin_get_env(args[0]),
            "lookupEnv" => self.lower_builtin_lookup_env(args[0]),
            "exitSuccess" => self.lower_builtin_exit_success(),
            "exitFailure" => self.lower_builtin_exit_failure(),
            "exitWith" => self.lower_builtin_exit_with(args[0]),
            "hGetContents" => self.lower_builtin_hgetcontents(args[0]),
            "getCurrentDirectory" => self.lower_builtin_get_current_directory(),
            "createDirectory" => self.lower_builtin_create_directory(args[0]),
            "listDirectory" => self.lower_builtin_list_directory(args[0]),

            // Higher-order / Monadic operations
            "fmap" | "<$>" => self.lower_builtin_fmap(args[0], args[1]),
            "<*>" => self.lower_builtin_ap(args[0], args[1]),
            "join" => self.lower_builtin_join(args[0]),
            "=<<" => self.lower_builtin_bind_flipped(args[0], args[1]),
            "when" => self.lower_builtin_when(args[0], args[1]),
            "unless" => self.lower_builtin_unless(args[0], args[1]),
            "void" => self.lower_builtin_void(args[0]),
            "mapM" => self.lower_builtin_mapm(args[0], args[1]),
            "mapM_" => self.lower_builtin_mapm_(args[0], args[1]),
            "forM" => self.lower_builtin_mapm(args[1], args[0]),
            "forM_" => self.lower_builtin_mapm_(args[1], args[0]),
            "sequence" => self.lower_builtin_sequence(args[0]),
            "sequence_" => self.lower_builtin_sequence_(args[0]),
            "forever" => self.lower_builtin_forever(args[0]),

            // Data.Function
            "flip" => self.lower_builtin_flip(args[0], args[1], args[2]),
            "on" => self.lower_builtin_on(args[0], args[1], args[2], args[3]),
            "fix" => self.lower_builtin_fix(args[0]),
            "$" => self.lower_builtin_apply(args[0], args[1]),
            "." => self.lower_builtin_compose(args[0], args[1], args[2]),

            // Show
            "show" => self.lower_builtin_show(args[0]),

            // Advanced list operations (delegate to existing patterns)
            "any" => self.lower_builtin_any(args[0], args[1]),
            "all" => self.lower_builtin_all(args[0], args[1]),
            "and" => self.lower_builtin_and(args[0]),
            "or" => self.lower_builtin_or(args[0]),
            "maximum" => self.lower_builtin_maximum(args[0]),
            "minimum" => self.lower_builtin_minimum(args[0]),
            "elem" => self.lower_builtin_elem(args[0], args[1]),
            "notElem" => self.lower_builtin_not_elem(args[0], args[1]),
            "iterate" => self.lower_builtin_iterate(args[0], args[1]),
            "repeat" => self.lower_builtin_repeat(args[0]),
            "cycle" => self.lower_builtin_cycle(args[0]),
            "takeWhile" => self.lower_builtin_take_while(args[0], args[1]),
            "dropWhile" => self.lower_builtin_drop_while(args[0], args[1]),
            "span" => self.lower_builtin_span(args[0], args[1]),
            "break" => self.lower_builtin_break(args[0], args[1]),
            "splitAt" => self.lower_builtin_split_at(args[0], args[1]),
            "find" => self.lower_builtin_find(args[0], args[1]),
            "lookup" => self.lower_builtin_lookup(args[0], args[1]),
            "partition" => self.lower_builtin_partition(args[0], args[1]),
            "intersperse" => self.lower_builtin_intersperse(args[0], args[1]),
            "intercalate" => self.lower_builtin_intercalate(args[0], args[1]),
            "transpose" => self.lower_builtin_transpose(args[0]),
            "nub" => self.lower_builtin_nub(args[0]),
            "sort" => self.lower_builtin_sort(args[0]),
            "sortBy" => self.lower_builtin_sort_by(args[0], args[1]),
            "group" => self.lower_builtin_group(args[0]),
            "delete" => self.lower_builtin_delete(args[0], args[1]),
            "union" => self.lower_builtin_union(args[0], args[1]),
            "intersect" => self.lower_builtin_intersect(args[0], args[1]),
            "scanl" => self.lower_builtin_scanl(args[0], args[1], args[2]),
            "scanl'" => self.lower_builtin_scanl(args[0], args[1], args[2]),
            "scanr" => self.lower_builtin_scanr(args[0], args[1], args[2]),
            "scanr1" => self.lower_builtin_scanr1(args[0], args[1]),
            "unfoldr" => self.lower_builtin_unfoldr(args[0], args[1]),
            "lines" => self.lower_builtin_lines(args[0]),
            "unlines" => self.lower_builtin_unlines(args[0]),
            "words" => self.lower_builtin_words(args[0]),
            "unwords" => self.lower_builtin_unwords(args[0]),
            "zip3" => self.lower_builtin_zip3(args[0], args[1], args[2]),
            "zipWith3" => self.lower_builtin_zipwith3(args[0], args[1], args[2], args[3]),
            "unzip" => self.lower_builtin_unzip(args[0]),

                // Data.Map operations
                "Data.Map.empty" => self.lower_builtin_map_empty(),
                "Data.Map.singleton" => self.lower_builtin_map_singleton(args[0], args[1]),
                "Data.Map.null" => self.lower_builtin_map_null(args[0]),
                "Data.Map.size" => self.lower_builtin_map_size(args[0]),
                "Data.Map.member" => self.lower_builtin_map_member(args[0], args[1]),
                "Data.Map.notMember" => {
                    // Note: result needs inversion, but stub for now
                    self.lower_builtin_map_member(args[0], args[1])
                }
                "Data.Map.lookup" => self.lower_builtin_map_lookup(args[0], args[1]),
                "Data.Map.findWithDefault" => self.lower_builtin_map_find_with_default(args[0], args[1], args[2]),
                "Data.Map.!" => self.lower_builtin_map_find_with_default(args[1], args[0], args[1]),
                "Data.Map.insert" => self.lower_builtin_map_insert(args[0], args[1], args[2]),
                "Data.Map.delete" => self.lower_builtin_map_delete(args[0], args[1]),
                "Data.Map.union" => self.lower_builtin_map_union(args[0], args[1]),
                "Data.Map.intersection" => self.lower_builtin_map_intersection(args[0], args[1]),
                "Data.Map.difference" => self.lower_builtin_map_difference(args[0], args[1]),
                "Data.Map.isSubmapOf" => self.lower_builtin_map_is_submap_of(args[0], args[1]),
                "Data.Map.map" => self.lower_builtin_map_map(args[0], args[1]),
                "Data.Map.filter" => self.lower_builtin_map_filter(args[0], args[1]),
                "Data.Map.foldr" => self.lower_builtin_map_foldr(args[0], args[1], args[2]),
                "Data.Map.foldl" => self.lower_builtin_map_foldl(args[0], args[1], args[2]),
                "Data.Map.mapWithKey" => self.lower_builtin_map_map_with_key(args[0], args[1]),
                "Data.Map.filterWithKey" => self.lower_builtin_map_filter_with_key(args[0], args[1]),
                "Data.Map.foldlWithKey" | "Data.Map.foldlWithKey'" => self.lower_builtin_map_foldl_with_key(args[0], args[1], args[2]),
                "Data.Map.foldrWithKey" => self.lower_builtin_map_foldr_with_key(args[0], args[1], args[2]),
                "Data.Map.unionWith" | "Data.Map.unionWithKey" => self.lower_builtin_map_union_with(args[0], args[1], args[2]),
                "Data.Map.intersectionWith" => self.lower_builtin_map_intersection_with(args[0], args[1], args[2]),
                "Data.Map.differenceWith" => self.lower_builtin_map_difference_with(args[0], args[1], args[2]),
                "Data.Map.insertWith" => self.lower_builtin_map_insert_with(args[0], args[1], args[2], args[3]),
                "Data.Map.adjust" => self.lower_builtin_map_adjust(args[0], args[1], args[2]),
                "Data.Map.mapKeys" => self.lower_builtin_map_map_keys(args[0], args[1]),
                "Data.Map.fromListWith" => self.lower_builtin_map_from_list_with(args[0], args[1]),
                "Data.Map.update" | "Data.Map.alter" | "Data.Map.unions" => {
                    let arg_exprs: Vec<&Expr> = args.iter().copied().collect();
                    self.lower_builtin_container_ho_stub(&arg_exprs, name)
                }
                "Data.Map.keys" => self.lower_builtin_map_keys(args[0]),
                "Data.Map.elems" => self.lower_builtin_map_elems(args[0]),
                "Data.Map.assocs" | "Data.Map.toList" | "Data.Map.toAscList"
                | "Data.Map.toDescList" => {
                    self.lower_builtin_map_to_list(args[0])
                }
                "Data.Map.keysSet" => {
                    // keysSet returns a Set, not a list  stub for now
                    self.lower_builtin_set_empty()
                }
                "Data.Map.fromList" => self.lower_builtin_map_from_list(args[0]),

                // Data.Set operations
                "Data.Set.empty" => self.lower_builtin_set_empty(),
                "Data.Set.singleton" => self.lower_builtin_set_singleton(args[0]),
                "Data.Set.null" => self.lower_builtin_set_null(args[0]),
                "Data.Set.size" => self.lower_builtin_set_size(args[0]),
                "Data.Set.member" | "Data.Set.notMember" => self.lower_builtin_set_member(args[0], args[1]),
                "Data.Set.insert" => self.lower_builtin_set_insert(args[0], args[1]),
                "Data.Set.delete" => self.lower_builtin_set_delete(args[0], args[1]),
                "Data.Set.union" => self.lower_builtin_set_binary(args[0], args[1], 1127, "set_union"),
                "Data.Set.intersection" => self.lower_builtin_set_binary(args[0], args[1], 1128, "set_intersection"),
                "Data.Set.difference" => self.lower_builtin_set_binary(args[0], args[1], 1129, "set_difference"),
                "Data.Set.isSubsetOf" => self.lower_builtin_set_predicate(args[0], args[1], 1130, "set_is_subset_of"),
                "Data.Set.isProperSubsetOf" => self.lower_builtin_set_predicate(args[0], args[1], 1131, "set_is_proper_subset_of"),
                "Data.Set.findMin" => self.lower_builtin_set_find_extremum(args[0], 1132, "set_find_min"),
                "Data.Set.findMax" => self.lower_builtin_set_find_extremum(args[0], 1133, "set_find_max"),
                "Data.Set.deleteMin" => self.lower_builtin_set_delete_extremum(args[0], 1134, "set_delete_min"),
                "Data.Set.deleteMax" => self.lower_builtin_set_delete_extremum(args[0], 1135, "set_delete_max"),
                "Data.Set.lookupMin" => self.lower_builtin_set_lookup_extremum(args[0], 1132, "set_lookup_min"),
                "Data.Set.lookupMax" => self.lower_builtin_set_lookup_extremum(args[0], 1133, "set_lookup_max"),
                "Data.Set.map" => self.lower_builtin_set_map(args[0], args[1]),
                "Data.Set.filter" => self.lower_builtin_set_filter(args[0], args[1]),
                "Data.Set.foldr" => self.lower_builtin_set_foldr(args[0], args[1], args[2]),
                "Data.Set.foldl" => self.lower_builtin_set_foldl(args[0], args[1], args[2]),
                "Data.Set.unions" | "Data.Set.partition" => {
                    let arg_exprs: Vec<&Expr> = args.iter().copied().collect();
                    self.lower_builtin_container_ho_stub(&arg_exprs, name)
                }
                "Data.Set.toList" | "Data.Set.toAscList" | "Data.Set.toDescList" | "Data.Set.elems" => {
                    self.lower_builtin_set_to_list(args[0])
                }
                "Data.Set.fromList" => self.lower_builtin_set_from_list(args[0]),

                // Data.IntMap operations
                "Data.IntMap.empty" => {
                    let rts_fn = self.functions.get(&VarId::new(1000140)).ok_or_else(|| {
                        CodegenError::Internal("bhc_intmap_empty not declared".to_string())
                    })?;
                    let result = self.builder()
                        .build_call(*rts_fn, &[], "intmap_empty")
                        .map_err(|e| CodegenError::Internal(format!("intmap_empty: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("intmap_empty: void".to_string()))?;
                    Ok(Some(result))
                }
                "Data.IntMap.singleton" => self.lower_builtin_map_singleton(args[0], args[1]),
                "Data.IntMap.null" => self.lower_builtin_map_null(args[0]),
                "Data.IntMap.size" => self.lower_builtin_map_size(args[0]),
                "Data.IntMap.member" => self.lower_builtin_map_member(args[0], args[1]),
                "Data.IntMap.lookup" => self.lower_builtin_map_lookup(args[0], args[1]),
                "Data.IntMap.findWithDefault" => self.lower_builtin_map_find_with_default(args[0], args[1], args[2]),
                "Data.IntMap.insert" => self.lower_builtin_map_insert(args[0], args[1], args[2]),
                "Data.IntMap.delete" => self.lower_builtin_map_delete(args[0], args[1]),
                "Data.IntMap.union" => self.lower_builtin_map_union(args[0], args[1]),
                "Data.IntMap.intersection" => self.lower_builtin_map_intersection(args[0], args[1]),
                "Data.IntMap.difference" => self.lower_builtin_map_difference(args[0], args[1]),
                "Data.IntMap.map" => self.lower_builtin_map_map(args[0], args[1]),
                "Data.IntMap.filter" => self.lower_builtin_map_filter(args[0], args[1]),
                "Data.IntMap.foldr" => self.lower_builtin_map_foldr(args[0], args[1], args[2]),
                "Data.IntMap.mapWithKey" => self.lower_builtin_map_map_with_key(args[0], args[1]),
                "Data.IntMap.foldlWithKey" | "Data.IntMap.foldlWithKey'" => self.lower_builtin_map_foldl_with_key(args[0], args[1], args[2]),
                "Data.IntMap.insertWith" => self.lower_builtin_map_insert_with(args[0], args[1], args[2], args[3]),
                "Data.IntMap.adjust" => self.lower_builtin_map_adjust(args[0], args[1], args[2]),
                "Data.IntMap.unionWith" => self.lower_builtin_map_union_with(args[0], args[1], args[2]),
                "Data.IntMap.keys" => self.lower_builtin_map_keys(args[0]),
                "Data.IntMap.elems" => self.lower_builtin_map_elems(args[0]),
                "Data.IntMap.toList" | "Data.IntMap.toAscList" => {
                    self.lower_builtin_map_to_list(args[0])
                }
                "Data.IntMap.fromList" => self.lower_builtin_map_from_list(args[0]),

                // Data.IntSet operations
                "Data.IntSet.empty" => {
                    let rts_fn = self.functions.get(&VarId::new(1000150)).ok_or_else(|| {
                        CodegenError::Internal("bhc_intset_empty not declared".to_string())
                    })?;
                    let result = self.builder()
                        .build_call(*rts_fn, &[], "intset_empty")
                        .map_err(|e| CodegenError::Internal(format!("intset_empty: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("intset_empty: void".to_string()))?;
                    Ok(Some(result))
                }
                "Data.IntSet.singleton" => self.lower_builtin_set_singleton(args[0]),
                "Data.IntSet.null" => self.lower_builtin_set_null(args[0]),
                "Data.IntSet.size" => self.lower_builtin_set_size(args[0]),
                "Data.IntSet.member" => self.lower_builtin_set_member(args[0], args[1]),
                "Data.IntSet.insert" => self.lower_builtin_set_insert(args[0], args[1]),
                "Data.IntSet.delete" => self.lower_builtin_set_delete(args[0], args[1]),
                "Data.IntSet.union" => self.lower_builtin_set_binary(args[0], args[1], 1155, "intset_union"),
                "Data.IntSet.intersection" => self.lower_builtin_set_binary(args[0], args[1], 1157, "intset_intersection"),
                "Data.IntSet.difference" => self.lower_builtin_set_binary(args[0], args[1], 1158, "intset_difference"),
                "Data.IntSet.isSubsetOf" => self.lower_builtin_set_predicate(args[0], args[1], 1159, "intset_is_subset_of"),
                "Data.IntSet.filter" | "Data.IntSet.foldr" => {
                    let arg_exprs: Vec<&Expr> = args.iter().copied().collect();
                    self.lower_builtin_container_ho_stub(&arg_exprs, name)
                }
                "Data.IntSet.toList" => self.lower_builtin_set_to_list(args[0]),
                "Data.IntSet.fromList" => self.lower_builtin_set_from_list(args[0]),

                // Data.Text operations
                "Data.Text.empty" => self.lower_builtin_text_nullary(1200, "text_empty"),
                "Data.Text.singleton" => self.lower_builtin_text_unary_int_to_ptr(args[0], 1201, "text_singleton"),
                "Data.Text.null" => self.lower_builtin_text_unary_ptr_to_int(args[0], 1202, "text_null"),
                "Data.Text.length" => self.lower_builtin_text_unary_ptr_to_int(args[0], 1203, "text_length"),
                "Data.Text.eq" | "Data.Text.==" => self.lower_builtin_text_binary_ptr_to_int(args[0], args[1], 1204, "text_eq"),
                "Data.Text.compare" => self.lower_builtin_text_binary_ptr_to_int(args[0], args[1], 1205, "text_compare"),
                "Data.Text.head" => self.lower_builtin_text_unary_ptr_to_int(args[0], 1206, "text_head"),
                "Data.Text.last" => self.lower_builtin_text_unary_ptr_to_int(args[0], 1207, "text_last"),
                "Data.Text.tail" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1208, "text_tail"),
                "Data.Text.init" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1209, "text_init"),
                "Data.Text.append" | "Data.Text.<>" => self.lower_builtin_text_binary_ptr_to_ptr(args[0], args[1], 1210, "text_append"),
                "Data.Text.reverse" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1211, "text_reverse"),
                "Data.Text.take" => self.lower_builtin_text_int_ptr_to_ptr(args[0], args[1], 1212, "text_take"),
                "Data.Text.takeEnd" => self.lower_builtin_text_int_ptr_to_ptr(args[0], args[1], 1213, "text_take_end"),
                "Data.Text.drop" => self.lower_builtin_text_int_ptr_to_ptr(args[0], args[1], 1214, "text_drop"),
                "Data.Text.dropEnd" => self.lower_builtin_text_int_ptr_to_ptr(args[0], args[1], 1215, "text_drop_end"),
                "Data.Text.isPrefixOf" => self.lower_builtin_text_binary_ptr_to_int(args[0], args[1], 1216, "text_is_prefix_of"),
                "Data.Text.isSuffixOf" => self.lower_builtin_text_binary_ptr_to_int(args[0], args[1], 1217, "text_is_suffix_of"),
                "Data.Text.isInfixOf" => self.lower_builtin_text_binary_ptr_to_int(args[0], args[1], 1218, "text_is_infix_of"),
                "Data.Text.toLower" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1219, "text_to_lower"),
                "Data.Text.toUpper" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1220, "text_to_upper"),
                "Data.Text.toCaseFold" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1221, "text_to_case_fold"),
                "Data.Text.toTitle" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1222, "text_to_title"),
                "Data.Text.pack" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1223, "text_pack"),
                "Data.Text.unpack" => self.lower_builtin_text_unpack(args[0]),
                "Data.Text.map" => self.lower_builtin_text_map(args[0], args[1]),

                // ByteArray operations (used by Data.ByteString internals)
                "Data.ByteString.bhc_bytearray_malloc" => self.lower_builtin_text_unary_int_to_ptr(args[0], 1250, "ba_malloc"),
                "Data.ByteString.bhc_bytearray_contents" => self.lower_builtin_text_unary_ptr_to_ptr(args[0], 1251, "ba_contents"),
                "Data.ByteString.bhc_bytearray_index" => self.lower_builtin_text_ptr_int_to_int(args[0], args[1], 1252, "ba_index"),
                "Data.ByteString.bhc_bytearray_copy" => self.lower_builtin_ba_copy(args[0], args[1], args[2], args[3]),
                "Data.ByteString.bhc_ptr_plus" => self.lower_builtin_text_ptr_int_to_ptr(args[0], args[1], 1254, "ba_ptr_plus"),
                "Data.ByteString.bhc_poke_byte" => self.lower_builtin_ba_poke(args[0], args[1], args[2]),
                "Data.ByteString.bhc_cstring_length" => self.lower_builtin_text_unary_ptr_to_int(args[0], 1256, "ba_strlen"),
                "Data.ByteString.bhc_peek_array" => self.lower_builtin_text_int_ptr_to_ptr(args[0], args[1], 1257, "ba_peek_array"),

            // Identity operations (newtype = pass through)
            "Identity" | "runIdentity" => self.lower_expr(args[0]),
            "Identity.fmap" => {
                // fmap f (Identity x) = Identity (f x) => just apply f to x
                self.lower_builtin_fmap(args[0], args[1])
            }
            "Identity.pure" => self.lower_expr(args[0]),
            "Identity.<*>" => self.lower_builtin_ap(args[0], args[1]),
            "Identity.>>=" => self.lower_builtin_bind(args[0], args[1]),
            "Identity.>>" => self.lower_builtin_then(args[0], args[1]),

            // ReaderT operations
            "ReaderT" => self.lower_expr(args[0]), // newtype wrap = identity
            "runReaderT" => self.lower_builtin_run_reader_t(args[0], args[1]),
            "ReaderT.pure" => self.lower_builtin_reader_t_pure(args[0]),
            "ReaderT.>>=" => self.lower_builtin_reader_t_bind(args[0], args[1]),
            "ReaderT.>>" => self.lower_builtin_reader_t_then(args[0], args[1]),
            "ReaderT.fmap" => self.lower_builtin_reader_t_fmap(args[0], args[1]),
            "ReaderT.<*>" => self.lower_builtin_reader_t_ap(args[0], args[1]),
            "ReaderT.lift" | "ReaderT.liftIO" => self.lower_builtin_reader_t_lift(args[0]),
            "ask" => self.lower_builtin_ask(),
            "asks" => self.lower_builtin_asks(args[0]),
            "local" => self.lower_builtin_local(args[0], args[1]),

            // StateT operations
            "StateT" => self.lower_expr(args[0]), // newtype wrap = identity
            "runStateT" => self.lower_builtin_run_state_t(args[0], args[1]),
            "StateT.pure" => self.lower_builtin_state_t_pure(args[0]),
            "StateT.>>=" => self.lower_builtin_state_t_bind(args[0], args[1]),
            "StateT.>>" => self.lower_builtin_state_t_then(args[0], args[1]),
            "StateT.fmap" => self.lower_builtin_state_t_fmap(args[0], args[1]),
            "StateT.<*>" => self.lower_builtin_state_t_ap(args[0], args[1]),
            "StateT.lift" | "StateT.liftIO" => self.lower_builtin_state_t_lift(args[0]),
            "get" => self.lower_builtin_get(),
            "put" => self.lower_builtin_put(args[0]),
            "modify" => self.lower_builtin_modify(args[0]),
            "gets" => self.lower_builtin_gets(args[0]),
            "evalStateT" => self.lower_builtin_eval_state_t(args[0], args[1]),
            "execStateT" => self.lower_builtin_exec_state_t(args[0], args[1]),

            // ExceptT operations
            "ExceptT" => self.lower_expr(args[0]), // newtype wrap = identity
            "runExceptT" => self.lower_builtin_run_except_t(args[0]),
            "ExceptT.pure" => self.lower_builtin_except_t_pure(args[0]),
            "ExceptT.>>=" => self.lower_builtin_except_t_bind(args[0], args[1]),
            "ExceptT.>>" => self.lower_builtin_except_t_then(args[0], args[1]),
            "ExceptT.fmap" => self.lower_builtin_except_t_fmap(args[0], args[1]),
            "ExceptT.<*>" => self.lower_builtin_except_t_ap(args[0], args[1]),
            "ExceptT.lift" | "ExceptT.liftIO" => self.lower_builtin_except_t_lift(args[0]),
            "throwE" => self.lower_builtin_throw_e(args[0]),
            "catchE" => self.lower_builtin_catch_e(args[0], args[1]),

            // WriterT operations
            "WriterT" => self.lower_expr(args[0]), // newtype wrap = identity
            "runWriterT" => self.lower_builtin_run_writer_t(args[0]),
            "WriterT.pure" => self.lower_builtin_writer_t_pure(args[0]),
            "WriterT.>>=" => self.lower_builtin_writer_t_bind(args[0], args[1]),
            "WriterT.>>" => self.lower_builtin_writer_t_then(args[0], args[1]),
            "WriterT.fmap" => self.lower_builtin_writer_t_fmap(args[0], args[1]),
            "WriterT.<*>" => self.lower_builtin_writer_t_ap(args[0], args[1]),
            "WriterT.lift" | "WriterT.liftIO" => self.lower_builtin_writer_t_lift(args[0]),
            "tell" => self.lower_builtin_tell(args[0]),
            "execWriterT" => self.lower_builtin_exec_writer_t(args[0]),

            _ => {
                // Check for field selector pattern: $sel_N
                if name.starts_with("$sel_") {
                    if let Ok(field_index) = name[5..].parse::<u32>() {
                        return self.lower_builtin_field_selector(args[0], field_index);
                    }
                }
                Err(CodegenError::Internal(format!("unknown builtin: {}", name)))
            }
        }
    }

    /// Lower `head` - extract first element of a list.
    /// head [] = error "empty list"
    /// head (x:_) = x
    fn lower_builtin_head(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("head: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("head expects a list".to_string())),
        };

        // Extract tag to check if empty
        let tag = self.extract_adt_tag(list_ptr)?;
        let tm = self.type_mapper();

        // Create blocks for empty check
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let empty_block = self
            .llvm_context()
            .append_basic_block(current_fn, "head_empty");
        let cons_block = self
            .llvm_context()
            .append_basic_block(current_fn, "head_cons");

        // Branch on tag (0 = [], 1 = :)
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, empty_block, cons_block)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Empty case: call error
        self.builder().position_at_end(empty_block);
        let error_msg = self
            .module
            .add_global_string("head_empty_error", "head: empty list");
        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;
        self.builder()
            .build_call(*error_fn, &[error_msg.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;
        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        // Cons case: extract head (field 0)
        self.builder().position_at_end(cons_block);
        let head_ptr = self.extract_adt_field(list_ptr, 2, 0)?; // arity=2 for (:)
        Ok(Some(head_ptr.into()))
    }

    /// Lower `tail` - extract rest of a list.
    /// tail [] = error "empty list"
    /// tail (_:xs) = xs
    fn lower_builtin_tail(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("tail: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("tail expects a list".to_string())),
        };

        // Extract tag to check if empty
        let tag = self.extract_adt_tag(list_ptr)?;
        let tm = self.type_mapper();

        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let empty_block = self
            .llvm_context()
            .append_basic_block(current_fn, "tail_empty");
        let cons_block = self
            .llvm_context()
            .append_basic_block(current_fn, "tail_cons");

        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, empty_block, cons_block)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Empty case: call error
        self.builder().position_at_end(empty_block);
        let error_msg = self
            .module
            .add_global_string("tail_empty_error", "tail: empty list");
        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;
        self.builder()
            .build_call(*error_fn, &[error_msg.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;
        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        // Cons case: extract tail (field 1)
        self.builder().position_at_end(cons_block);
        let tail_ptr = self.extract_adt_field(list_ptr, 2, 1)?;
        Ok(Some(tail_ptr.into()))
    }

    /// Lower `null` - check if list is empty.
    /// null [] = True
    /// null (_:_) = False
    fn lower_builtin_null(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("null: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("null expects a list".to_string())),
        };

        // Extract tag: 0 = [], 1 = (:)
        let tag = self.extract_adt_tag(list_ptr)?;
        let tm = self.type_mapper();

        // null = (tag == 0)
        let is_null = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_null",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        // Extend i1 to i64 for Bool representation
        let result = self
            .builder()
            .build_int_z_extend(is_null, tm.i64_type(), "null_result")
            .map_err(|e| CodegenError::Internal(format!("failed to extend: {:?}", e)))?;

        Ok(Some(result.into()))
    }

    /// Lower `length` - compute list length.
    /// Handles both cons-cell lists (tag 0=nil, 1=cons) and raw C strings
    /// (from readFile etc.) by checking the tag value at runtime.
    fn lower_builtin_length(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("length: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("length expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Read the first i64 from the pointer to determine representation.
        // Cons-cell lists have tag 0 (nil) or 1 (cons).
        // C strings have arbitrary byte content (interpreted as i64, usually > 1).
        let tag = self.extract_adt_tag(list_ptr)?;

        // Create blocks for dispatch
        let is_cons_block = self
            .llvm_context()
            .append_basic_block(current_fn, "length_cons");
        let is_cstring_block = self
            .llvm_context()
            .append_basic_block(current_fn, "length_cstring");
        let loop_header = self
            .llvm_context()
            .append_basic_block(current_fn, "length_header");
        let loop_body = self
            .llvm_context()
            .append_basic_block(current_fn, "length_body");
        let merge_block = self
            .llvm_context()
            .append_basic_block(current_fn, "length_merge");

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        // Check if tag == 0 (nil list  length 0)
        let is_nil = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_nil",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        // For tag==0, jump directly to merge with result 0.
        // For tag!=0, check if tag==1 (cons) or >1 (C string).
        let not_nil_block = self
            .llvm_context()
            .append_basic_block(current_fn, "length_not_nil");
        self.builder()
            .build_conditional_branch(is_nil, merge_block, not_nil_block)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // not_nil: check tag == 1 (cons) vs > 1 (C string)
        self.builder().position_at_end(not_nil_block);
        let is_cons = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_int(1, false),
                "is_cons",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(is_cons, is_cons_block, is_cstring_block)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // ---- C string path: call bhc_string_length ----
        self.builder().position_at_end(is_cstring_block);
        let strlen_fn = self.functions.get(&VarId::new(1000180)).ok_or_else(|| {
            CodegenError::Internal("bhc_string_length not declared".to_string())
        })?;
        let strlen_result = self
            .builder()
            .build_call(*strlen_fn, &[list_ptr.into()], "strlen_result")
            .map_err(|e| CodegenError::Internal(format!("strlen call failed: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("strlen returned void".to_string()))?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        let cstring_exit_block = self.builder().get_insert_block().unwrap();

        // ---- Cons-cell path: iterative loop ----
        self.builder().position_at_end(is_cons_block);
        let init_count = tm.i64_type().const_int(1, false); // already know first cell is cons
        let first_tail = self.extract_adt_field(list_ptr, 2, 1)?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let count_phi = self
            .builder()
            .build_phi(tm.i64_type(), "count")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let current_list = list_phi.as_basic_value().into_pointer_value();
        let cur_tag = self.extract_adt_tag(current_list)?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                cur_tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(is_empty, merge_block, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        let loop_header_exit = self.builder().get_insert_block().unwrap();

        // Loop body
        self.builder().position_at_end(loop_body);
        let new_count = self
            .builder()
            .build_int_add(
                count_phi.as_basic_value().into_int_value(),
                tm.i64_type().const_int(1, false),
                "new_count",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to add: {:?}", e)))?;
        let tail_ptr = self.extract_adt_field(current_list, 2, 1)?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Wire up phi nodes
        count_phi.add_incoming(&[(&init_count, is_cons_block), (&new_count, loop_body)]);
        list_phi.add_incoming(&[(&first_tail, is_cons_block), (&tail_ptr, loop_body)]);

        // ---- Merge block: phi to combine all paths ----
        self.builder().position_at_end(merge_block);
        let result_phi = self
            .builder()
            .build_phi(tm.i64_type(), "length_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let zero = tm.i64_type().const_zero();
        result_phi.add_incoming(&[
            (&zero, entry_block),                                     // nil path
            (&strlen_result.into_int_value(), cstring_exit_block),    // C string path
            (&count_phi.as_basic_value().into_int_value(), loop_header_exit), // cons loop done
        ]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `take` - take first n elements of a list.
    /// Implemented iteratively: collect n elements in reverse, then reverse the result.
    fn lower_builtin_take(
        &mut self,
        n_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let n_val = self
            .lower_expr(n_expr)?
            .ok_or_else(|| CodegenError::Internal("take: n has no value".to_string()))?;
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("take: list has no value".to_string()))?;

        let n = self.to_int_value(n_val)?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("take expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Phase 1: Collect n elements into a reversed accumulator
        let collect_header = self
            .llvm_context()
            .append_basic_block(current_fn, "take_collect_header");
        let collect_body = self
            .llvm_context()
            .append_basic_block(current_fn, "take_collect_body");
        let collect_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "take_collect_exit");
        // Phase 2: Reverse the accumulator
        let rev_header = self
            .llvm_context()
            .append_basic_block(current_fn, "take_rev_header");
        let rev_body = self
            .llvm_context()
            .append_basic_block(current_fn, "take_rev_body");
        let rev_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "take_rev_exit");

        // Build nil in entry block before branching
        let nil = self.build_nil()?;
        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder()
            .build_unconditional_branch(collect_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Collect loop header
        self.builder().position_at_end(collect_header);
        let acc_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let count_phi = self
            .builder()
            .build_phi(tm.i64_type(), "count")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if count <= 0 (taken enough)
        let count = count_phi.as_basic_value().into_int_value();
        let count_le_0 = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::SLE,
                count,
                tm.i64_type().const_zero(),
                "count_le_0",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        // Check if list is empty
        let current_list = list_phi.as_basic_value().into_pointer_value();
        let tag = self.extract_adt_tag(current_list)?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        // Exit if count <= 0 OR list is empty
        let should_exit = self
            .builder()
            .build_or(count_le_0, is_empty, "should_exit")
            .map_err(|e| CodegenError::Internal(format!("failed to build or: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(should_exit, collect_exit, collect_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Collect loop body: cons head onto accumulator (in reverse), advance
        self.builder().position_at_end(collect_body);
        let head_ptr = self.extract_adt_field(current_list, 2, 0)?;
        let tail_ptr = self.extract_adt_field(current_list, 2, 1)?;
        let new_acc = self.build_cons(head_ptr.into(), acc_phi.as_basic_value())?;
        let new_count = self
            .builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "new_count")
            .map_err(|e| CodegenError::Internal(format!("failed to sub: {:?}", e)))?;
        self.builder()
            .build_unconditional_branch(collect_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, collect_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, collect_body)]);
        count_phi.add_incoming(&[(&n, entry_block), (&new_count, collect_body)]);

        // collect_exit: build nil for reverse phase and branch to rev_header
        self.builder().position_at_end(collect_exit);
        let nil2 = self.build_nil()?;
        // Save the collected accumulator (will be used as rev_list input)
        let collected_acc = acc_phi.as_basic_value().into_pointer_value();
        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Reverse loop header
        self.builder().position_at_end(rev_header);
        let rev_acc_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_current = rev_list_phi.as_basic_value().into_pointer_value();
        let rev_tag = self.extract_adt_tag(rev_current)?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Reverse loop body
        self.builder().position_at_end(rev_body);
        let rev_head = self.extract_adt_field(rev_current, 2, 0)?;
        let rev_tail = self.extract_adt_field(rev_current, 2, 1)?;
        let new_rev_acc = self.build_cons(rev_head.into(), rev_acc_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming edges
        rev_acc_phi.add_incoming(&[(&nil2, collect_exit), (&new_rev_acc, rev_body)]);
        rev_list_phi.add_incoming(&[(&collected_acc, collect_exit), (&rev_tail, rev_body)]);

        // Return result
        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc_phi.as_basic_value()))
    }

    /// Lower `drop` - drop first n elements of a list.
    /// drop n xs | n <= 0 = xs
    /// drop _ [] = []
    /// drop n (_:xs) = drop (n-1) xs
    fn lower_builtin_drop(
        &mut self,
        n_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let n_val = self
            .lower_expr(n_expr)?
            .ok_or_else(|| CodegenError::Internal("drop: n has no value".to_string()))?;
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("drop: list has no value".to_string()))?;

        let n = self.to_int_value(n_val)?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("drop expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Create loop blocks for iterative drop
        let loop_header = self
            .llvm_context()
            .append_basic_block(current_fn, "drop_header");
        let loop_body = self
            .llvm_context()
            .append_basic_block(current_fn, "drop_body");
        let loop_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "drop_exit");

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();

        // Loop header: phi for remaining count and current list
        self.builder().position_at_end(loop_header);
        let count_phi = self
            .builder()
            .build_phi(tm.i64_type(), "count")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if count <= 0 (done dropping)
        let count_le_0 = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::SLE,
                count_phi.as_basic_value().into_int_value(),
                tm.i64_type().const_zero(),
                "count_le_0",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        // Check if list is empty
        let current_list = list_phi.as_basic_value().into_pointer_value();
        let tag = self.extract_adt_tag(current_list)?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        // Exit if count <= 0 OR list is empty
        let should_exit = self
            .builder()
            .build_or(count_le_0, is_empty, "should_exit")
            .map_err(|e| CodegenError::Internal(format!("failed to build or: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(should_exit, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: decrement count, advance to tail
        self.builder().position_at_end(loop_body);
        let new_count = self
            .builder()
            .build_int_sub(
                count_phi.as_basic_value().into_int_value(),
                tm.i64_type().const_int(1, false),
                "new_count",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to sub: {:?}", e)))?;
        let tail_ptr = self.extract_adt_field(current_list, 2, 1)?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming edges
        count_phi.add_incoming(&[(&n, entry_block), (&new_count, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Loop exit: return current list
        self.builder().position_at_end(loop_exit);
        Ok(Some(list_phi.as_basic_value()))
    }

    /// Lower `reverse` - reverse a list.
    fn lower_builtin_reverse(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("reverse: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "reverse expects a list".to_string(),
                ))
            }
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Create loop blocks for iterative reverse
        let loop_header = self
            .llvm_context()
            .append_basic_block(current_fn, "rev_header");
        let loop_body = self
            .llvm_context()
            .append_basic_block(current_fn, "rev_body");
        let loop_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "rev_exit");

        // Start with empty accumulator
        let nil = self.build_nil()?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();

        // Loop header
        self.builder().position_at_end(loop_header);
        let acc_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if list is empty
        let current_list = list_phi.as_basic_value().into_pointer_value();
        let tag = self.extract_adt_tag(current_list)?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: cons head onto accumulator, advance to tail
        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(current_list, 2, 0)?;
        let tail_ptr = self.extract_adt_field(current_list, 2, 1)?;
        let new_acc = self.build_cons(head_ptr.into(), acc_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming edges
        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Loop exit: return accumulator
        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `append` / `++` - concatenate two lists.
    fn lower_builtin_append(
        &mut self,
        list1_expr: &Expr,
        list2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list1_val = self
            .lower_expr(list1_expr)?
            .ok_or_else(|| CodegenError::Internal("append: list1 has no value".to_string()))?;
        let list2_val = self
            .lower_expr(list2_expr)?
            .ok_or_else(|| CodegenError::Internal("append: list2 has no value".to_string()))?;

        let list1_ptr = match list1_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("append expects a list".to_string())),
        };
        let list2_ptr = match list2_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("append expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // First reverse list1, then fold onto list2
        // This is: append xs ys = foldl (flip (:)) ys (reverse xs)
        // Or equivalently: go [] xs where go acc [] = acc ++ ys; go acc (x:xs) = go (x:acc) xs

        // Step 1: Reverse list1
        let rev_header = self
            .llvm_context()
            .append_basic_block(current_fn, "app_rev_header");
        let rev_body = self
            .llvm_context()
            .append_basic_block(current_fn, "app_rev_body");
        let rev_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "app_rev_exit");
        let fold_header = self
            .llvm_context()
            .append_basic_block(current_fn, "app_fold_header");
        let fold_body = self
            .llvm_context()
            .append_basic_block(current_fn, "app_fold_body");
        let fold_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "app_fold_exit");

        // Start with empty accumulator for reverse
        let nil = self.build_nil()?;
        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();

        // Reverse loop header
        self.builder().position_at_end(rev_header);
        let rev_acc_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_current = rev_list_phi.as_basic_value().into_pointer_value();
        let rev_tag = self.extract_adt_tag(rev_current)?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Reverse loop body
        self.builder().position_at_end(rev_body);
        let rev_head = self.extract_adt_field(rev_current, 2, 0)?;
        let rev_tail = self.extract_adt_field(rev_current, 2, 1)?;
        let rev_new_acc = self.build_cons(rev_head.into(), rev_acc_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        rev_acc_phi.add_incoming(&[(&nil, entry_block), (&rev_new_acc, rev_body)]);
        rev_list_phi.add_incoming(&[(&list1_ptr, entry_block), (&rev_tail, rev_body)]);

        // After reversing, fold reversed list onto list2
        self.builder().position_at_end(rev_exit);
        self.builder()
            .build_unconditional_branch(fold_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Fold loop header
        self.builder().position_at_end(fold_header);
        let fold_acc_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "fold_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let fold_list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "fold_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let fold_current = fold_list_phi.as_basic_value().into_pointer_value();
        let fold_tag = self.extract_adt_tag(fold_current)?;
        let fold_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                fold_tag,
                tm.i64_type().const_zero(),
                "fold_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(fold_is_empty, fold_exit, fold_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Fold loop body: cons head of reversed list onto accumulator
        self.builder().position_at_end(fold_body);
        let fold_head = self.extract_adt_field(fold_current, 2, 0)?;
        let fold_tail = self.extract_adt_field(fold_current, 2, 1)?;
        let fold_new_acc = self.build_cons(fold_head.into(), fold_acc_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(fold_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        fold_acc_phi.add_incoming(&[(&list2_ptr, rev_exit), (&fold_new_acc, fold_body)]);
        fold_list_phi.add_incoming(&[
            (&rev_acc_phi.as_basic_value().into_pointer_value(), rev_exit),
            (&fold_tail, fold_body),
        ]);

        // Return result
        self.builder().position_at_end(fold_exit);
        Ok(Some(fold_acc_phi.as_basic_value()))
    }

    /// Lower `enumFromTo` - generate a list [from..to].
    fn lower_builtin_enum_from_to(
        &mut self,
        from_expr: &Expr,
        to_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let from_val = self
            .lower_expr(from_expr)?
            .ok_or_else(|| CodegenError::Internal("enumFromTo: from has no value".to_string()))?;
        let to_val = self
            .lower_expr(to_expr)?
            .ok_or_else(|| CodegenError::Internal("enumFromTo: to has no value".to_string()))?;

        let from = self.to_int_value(from_val)?;
        let to = self.to_int_value(to_val)?;

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Build list backwards from to down to from, then we have [from..to]
        let loop_header = self
            .llvm_context()
            .append_basic_block(current_fn, "enum_header");
        let loop_body = self
            .llvm_context()
            .append_basic_block(current_fn, "enum_body");
        let loop_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "enum_exit");

        // Start with empty list, current = to
        let nil = self.build_nil()?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();

        // Loop header
        self.builder().position_at_end(loop_header);
        let acc_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let current_phi = self
            .builder()
            .build_phi(tm.i64_type(), "current")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if current < from (done)
        let current = current_phi.as_basic_value().into_int_value();
        let done = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::SLT, current, from, "done")
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: cons current onto accumulator, decrement current
        self.builder().position_at_end(loop_body);
        let boxed_current = self.box_int(current)?;
        let new_acc = self.build_cons(boxed_current.into(), acc_phi.as_basic_value())?;
        let prev_current = self
            .builder()
            .build_int_sub(current, tm.i64_type().const_int(1, false), "prev")
            .map_err(|e| CodegenError::Internal(format!("failed to sub: {:?}", e)))?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, loop_body)]);
        current_phi.add_incoming(&[(&to, entry_block), (&prev_current, loop_body)]);

        // Return result
        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `replicate` - create a list with n copies of an element.
    fn lower_builtin_replicate(
        &mut self,
        n_expr: &Expr,
        elem_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let n_val = self
            .lower_expr(n_expr)?
            .ok_or_else(|| CodegenError::Internal("replicate: n has no value".to_string()))?;
        let elem_val = self
            .lower_expr(elem_expr)?
            .ok_or_else(|| CodegenError::Internal("replicate: elem has no value".to_string()))?;

        let n = self.to_int_value(n_val)?;
        let elem_ptr = self.value_to_ptr(elem_val)?;

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Build list by consing n times
        let loop_header = self
            .llvm_context()
            .append_basic_block(current_fn, "rep_header");
        let loop_body = self
            .llvm_context()
            .append_basic_block(current_fn, "rep_body");
        let loop_exit = self
            .llvm_context()
            .append_basic_block(current_fn, "rep_exit");

        // Start with empty list
        let nil = self.build_nil()?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();

        // Loop header
        self.builder().position_at_end(loop_header);
        let acc_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let count_phi = self
            .builder()
            .build_phi(tm.i64_type(), "count")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if count <= 0
        let count = count_phi.as_basic_value().into_int_value();
        let done = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::SLE,
                count,
                tm.i64_type().const_zero(),
                "done",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: cons elem onto accumulator, decrement count
        self.builder().position_at_end(loop_body);
        let new_acc = self.build_cons(elem_ptr.into(), acc_phi.as_basic_value())?;
        let new_count = self
            .builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "new_count")
            .map_err(|e| CodegenError::Internal(format!("failed to sub: {:?}", e)))?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, loop_body)]);
        count_phi.add_incoming(&[(&n, entry_block), (&new_count, loop_body)]);

        // Return result
        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Build an empty list (Nil / []).
    fn build_nil(&self) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        // Nil is represented as ADT with tag 0 and no fields
        // Allocate space: tag (i64) only
        let size = tm.i64_type().const_int(8, false);
        let alloc_fn = self
            .functions
            .get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;
        let alloc_call = self
            .builder()
            .build_call(*alloc_fn, &[size.into()], "nil_alloc")
            .map_err(|e| CodegenError::Internal(format!("failed to call alloc: {:?}", e)))?;
        let nil_ptr = alloc_call
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("alloc returned void".to_string()))?
            .into_pointer_value();

        // Store tag = 0
        self.builder()
            .build_store(nil_ptr, tm.i64_type().const_zero())
            .map_err(|e| CodegenError::Internal(format!("failed to store tag: {:?}", e)))?;

        Ok(nil_ptr)
    }

    /// Build a cons cell (x : xs).
    fn build_cons(
        &self,
        head: BasicValueEnum<'ctx>,
        tail: BasicValueEnum<'ctx>,
    ) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        // Cons is represented as ADT with tag 1 and 2 fields (head, tail)
        // Allocate space: tag (i64) + head (ptr) + tail (ptr) = 24 bytes
        let size = tm.i64_type().const_int(24, false);
        let alloc_fn = self
            .functions
            .get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;
        let alloc_call = self
            .builder()
            .build_call(*alloc_fn, &[size.into()], "cons_alloc")
            .map_err(|e| CodegenError::Internal(format!("failed to call alloc: {:?}", e)))?;
        let cons_ptr = alloc_call
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("alloc returned void".to_string()))?
            .into_pointer_value();

        // Store tag = 1
        self.builder()
            .build_store(cons_ptr, tm.i64_type().const_int(1, false))
            .map_err(|e| CodegenError::Internal(format!("failed to store tag: {:?}", e)))?;

        // Store head at offset 8
        let head_ptr = unsafe {
            self.builder()
                .build_gep(
                    tm.i64_type(),
                    cons_ptr,
                    &[tm.i64_type().const_int(1, false)],
                    "head_ptr",
                )
                .map_err(|e| CodegenError::Internal(format!("failed to build gep: {:?}", e)))?
        };
        let head_as_ptr = self.value_to_ptr(head)?;
        self.builder()
            .build_store(head_ptr, head_as_ptr)
            .map_err(|e| CodegenError::Internal(format!("failed to store head: {:?}", e)))?;

        // Store tail at offset 16
        let tail_slot = unsafe {
            self.builder()
                .build_gep(
                    tm.i64_type(),
                    cons_ptr,
                    &[tm.i64_type().const_int(2, false)],
                    "tail_ptr",
                )
                .map_err(|e| CodegenError::Internal(format!("failed to build gep: {:?}", e)))?
        };
        let tail_as_ptr = self.value_to_ptr(tail)?;
        self.builder()
            .build_store(tail_slot, tail_as_ptr)
            .map_err(|e| CodegenError::Internal(format!("failed to store tail: {:?}", e)))?;

        Ok(cons_ptr)
    }

    /// Convert a C-string (null-terminated i8 pointer) into a [Char] linked list.
    /// Emits LLVM IR that loops over the C-string bytes and builds cons cells.
    fn cstring_to_char_list(&self, cstr_ptr: inkwell::values::PointerValue<'ctx>) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function for cstring_to_char_list".to_string()))?;

        // Guard: if the C-string pointer is null (e.g. exception sentinel from bhc_throw),
        // return nil (empty list) so execution can continue back to bhc_catch.
        let null_path_block = self.llvm_context().append_basic_block(current_fn, "c2l_null_path");
        let convert_block = self.llvm_context().append_basic_block(current_fn, "c2l_convert");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "c2l_merge");

        let is_null_ptr = self.builder().build_is_null(cstr_ptr, "c2l_ptr_null")
            .map_err(|e| CodegenError::Internal(format!("c2l is_null: {:?}", e)))?;
        self.builder().build_conditional_branch(is_null_ptr, null_path_block, convert_block)
            .map_err(|e| CodegenError::Internal(format!("c2l null branch: {:?}", e)))?;

        // Null path: build nil and jump to merge
        self.builder().position_at_end(null_path_block);
        let null_nil = self.build_nil()?;
        let null_nil_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("c2l null nil branch: {:?}", e)))?;

        // Non-null path: do the conversion
        self.builder().position_at_end(convert_block);

        // Strategy: compute strlen, then iterate backwards building the list.

        // --- Compute strlen ---
        let strlen_header = self.llvm_context().append_basic_block(current_fn, "c2l_strlen_hdr");
        let strlen_body = self.llvm_context().append_basic_block(current_fn, "c2l_strlen_body");
        let strlen_done = self.llvm_context().append_basic_block(current_fn, "c2l_strlen_done");

        // Capture the block we're in BEFORE branching
        let pre_strlen_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(strlen_header)
            .map_err(|e| CodegenError::Internal(format!("c2l branch: {:?}", e)))?;

        self.builder().position_at_end(strlen_header);
        let idx_phi = self.builder().build_phi(tm.i64_type(), "c2l_idx")
            .map_err(|e| CodegenError::Internal(format!("c2l phi: {:?}", e)))?;
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), pre_strlen_block)]);

        let byte_ptr = unsafe {
            self.builder().build_gep(tm.i8_type(), cstr_ptr, &[idx_phi.as_basic_value().into_int_value()], "c2l_byte_ptr")
                .map_err(|e| CodegenError::Internal(format!("c2l gep: {:?}", e)))?
        };
        let byte_val = self.builder().build_load(tm.i8_type(), byte_ptr, "c2l_byte")
            .map_err(|e| CodegenError::Internal(format!("c2l load: {:?}", e)))?
            .into_int_value();
        let is_null = self.builder().build_int_compare(inkwell::IntPredicate::EQ, byte_val, tm.i8_type().const_zero(), "c2l_is_null")
            .map_err(|e| CodegenError::Internal(format!("c2l cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_null, strlen_done, strlen_body)
            .map_err(|e| CodegenError::Internal(format!("c2l branch: {:?}", e)))?;

        self.builder().position_at_end(strlen_body);
        let next_idx = self.builder().build_int_add(idx_phi.as_basic_value().into_int_value(), tm.i64_type().const_int(1, false), "c2l_next")
            .map_err(|e| CodegenError::Internal(format!("c2l add: {:?}", e)))?;
        idx_phi.add_incoming(&[(&next_idx, strlen_body)]);
        self.builder().build_unconditional_branch(strlen_header)
            .map_err(|e| CodegenError::Internal(format!("c2l branch: {:?}", e)))?;

        // strlen_done: idx_phi contains the length
        self.builder().position_at_end(strlen_done);
        let len = idx_phi.as_basic_value().into_int_value();

        // --- Build list backwards from len-1 to 0 ---
        let build_header = self.llvm_context().append_basic_block(current_fn, "c2l_build_hdr");
        let build_body = self.llvm_context().append_basic_block(current_fn, "c2l_build_body");
        let build_done = self.llvm_context().append_basic_block(current_fn, "c2l_build_done");

        let nil = self.build_nil()?;

        // Capture block before branching (may differ from strlen_done due to build_nil alloc)
        let pre_build_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(build_header)
            .map_err(|e| CodegenError::Internal(format!("c2l branch: {:?}", e)))?;

        self.builder().position_at_end(build_header);
        let build_idx = self.builder().build_phi(tm.i64_type(), "c2l_bidx")
            .map_err(|e| CodegenError::Internal(format!("c2l phi: {:?}", e)))?;
        let build_list = self.builder().build_phi(tm.ptr_type(), "c2l_list")
            .map_err(|e| CodegenError::Internal(format!("c2l phi: {:?}", e)))?;

        build_idx.add_incoming(&[(&len, pre_build_block)]);
        build_list.add_incoming(&[(&nil, pre_build_block)]);

        let is_done = self.builder().build_int_compare(inkwell::IntPredicate::EQ, build_idx.as_basic_value().into_int_value(), tm.i64_type().const_zero(), "c2l_done")
            .map_err(|e| CodegenError::Internal(format!("c2l cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_done, build_done, build_body)
            .map_err(|e| CodegenError::Internal(format!("c2l branch: {:?}", e)))?;

        self.builder().position_at_end(build_body);
        let prev_idx = self.builder().build_int_sub(build_idx.as_basic_value().into_int_value(), tm.i64_type().const_int(1, false), "c2l_prev")
            .map_err(|e| CodegenError::Internal(format!("c2l sub: {:?}", e)))?;
        let char_ptr = unsafe {
            self.builder().build_gep(tm.i8_type(), cstr_ptr, &[prev_idx], "c2l_char_ptr")
                .map_err(|e| CodegenError::Internal(format!("c2l gep: {:?}", e)))?
        };
        let char_byte = self.builder().build_load(tm.i8_type(), char_ptr, "c2l_char")
            .map_err(|e| CodegenError::Internal(format!("c2l load: {:?}", e)))?
            .into_int_value();
        let char_i64 = self.builder().build_int_z_extend(char_byte, tm.i64_type(), "c2l_char_ext")
            .map_err(|e| CodegenError::Internal(format!("c2l ext: {:?}", e)))?;
        let char_as_ptr = self.int_to_ptr(char_i64)?;

        let new_cons = self.build_cons(char_as_ptr.into(), build_list.as_basic_value())?;
        // Capture the current block AFTER build_cons (which creates new blocks)
        let build_body_end = self.builder().get_insert_block().unwrap();
        build_idx.add_incoming(&[(&prev_idx, build_body_end)]);
        build_list.add_incoming(&[(&new_cons, build_body_end)]);

        self.builder().build_unconditional_branch(build_header)
            .map_err(|e| CodegenError::Internal(format!("c2l branch: {:?}", e)))?;

        self.builder().position_at_end(build_done);
        let converted_list = build_list.as_basic_value().into_pointer_value();
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("c2l done branch: {:?}", e)))?;

        // Merge: PHI between null path (nil) and convert path (converted list)
        self.builder().position_at_end(merge_block);
        let result_phi = self.builder().build_phi(tm.ptr_type(), "c2l_result")
            .map_err(|e| CodegenError::Internal(format!("c2l merge phi: {:?}", e)))?;
        result_phi.add_incoming(&[(&null_nil, null_nil_block), (&converted_list, build_done)]);

        Ok(result_phi.as_basic_value().into_pointer_value())
    }

    /// Convert a [Char] linked list into a C-string (null-terminated i8 pointer).
    /// Emits LLVM IR that first counts the list length, allocates a buffer, then fills it.
    fn char_list_to_cstring(&self, list_ptr: inkwell::values::PointerValue<'ctx>) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function for char_list_to_cstring".to_string()))?;

        // --- Count list length ---
        let len_header = self.llvm_context().append_basic_block(current_fn, "l2c_len_hdr");
        let len_body = self.llvm_context().append_basic_block(current_fn, "l2c_len_body");
        let len_done = self.llvm_context().append_basic_block(current_fn, "l2c_len_done");

        let pre_len_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(len_header)
            .map_err(|e| CodegenError::Internal(format!("l2c branch: {:?}", e)))?;

        self.builder().position_at_end(len_header);
        let len_node = self.builder().build_phi(tm.ptr_type(), "l2c_node")
            .map_err(|e| CodegenError::Internal(format!("l2c phi: {:?}", e)))?;
        let len_count = self.builder().build_phi(tm.i64_type(), "l2c_count")
            .map_err(|e| CodegenError::Internal(format!("l2c phi: {:?}", e)))?;
        len_node.add_incoming(&[(&list_ptr, pre_len_block)]);
        len_count.add_incoming(&[(&tm.i64_type().const_zero(), pre_len_block)]);

        let tag = self.extract_adt_tag(len_node.as_basic_value().into_pointer_value())?;
        let is_nil = self.builder().build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "l2c_nil")
            .map_err(|e| CodegenError::Internal(format!("l2c cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_nil, len_done, len_body)
            .map_err(|e| CodegenError::Internal(format!("l2c branch: {:?}", e)))?;

        self.builder().position_at_end(len_body);
        let next_count = self.builder().build_int_add(len_count.as_basic_value().into_int_value(), tm.i64_type().const_int(1, false), "l2c_inc")
            .map_err(|e| CodegenError::Internal(format!("l2c add: {:?}", e)))?;
        let tail = self.extract_adt_field(len_node.as_basic_value().into_pointer_value(), 2, 1)?;
        len_node.add_incoming(&[(&tail, len_body)]);
        len_count.add_incoming(&[(&next_count, len_body)]);
        self.builder().build_unconditional_branch(len_header)
            .map_err(|e| CodegenError::Internal(format!("l2c branch: {:?}", e)))?;

        // --- Allocate buffer (len + 1 for null terminator) ---
        self.builder().position_at_end(len_done);
        let total_len = len_count.as_basic_value().into_int_value();
        let buf_size = self.builder().build_int_add(total_len, tm.i64_type().const_int(1, false), "l2c_bufsize")
            .map_err(|e| CodegenError::Internal(format!("l2c add: {:?}", e)))?;
        let alloc_fn = self.functions.get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;
        let buf = self.builder().build_call(*alloc_fn, &[buf_size.into()], "l2c_buf")
            .map_err(|e| CodegenError::Internal(format!("l2c alloc: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("l2c alloc void".to_string()))?
            .into_pointer_value();

        // --- Fill buffer ---
        let fill_header = self.llvm_context().append_basic_block(current_fn, "l2c_fill_hdr");
        let fill_body = self.llvm_context().append_basic_block(current_fn, "l2c_fill_body");
        let fill_done = self.llvm_context().append_basic_block(current_fn, "l2c_fill_done");

        let pre_fill_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(fill_header)
            .map_err(|e| CodegenError::Internal(format!("l2c branch: {:?}", e)))?;

        self.builder().position_at_end(fill_header);
        let fill_node = self.builder().build_phi(tm.ptr_type(), "l2c_fnode")
            .map_err(|e| CodegenError::Internal(format!("l2c phi: {:?}", e)))?;
        let fill_idx = self.builder().build_phi(tm.i64_type(), "l2c_fidx")
            .map_err(|e| CodegenError::Internal(format!("l2c phi: {:?}", e)))?;
        fill_node.add_incoming(&[(&list_ptr, pre_fill_block)]);
        fill_idx.add_incoming(&[(&tm.i64_type().const_zero(), pre_fill_block)]);

        let ftag = self.extract_adt_tag(fill_node.as_basic_value().into_pointer_value())?;
        let fis_nil = self.builder().build_int_compare(inkwell::IntPredicate::EQ, ftag, tm.i64_type().const_zero(), "l2c_fnil")
            .map_err(|e| CodegenError::Internal(format!("l2c cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(fis_nil, fill_done, fill_body)
            .map_err(|e| CodegenError::Internal(format!("l2c branch: {:?}", e)))?;

        self.builder().position_at_end(fill_body);
        let head = self.extract_adt_field(fill_node.as_basic_value().into_pointer_value(), 2, 0)?;
        let char_val = self.builder().build_ptr_to_int(head, tm.i64_type(), "l2c_char")
            .map_err(|e| CodegenError::Internal(format!("l2c ptr2int: {:?}", e)))?;
        let char_i8 = self.builder().build_int_truncate(char_val, tm.i8_type(), "l2c_i8")
            .map_err(|e| CodegenError::Internal(format!("l2c trunc: {:?}", e)))?;
        let dst = unsafe {
            self.builder().build_gep(tm.i8_type(), buf, &[fill_idx.as_basic_value().into_int_value()], "l2c_dst")
                .map_err(|e| CodegenError::Internal(format!("l2c gep: {:?}", e)))?
        };
        self.builder().build_store(dst, char_i8)
            .map_err(|e| CodegenError::Internal(format!("l2c store: {:?}", e)))?;

        let next_fidx = self.builder().build_int_add(fill_idx.as_basic_value().into_int_value(), tm.i64_type().const_int(1, false), "l2c_fnext")
            .map_err(|e| CodegenError::Internal(format!("l2c add: {:?}", e)))?;
        let ftail = self.extract_adt_field(fill_node.as_basic_value().into_pointer_value(), 2, 1)?;
        fill_node.add_incoming(&[(&ftail, fill_body)]);
        fill_idx.add_incoming(&[(&next_fidx, fill_body)]);
        self.builder().build_unconditional_branch(fill_header)
            .map_err(|e| CodegenError::Internal(format!("l2c branch: {:?}", e)))?;

        // --- Null-terminate ---
        self.builder().position_at_end(fill_done);
        let null_dst = unsafe {
            self.builder().build_gep(tm.i8_type(), buf, &[fill_idx.as_basic_value().into_int_value()], "l2c_null")
                .map_err(|e| CodegenError::Internal(format!("l2c gep: {:?}", e)))?
        };
        self.builder().build_store(null_dst, tm.i8_type().const_zero())
            .map_err(|e| CodegenError::Internal(format!("l2c store: {:?}", e)))?;

        Ok(buf)
    }

    /// Convert a cons-cell list of C-strings into a cons-cell list of [Char] lists.
    /// Used for converting the result of RTS functions like bhc_string_lines/words.
    fn cstring_list_to_char_list_list(&self, list_ptr: inkwell::values::PointerValue<'ctx>) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let walk_header = self.llvm_context().append_basic_block(current_fn, "csll_walk_hdr");
        let walk_body = self.llvm_context().append_basic_block(current_fn, "csll_walk_body");
        let walk_done = self.llvm_context().append_basic_block(current_fn, "csll_walk_done");

        let init_nil = self.build_nil()?;
        let pre_walk_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(walk_header)
            .map_err(|e| CodegenError::Internal(format!("csll branch: {:?}", e)))?;

        self.builder().position_at_end(walk_header);
        let w_node = self.builder().build_phi(tm.ptr_type(), "csll_node")
            .map_err(|e| CodegenError::Internal(format!("csll phi: {:?}", e)))?;
        let w_acc = self.builder().build_phi(tm.ptr_type(), "csll_acc")
            .map_err(|e| CodegenError::Internal(format!("csll phi: {:?}", e)))?;
        w_node.add_incoming(&[(&list_ptr, pre_walk_block)]);
        w_acc.add_incoming(&[(&init_nil, pre_walk_block)]);

        let tag = self.extract_adt_tag(w_node.as_basic_value().into_pointer_value())?;
        let is_nil = self.builder().build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "csll_nil")
            .map_err(|e| CodegenError::Internal(format!("csll cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_nil, walk_done, walk_body)
            .map_err(|e| CodegenError::Internal(format!("csll branch: {:?}", e)))?;

        self.builder().position_at_end(walk_body);
        let cstr_head = self.extract_adt_field(w_node.as_basic_value().into_pointer_value(), 2, 0)?;
        let char_list = self.cstring_to_char_list(cstr_head)?;
        let new_acc = self.build_cons(char_list.into(), w_acc.as_basic_value())?;
        let w_tail = self.extract_adt_field(w_node.as_basic_value().into_pointer_value(), 2, 1)?;

        let walk_body_end = self.builder().get_insert_block().unwrap();
        w_node.add_incoming(&[(&w_tail, walk_body_end)]);
        w_acc.add_incoming(&[(&new_acc, walk_body_end)]);
        self.builder().build_unconditional_branch(walk_header)
            .map_err(|e| CodegenError::Internal(format!("csll branch: {:?}", e)))?;

        self.builder().position_at_end(walk_done);
        let reversed = w_acc.as_basic_value().into_pointer_value();
        self.reverse_list(reversed)
    }

    /// Reverse a cons-cell linked list (builds a new reversed list).
    fn reverse_list(&self, list_ptr: inkwell::values::PointerValue<'ctx>) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function for reverse_list".to_string()))?;

        let rev_header = self.llvm_context().append_basic_block(current_fn, "rev_hdr");
        let rev_body = self.llvm_context().append_basic_block(current_fn, "rev_body");
        let rev_done = self.llvm_context().append_basic_block(current_fn, "rev_done");

        let nil = self.build_nil()?;
        let pre_rev_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("rev branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let r_node = self.builder().build_phi(tm.ptr_type(), "rev_node")
            .map_err(|e| CodegenError::Internal(format!("rev phi: {:?}", e)))?;
        let r_acc = self.builder().build_phi(tm.ptr_type(), "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("rev phi: {:?}", e)))?;
        r_node.add_incoming(&[(&list_ptr, pre_rev_block)]);
        r_acc.add_incoming(&[(&nil, pre_rev_block)]);

        let tag = self.extract_adt_tag(r_node.as_basic_value().into_pointer_value())?;
        let is_nil = self.builder().build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "rev_nil")
            .map_err(|e| CodegenError::Internal(format!("rev cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_nil, rev_done, rev_body)
            .map_err(|e| CodegenError::Internal(format!("rev branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let head = self.extract_adt_field(r_node.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail = self.extract_adt_field(r_node.as_basic_value().into_pointer_value(), 2, 1)?;
        let new_cons = self.build_cons(head.into(), r_acc.as_basic_value())?;
        let rev_body_end = self.builder().get_insert_block().unwrap();
        r_node.add_incoming(&[(&tail, rev_body_end)]);
        r_acc.add_incoming(&[(&new_cons, rev_body_end)]);
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("rev branch: {:?}", e)))?;

        self.builder().position_at_end(rev_done);
        Ok(r_acc.as_basic_value().into_pointer_value())
    }

    /// Convert a [Char] list of [Char] lists to a cons-cell list of C-strings.
    /// Used for passing list-of-strings to RTS functions like bhc_string_unlines/unwords.
    fn char_list_list_to_cstring_list(&self, list_ptr: inkwell::values::PointerValue<'ctx>) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let walk_header = self.llvm_context().append_basic_block(current_fn, "lccs_walk_hdr");
        let walk_body = self.llvm_context().append_basic_block(current_fn, "lccs_walk_body");
        let walk_done = self.llvm_context().append_basic_block(current_fn, "lccs_walk_done");

        let init_nil = self.build_nil()?;
        let pre_walk_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(walk_header)
            .map_err(|e| CodegenError::Internal(format!("lccs branch: {:?}", e)))?;

        self.builder().position_at_end(walk_header);
        let w_node = self.builder().build_phi(tm.ptr_type(), "lccs_node")
            .map_err(|e| CodegenError::Internal(format!("lccs phi: {:?}", e)))?;
        let w_acc = self.builder().build_phi(tm.ptr_type(), "lccs_acc")
            .map_err(|e| CodegenError::Internal(format!("lccs phi: {:?}", e)))?;
        w_node.add_incoming(&[(&list_ptr, pre_walk_block)]);
        w_acc.add_incoming(&[(&init_nil, pre_walk_block)]);

        let tag = self.extract_adt_tag(w_node.as_basic_value().into_pointer_value())?;
        let is_nil = self.builder().build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "lccs_nil")
            .map_err(|e| CodegenError::Internal(format!("lccs cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_nil, walk_done, walk_body)
            .map_err(|e| CodegenError::Internal(format!("lccs branch: {:?}", e)))?;

        self.builder().position_at_end(walk_body);
        let char_list_head = self.extract_adt_field(w_node.as_basic_value().into_pointer_value(), 2, 0)?;
        let cstr = self.char_list_to_cstring(char_list_head)?;
        let new_acc = self.build_cons(cstr.into(), w_acc.as_basic_value())?;
        let w_tail = self.extract_adt_field(w_node.as_basic_value().into_pointer_value(), 2, 1)?;
        let walk_body_end = self.builder().get_insert_block().unwrap();
        w_node.add_incoming(&[(&w_tail, walk_body_end)]);
        w_acc.add_incoming(&[(&new_acc, walk_body_end)]);
        self.builder().build_unconditional_branch(walk_header)
            .map_err(|e| CodegenError::Internal(format!("lccs branch: {:?}", e)))?;

        self.builder().position_at_end(walk_done);
        let reversed = w_acc.as_basic_value().into_pointer_value();
        self.reverse_list(reversed)
    }

    /// Try to extract a map application from an expression.
    /// Returns Some((map_fn, inner_list)) if expr is `map f xs`, None otherwise.
    ///
    /// This is used for fusion opportunities like `sum (map f xs)`.
    #[allow(unused_variables)]
    fn try_extract_map_app(_expr: &Expr) -> Option<(&Expr, &Expr)> {
        // TODO: Implement pattern matching for map applications
        // For now, return None to skip fusion and use the non-fused path
        None
    }

    /// Lower a fused sum(map f xs) into a single loop.
    /// This avoids allocating an intermediate list.
    #[allow(unused_variables)]
    fn lower_fused_sum_map(
        &mut self,
        _map_fn: &Expr,
        _inner_list: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // TODO: Implement fused sum/map lowering
        // This should generate a single loop that applies map_fn to each element
        // and accumulates the sum, without creating an intermediate list.
        Err(CodegenError::Internal(
            "fused sum/map not yet implemented".to_string(),
        ))
    }

    /// Lower `sum` - sum all elements of a list.
    /// sum [] = 0
    /// sum (x:xs) = x + sum xs
    fn lower_builtin_sum(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Check for fusion opportunity: sum (map f xs)
        // This fuses into a single loop that applies f to each element and sums
        if let Some((map_fn, inner_list)) = Self::try_extract_map_app(list_expr) {
            return self.lower_fused_sum_map(map_fn, inner_list);
        }

        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("sum: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("sum expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "sum_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "sum_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "sum_exit");

        // Jump to loop header
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header: phi for accumulator and current list pointer
        self.builder().position_at_end(loop_header);
        let acc_phi = self
            .builder()
            .build_phi(tm.i64_type(), "sum_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "sum_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if list is empty (tag == 0)
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: extract head, add to accumulator, continue with tail
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let head_val = self
            .builder()
            .build_ptr_to_int(head_ptr, tm.i64_type(), "head_val")
            .map_err(|e| CodegenError::Internal(format!("failed to ptr_to_int: {:?}", e)))?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let new_acc = self
            .builder()
            .build_int_add(
                acc_phi.as_basic_value().into_int_value(),
                head_val,
                "new_acc",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to add: {:?}", e)))?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add incoming values to phi nodes
        acc_phi.add_incoming(&[
            (&tm.i64_type().const_zero(), entry_block),
            (&new_acc, loop_body),
        ]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: return accumulator (boxed as pointer)
        self.builder().position_at_end(loop_exit);
        let result = self
            .builder()
            .build_int_to_ptr(
                acc_phi.as_basic_value().into_int_value(),
                tm.ptr_type(),
                "result",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to int_to_ptr: {:?}", e)))?;
        Ok(Some(result.into()))
    }

    /// Lower `product` - multiply all elements of a list.
    /// product [] = 1
    /// product (x:xs) = x * product xs
    fn lower_builtin_product(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("product: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "product expects a list".to_string(),
                ))
            }
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "prod_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "prod_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "prod_exit");

        // Jump to loop header
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header: phi for accumulator and current list pointer
        self.builder().position_at_end(loop_header);
        let acc_phi = self
            .builder()
            .build_phi(tm.i64_type(), "prod_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(tm.ptr_type(), "prod_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if list is empty (tag == 0)
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: extract head, multiply with accumulator, continue with tail
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let head_val = self
            .builder()
            .build_ptr_to_int(head_ptr, tm.i64_type(), "head_val")
            .map_err(|e| CodegenError::Internal(format!("failed to ptr_to_int: {:?}", e)))?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let new_acc = self
            .builder()
            .build_int_mul(
                acc_phi.as_basic_value().into_int_value(),
                head_val,
                "new_acc",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to mul: {:?}", e)))?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add incoming values to phi nodes (start with 1 for product)
        acc_phi.add_incoming(&[
            (&tm.i64_type().const_int(1, false), entry_block),
            (&new_acc, loop_body),
        ]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: return accumulator (boxed as pointer)
        self.builder().position_at_end(loop_exit);
        let result = self
            .builder()
            .build_int_to_ptr(
                acc_phi.as_basic_value().into_int_value(),
                tm.ptr_type(),
                "result",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to int_to_ptr: {:?}", e)))?;
        Ok(Some(result.into()))
    }

    /// Lower `map` - apply a function to each element of a list.
    /// map f [] = []
    /// map f (x:xs) = f x : map f xs
    fn lower_builtin_map(
        &mut self,
        fn_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the function (should be a closure)
        let fn_val = self
            .lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map: function has no value".to_string()))?;

        let fn_ptr = match fn_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "map: function must be a closure".to_string(),
                ))
            }
        };

        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("map: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("map expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "map_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "map_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "map_exit");

        // Build nil in entry block before branching
        let nil = self.build_nil()?;

        // Build result list in reverse (we'll reverse at the end)
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "map_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "map_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if list is empty
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: apply function to head, cons result onto accumulator
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call the function closure: fn_ptr(fn_ptr, head)
        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let mapped_val = self
            .builder()
            .build_indirect_call(
                fn_type,
                closure_fn_ptr,
                &[fn_ptr.into(), head_ptr.into()],
                "mapped",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to call map fn: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("map function returned void".to_string()))?;

        // Build new cons cell
        let new_cons = self.build_cons(mapped_val, result_phi.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values (nil was built in entry block before branching)
        result_phi.add_incoming(&[(&nil, entry_block), (&new_cons, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: reverse the result (we built it in reverse order)
        self.builder().position_at_end(loop_exit);

        // Call builtin reverse - but we need to do it inline to avoid recursion issues
        // For simplicity, we'll use an iterative reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        // Build nil2 before branching
        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // nil2 was built in loop_exit before branching
        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), loop_exit),
            (&rev_tail, rev_body),
        ]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `filter` - keep elements that satisfy a predicate.
    /// filter p [] = []
    /// filter p (x:xs) = if p x then x : filter p xs else filter p xs
    fn lower_builtin_filter(
        &mut self,
        pred_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the predicate (should be a closure)
        let pred_val = self
            .lower_expr(pred_expr)?
            .ok_or_else(|| CodegenError::Internal("filter: predicate has no value".to_string()))?;

        let pred_ptr = match pred_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "filter: predicate must be a closure".to_string(),
                ))
            }
        };

        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("filter: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("filter expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "filter_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "filter_body");
        let loop_keep = self.llvm_ctx.append_basic_block(current_fn, "filter_keep");
        let loop_skip = self.llvm_ctx.append_basic_block(current_fn, "filter_skip");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "filter_exit");

        // Build nil in entry block before branching
        let nil = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "filter_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "filter_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if list is empty
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: check predicate
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call predicate: pred_ptr(pred_ptr, head)
        let pred_fn_ptr = self.extract_closure_fn_ptr(pred_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let pred_result = self
            .builder()
            .build_indirect_call(
                fn_type,
                pred_fn_ptr,
                &[pred_ptr.into(), head_ptr.into()],
                "pred_result",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to call predicate: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("predicate returned void".to_string()))?;

        // Check if predicate returned True (non-zero value)
        // Bools are boxed as int_to_ptr, so we need to convert back with ptr_to_int
        let pred_bool = self
            .builder()
            .build_ptr_to_int(pred_result.into_pointer_value(), tm.i64_type(), "pred_bool")
            .map_err(|e| CodegenError::Internal(format!("failed to unbox pred result: {:?}", e)))?;
        let is_true = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::NE,
                pred_bool,
                tm.i64_type().const_zero(),
                "is_true",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_true, loop_keep, loop_skip)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Keep: cons head onto result
        self.builder().position_at_end(loop_keep);
        let new_cons = self.build_cons(head_ptr.into(), result_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Skip: just continue
        self.builder().position_at_end(loop_skip);
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values (nil was built in entry block)
        result_phi.add_incoming(&[
            (&nil, entry_block),
            (&new_cons, loop_keep),
            (&result_phi.as_basic_value(), loop_skip),
        ]);
        list_phi.add_incoming(&[
            (&list_ptr, entry_block),
            (&tail_ptr, loop_keep),
            (&tail_ptr, loop_skip),
        ]);

        // Exit: reverse the result
        self.builder().position_at_end(loop_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        // Build nil2 before branching
        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // nil2 was built in loop_exit before branching
        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), loop_exit),
            (&rev_tail, rev_body),
        ]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `foldl` - left fold over a list.
    /// foldl f z [] = z
    /// foldl f z (x:xs) = foldl f (f z x) xs
    ///
    /// Iterative implementation: accumulates from left to right
    fn lower_builtin_foldl(
        &mut self,
        func_expr: &Expr,
        init_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the function (should be a closure)
        let func_val = self
            .lower_expr(func_expr)?
            .ok_or_else(|| CodegenError::Internal("foldl: function has no value".to_string()))?;

        let func_ptr = match func_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "foldl: function must be a closure".to_string(),
                ))
            }
        };

        // Lower the initial value
        let init_val = self.lower_expr(init_expr)?.ok_or_else(|| {
            CodegenError::Internal("foldl: initial value has no value".to_string())
        })?;
        let init_ptr = self.value_to_ptr(init_val)?;

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("foldl: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("foldl expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "foldl_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "foldl_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "foldl_exit");

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let acc_phi = self
            .builder()
            .build_phi(ptr_type, "foldl_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "foldl_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if list is empty
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: acc = f acc head; list = tail
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call f acc head - function takes (closure_ptr, acc, head) and returns new acc
        // The closure stores the function pointer which expects all args at once
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let new_acc = self
            .builder()
            .build_indirect_call(
                fn_type,
                fn_ptr,
                &[
                    func_ptr.into(),
                    acc_phi.as_basic_value().into(),
                    head_ptr.into(),
                ],
                "foldl_result",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to call function: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("foldl: function returned void".to_string()))?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values
        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: return accumulator
        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `foldr` - right fold over a list.
    /// foldr f z [] = z
    /// foldr f z (x:xs) = f x (foldr f z xs)
    ///
    /// Implementation: reverse the list first, then fold left with swapped args
    fn lower_builtin_foldr(
        &mut self,
        func_expr: &Expr,
        init_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the function (should be a closure)
        let func_val = self
            .lower_expr(func_expr)?
            .ok_or_else(|| CodegenError::Internal("foldr: function has no value".to_string()))?;

        let func_ptr = match func_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "foldr: function must be a closure".to_string(),
                ))
            }
        };

        // Lower the initial value
        let init_val = self.lower_expr(init_expr)?.ok_or_else(|| {
            CodegenError::Internal("foldr: initial value has no value".to_string())
        })?;
        let init_ptr = self.value_to_ptr(init_val)?;

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("foldr: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("foldr expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // First, reverse the list
        let rev_entry = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let rev_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "foldr_rev_header");
        let rev_body = self
            .llvm_ctx
            .append_basic_block(current_fn, "foldr_rev_body");
        let rev_exit = self
            .llvm_ctx
            .append_basic_block(current_fn, "foldr_rev_exit");

        // Build nil before branching
        let nil = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Reverse loop
        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil, rev_entry), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[(&list_ptr, rev_entry), (&rev_tail, rev_body)]);

        // Now fold the reversed list with f applied as f elem acc
        self.builder().position_at_end(rev_exit);

        let fold_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "foldr_fold_header");
        let fold_body = self
            .llvm_ctx
            .append_basic_block(current_fn, "foldr_fold_body");
        let fold_exit = self
            .llvm_ctx
            .append_basic_block(current_fn, "foldr_fold_exit");

        self.builder()
            .build_unconditional_branch(fold_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Fold loop
        self.builder().position_at_end(fold_header);
        let acc_phi = self
            .builder()
            .build_phi(ptr_type, "foldr_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "foldr_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, fold_exit, fold_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(fold_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call f head acc - function takes (closure_ptr, elem, acc) and returns new acc
        // Note: for foldr, the function signature is (a -> b -> b), so elem comes first, then acc
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let new_acc = self
            .builder()
            .build_indirect_call(
                fn_type,
                fn_ptr,
                &[
                    func_ptr.into(),
                    head_ptr.into(),
                    acc_phi.as_basic_value().into(),
                ],
                "foldr_result",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to call function: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("foldr: function returned void".to_string()))?;

        self.builder()
            .build_unconditional_branch(fold_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values
        acc_phi.add_incoming(&[(&init_ptr, rev_exit), (&new_acc, fold_body)]);
        list_phi.add_incoming(&[
            (&rev_acc.as_basic_value(), rev_exit),
            (&tail_ptr, fold_body),
        ]);

        // Exit: return accumulator
        self.builder().position_at_end(fold_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `foldl'` - strict left fold (same as foldl but forces accumulator).
    /// In our implementation, foldl is already strict, so this is the same.
    fn lower_builtin_foldl_strict(
        &mut self,
        func_expr: &Expr,
        init_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Our foldl is already strict, so just delegate
        self.lower_builtin_foldl(func_expr, init_expr, list_expr)
    }

    /// Lower `zipWith` - apply a function to pairs of elements from two lists.
    /// zipWith f [] _ = []
    /// zipWith f _ [] = []
    /// zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
    fn lower_builtin_zipwith(
        &mut self,
        func_expr: &Expr,
        list1_expr: &Expr,
        list2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the function (should be a closure)
        let func_val = self
            .lower_expr(func_expr)?
            .ok_or_else(|| CodegenError::Internal("zipWith: function has no value".to_string()))?;

        let func_ptr = match func_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "zipWith: function must be a closure".to_string(),
                ))
            }
        };

        let list1_val = self
            .lower_expr(list1_expr)?
            .ok_or_else(|| CodegenError::Internal("zipWith: list1 has no value".to_string()))?;

        let list1_ptr = match list1_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("zipWith expects lists".to_string())),
        };

        let list2_val = self
            .lower_expr(list2_expr)?
            .ok_or_else(|| CodegenError::Internal("zipWith: list2 has no value".to_string()))?;

        let list2_ptr = match list2_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("zipWith expects lists".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "zipwith_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "zipwith_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "zipwith_exit");

        // Build nil in entry block
        let nil = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "zipwith_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list1_phi = self
            .builder()
            .build_phi(ptr_type, "zipwith_list1")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list2_phi = self
            .builder()
            .build_phi(ptr_type, "zipwith_list2")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if either list is empty
        let tag1 = self.extract_adt_tag(list1_phi.as_basic_value().into_pointer_value())?;
        let tag2 = self.extract_adt_tag(list2_phi.as_basic_value().into_pointer_value())?;
        let is_empty1 = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag1,
                tm.i64_type().const_zero(),
                "is_empty1",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;
        let is_empty2 = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag2,
                tm.i64_type().const_zero(),
                "is_empty2",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;
        let is_empty = self
            .builder()
            .build_or(is_empty1, is_empty2, "is_empty")
            .map_err(|e| CodegenError::Internal(format!("failed to build or: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body
        self.builder().position_at_end(loop_body);
        let head1_ptr =
            self.extract_adt_field(list1_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail1_ptr =
            self.extract_adt_field(list1_phi.as_basic_value().into_pointer_value(), 2, 1)?;
        let head2_ptr =
            self.extract_adt_field(list2_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail2_ptr =
            self.extract_adt_field(list2_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call the function: f x y
        // For binary functions (most common case with zipWith), we call with both args at once.
        // The closure convention is: closure_fn(closure_ptr, arg1, arg2) -> result
        let closure_fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let mapped_val = self
            .builder()
            .build_indirect_call(
                fn_type,
                closure_fn_ptr,
                &[func_ptr.into(), head1_ptr.into(), head2_ptr.into()],
                "mapped",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to call function: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("zipWith: function returned void".to_string()))?;

        // Build cons cell
        let new_cons = self.build_cons(mapped_val, result_phi.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values
        result_phi.add_incoming(&[(&nil, entry_block), (&new_cons, loop_body)]);
        list1_phi.add_incoming(&[(&list1_ptr, entry_block), (&tail1_ptr, loop_body)]);
        list2_phi.add_incoming(&[(&list2_ptr, entry_block), (&tail2_ptr, loop_body)]);

        // Exit: reverse the result
        self.builder().position_at_end(loop_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), loop_exit),
            (&rev_tail, rev_body),
        ]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `zip` - combine two lists into a list of pairs.
    /// zip [] _ = []
    /// zip _ [] = []
    /// zip (x:xs) (y:ys) = (x,y) : zip xs ys
    fn lower_builtin_zip(
        &mut self,
        list1_expr: &Expr,
        list2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list1_val = self
            .lower_expr(list1_expr)?
            .ok_or_else(|| CodegenError::Internal("zip: list1 has no value".to_string()))?;

        let list1_ptr = match list1_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("zip expects lists".to_string())),
        };

        let list2_val = self
            .lower_expr(list2_expr)?
            .ok_or_else(|| CodegenError::Internal("zip: list2 has no value".to_string()))?;

        let list2_ptr = match list2_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("zip expects lists".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "zip_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "zip_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "zip_exit");

        // Build nil in entry block
        let nil = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "zip_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list1_phi = self
            .builder()
            .build_phi(ptr_type, "zip_list1")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list2_phi = self
            .builder()
            .build_phi(ptr_type, "zip_list2")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if either list is empty
        let tag1 = self.extract_adt_tag(list1_phi.as_basic_value().into_pointer_value())?;
        let tag2 = self.extract_adt_tag(list2_phi.as_basic_value().into_pointer_value())?;
        let is_empty1 = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag1,
                tm.i64_type().const_zero(),
                "is_empty1",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;
        let is_empty2 = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag2,
                tm.i64_type().const_zero(),
                "is_empty2",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;
        let is_empty = self
            .builder()
            .build_or(is_empty1, is_empty2, "is_empty")
            .map_err(|e| CodegenError::Internal(format!("failed to build or: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body
        self.builder().position_at_end(loop_body);
        let head1_ptr =
            self.extract_adt_field(list1_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail1_ptr =
            self.extract_adt_field(list1_phi.as_basic_value().into_pointer_value(), 2, 1)?;
        let head2_ptr =
            self.extract_adt_field(list2_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail2_ptr =
            self.extract_adt_field(list2_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Build tuple (x, y) - represented as ADT with tag 0 and 2 fields
        let pair_ptr = self.build_pair(head1_ptr.into(), head2_ptr.into())?;

        // Build cons cell
        let new_cons = self.build_cons(pair_ptr.into(), result_phi.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values
        result_phi.add_incoming(&[(&nil, entry_block), (&new_cons, loop_body)]);
        list1_phi.add_incoming(&[(&list1_ptr, entry_block), (&tail1_ptr, loop_body)]);
        list2_phi.add_incoming(&[(&list2_ptr, entry_block), (&tail2_ptr, loop_body)]);

        // Exit: reverse the result
        self.builder().position_at_end(loop_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), loop_exit),
            (&rev_tail, rev_body),
        ]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Build a pair (tuple of 2 elements).
    fn build_pair(
        &self,
        fst: BasicValueEnum<'ctx>,
        snd: BasicValueEnum<'ctx>,
    ) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        let tm = self.type_mapper();
        // Pair is represented as ADT with tag 0 and 2 fields
        // Allocate space: tag (i64) + fst (ptr) + snd (ptr) = 24 bytes
        let size = tm.i64_type().const_int(24, false);
        let alloc_fn = self
            .functions
            .get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;
        let alloc_call = self
            .builder()
            .build_call(*alloc_fn, &[size.into()], "pair_alloc")
            .map_err(|e| CodegenError::Internal(format!("failed to call alloc: {:?}", e)))?;
        let pair_ptr = alloc_call
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("alloc returned void".to_string()))?
            .into_pointer_value();

        // Store tag = 0 (tuple constructor)
        self.builder()
            .build_store(pair_ptr, tm.i64_type().const_zero())
            .map_err(|e| CodegenError::Internal(format!("failed to store tag: {:?}", e)))?;

        // Store fst at offset 8
        let fst_slot = unsafe {
            self.builder()
                .build_gep(
                    tm.i64_type(),
                    pair_ptr,
                    &[tm.i64_type().const_int(1, false)],
                    "fst_ptr",
                )
                .map_err(|e| CodegenError::Internal(format!("failed to build gep: {:?}", e)))?
        };
        let fst_as_ptr = self.value_to_ptr(fst)?;
        self.builder()
            .build_store(fst_slot, fst_as_ptr)
            .map_err(|e| CodegenError::Internal(format!("failed to store fst: {:?}", e)))?;

        // Store snd at offset 16
        let snd_slot = unsafe {
            self.builder()
                .build_gep(
                    tm.i64_type(),
                    pair_ptr,
                    &[tm.i64_type().const_int(2, false)],
                    "snd_ptr",
                )
                .map_err(|e| CodegenError::Internal(format!("failed to build gep: {:?}", e)))?
        };
        let snd_as_ptr = self.value_to_ptr(snd)?;
        self.builder()
            .build_store(snd_slot, snd_as_ptr)
            .map_err(|e| CodegenError::Internal(format!("failed to store snd: {:?}", e)))?;

        Ok(pair_ptr)
    }

    /// Lower `last` - get last element of a list.
    /// last [] = error "empty list"
    /// last [x] = x
    /// last (_:xs) = last xs
    fn lower_builtin_last(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("last: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("last expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        // Check if list is empty at start
        let tag = self.extract_adt_tag(list_ptr)?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        let error_block = self.llvm_ctx.append_basic_block(current_fn, "last_error");
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "last_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "last_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "last_exit");

        self.builder()
            .build_conditional_branch(is_empty, error_block, loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Error block: empty list
        self.builder().position_at_end(error_block);
        let error_msg = self
            .module
            .add_global_string("last_error", "last: empty list");
        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;
        self.builder()
            .build_call(*error_fn, &[error_msg.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;
        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "last_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Extract head and tail
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Check if tail is empty (this element is the last)
        let tail_tag = self.extract_adt_tag(tail_ptr)?;
        let tail_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tail_tag,
                tm.i64_type().const_zero(),
                "tail_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(tail_is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: continue with tail
        self.builder().position_at_end(loop_body);
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: return head
        self.builder().position_at_end(loop_exit);
        Ok(Some(head_ptr.into()))
    }

    /// Lower `init` - get all but last element of a list.
    /// init [] = error "empty list"
    /// init [x] = []
    /// init (x:xs) = x : init xs
    fn lower_builtin_init(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("init: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("init expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        // Check if list is empty at start
        let tag = self.extract_adt_tag(list_ptr)?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        let error_block = self.llvm_ctx.append_basic_block(current_fn, "init_error");
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "init_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "init_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "init_exit");

        // Build nil in entry block
        let nil = self.build_nil()?;

        self.builder()
            .build_conditional_branch(is_empty, error_block, loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Error block: empty list
        self.builder().position_at_end(error_block);
        let error_msg = self
            .module
            .add_global_string("init_error", "init: empty list");
        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;
        self.builder()
            .build_call(*error_fn, &[error_msg.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;
        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "init_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "init_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Extract head and tail
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Check if tail is empty (this element is the last - don't include it)
        let tail_tag = self.extract_adt_tag(tail_ptr)?;
        let tail_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tail_tag,
                tm.i64_type().const_zero(),
                "tail_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(tail_is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: cons head onto result, continue with tail
        self.builder().position_at_end(loop_body);
        let new_cons = self.build_cons(head_ptr.into(), result_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values
        result_phi.add_incoming(&[(&nil, entry_block), (&new_cons, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: reverse the result
        self.builder().position_at_end(loop_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), loop_exit),
            (&rev_tail, rev_body),
        ]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `!!` - index into a list.
    /// [] !! _ = error "index too large"
    /// (x:_) !! 0 = x
    /// (_:xs) !! n = xs !! (n-1)
    fn lower_builtin_index(
        &mut self,
        list_expr: &Expr,
        index_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("!!: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("!! expects a list".to_string())),
        };

        let index_val = self
            .lower_expr(index_expr)?
            .ok_or_else(|| CodegenError::Internal("!!: index has no value".to_string()))?;

        let index = self.to_int_value(index_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "index_header");
        let check_empty = self
            .llvm_ctx
            .append_basic_block(current_fn, "index_check_empty");
        let check_zero = self
            .llvm_ctx
            .append_basic_block(current_fn, "index_check_zero");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "index_body");
        let error_block = self.llvm_ctx.append_basic_block(current_fn, "index_error");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "index_exit");

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "index_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let idx_phi = self
            .builder()
            .build_phi(tm.i64_type(), "index_idx")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        self.builder()
            .build_unconditional_branch(check_empty)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Check if list is empty
        self.builder().position_at_end(check_empty);
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, error_block, check_zero)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Check if index is zero
        self.builder().position_at_end(check_zero);
        let is_zero = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                idx_phi.as_basic_value().into_int_value(),
                tm.i64_type().const_zero(),
                "is_zero",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_zero, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Error block: index out of bounds
        self.builder().position_at_end(error_block);
        let error_msg = self
            .module
            .add_global_string("index_error", "!!: index too large");
        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;
        self.builder()
            .build_call(*error_fn, &[error_msg.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;
        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        // Loop body: decrement index, continue with tail
        self.builder().position_at_end(loop_body);
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;
        let new_idx = self
            .builder()
            .build_int_sub(
                idx_phi.as_basic_value().into_int_value(),
                tm.i64_type().const_int(1, false),
                "new_idx",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to sub: {:?}", e)))?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Add phi incoming values
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);
        idx_phi.add_incoming(&[(&index, entry_block), (&new_idx, loop_body)]);

        // Exit: return head
        self.builder().position_at_end(loop_exit);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        Ok(Some(head_ptr.into()))
    }

    /// Lower `concat` - flatten a list of lists.
    /// concat [] = []
    /// concat (xs:xss) = xs ++ concat xss
    fn lower_builtin_concat(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("concat: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "concat expects a list of lists".to_string(),
                ))
            }
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        // Build nil in entry block
        let nil = self.build_nil()?;

        // Outer loop: iterate over list of lists
        let outer_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "concat_outer_header");
        let outer_body = self
            .llvm_ctx
            .append_basic_block(current_fn, "concat_outer_body");
        let outer_exit = self
            .llvm_ctx
            .append_basic_block(current_fn, "concat_outer_exit");

        // Inner loop: iterate over current inner list
        let inner_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "concat_inner_header");
        let inner_body = self
            .llvm_ctx
            .append_basic_block(current_fn, "concat_inner_body");
        let inner_exit = self
            .llvm_ctx
            .append_basic_block(current_fn, "concat_inner_exit");

        self.builder()
            .build_unconditional_branch(outer_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Outer loop header
        self.builder().position_at_end(outer_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "concat_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let outer_list_phi = self
            .builder()
            .build_phi(ptr_type, "concat_outer_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if outer list is empty
        let outer_tag =
            self.extract_adt_tag(outer_list_phi.as_basic_value().into_pointer_value())?;
        let outer_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                outer_tag,
                tm.i64_type().const_zero(),
                "outer_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(outer_is_empty, outer_exit, outer_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Outer loop body: get current inner list and process it
        self.builder().position_at_end(outer_body);
        let inner_list_ptr =
            self.extract_adt_field(outer_list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let outer_tail_ptr =
            self.extract_adt_field(outer_list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        self.builder()
            .build_unconditional_branch(inner_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Inner loop header
        self.builder().position_at_end(inner_header);
        let inner_result_phi = self
            .builder()
            .build_phi(ptr_type, "concat_inner_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let inner_list_phi = self
            .builder()
            .build_phi(ptr_type, "concat_inner_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if inner list is empty
        let inner_tag =
            self.extract_adt_tag(inner_list_phi.as_basic_value().into_pointer_value())?;
        let inner_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                inner_tag,
                tm.i64_type().const_zero(),
                "inner_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(inner_is_empty, inner_exit, inner_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Inner loop body: cons head onto result
        self.builder().position_at_end(inner_body);
        let head_ptr =
            self.extract_adt_field(inner_list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(inner_list_phi.as_basic_value().into_pointer_value(), 2, 1)?;
        let new_cons = self.build_cons(head_ptr.into(), inner_result_phi.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(inner_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Inner phi incoming values
        inner_result_phi.add_incoming(&[
            (&result_phi.as_basic_value(), outer_body),
            (&new_cons, inner_body),
        ]);
        inner_list_phi.add_incoming(&[(&inner_list_ptr, outer_body), (&tail_ptr, inner_body)]);

        // Inner loop exit: continue with outer loop
        self.builder().position_at_end(inner_exit);
        self.builder()
            .build_unconditional_branch(outer_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Outer phi incoming values
        result_phi.add_incoming(&[
            (&nil, entry_block),
            (&inner_result_phi.as_basic_value(), inner_exit),
        ]);
        outer_list_phi.add_incoming(&[(&list_ptr, entry_block), (&outer_tail_ptr, inner_exit)]);

        // Outer exit: reverse the result
        self.builder().position_at_end(outer_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, outer_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), outer_exit),
            (&rev_tail, rev_body),
        ]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `concatMap` - map and concatenate.
    /// concatMap f xs = concat (map f xs)
    fn lower_builtin_concat_map(
        &mut self,
        func_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // For efficiency, we implement this directly rather than via concat (map f xs)
        let func_val = self.lower_expr(func_expr)?.ok_or_else(|| {
            CodegenError::Internal("concatMap: function has no value".to_string())
        })?;

        let func_ptr = match func_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "concatMap: function must be a closure".to_string(),
                ))
            }
        };

        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("concatMap: list has no value".to_string()))?;

        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "concatMap expects a list".to_string(),
                ))
            }
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        // Build nil in entry block
        let nil = self.build_nil()?;

        // Outer loop: iterate over input list
        let outer_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "concatmap_outer_header");
        let outer_body = self
            .llvm_ctx
            .append_basic_block(current_fn, "concatmap_outer_body");
        let outer_exit = self
            .llvm_ctx
            .append_basic_block(current_fn, "concatmap_outer_exit");

        // Inner loop: iterate over result of f applied to current element
        let inner_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "concatmap_inner_header");
        let inner_body = self
            .llvm_ctx
            .append_basic_block(current_fn, "concatmap_inner_body");
        let inner_exit = self
            .llvm_ctx
            .append_basic_block(current_fn, "concatmap_inner_exit");

        self.builder()
            .build_unconditional_branch(outer_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Outer loop header
        self.builder().position_at_end(outer_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "concatmap_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let outer_list_phi = self
            .builder()
            .build_phi(ptr_type, "concatmap_outer_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if outer list is empty
        let outer_tag =
            self.extract_adt_tag(outer_list_phi.as_basic_value().into_pointer_value())?;
        let outer_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                outer_tag,
                tm.i64_type().const_zero(),
                "outer_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(outer_is_empty, outer_exit, outer_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Outer loop body: apply f to head, process result
        self.builder().position_at_end(outer_body);
        let head_ptr =
            self.extract_adt_field(outer_list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let outer_tail_ptr =
            self.extract_adt_field(outer_list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call f on head
        let closure_fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let inner_list_ptr = self
            .builder()
            .build_indirect_call(
                fn_type,
                closure_fn_ptr,
                &[func_ptr.into(), head_ptr.into()],
                "f_result",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to call function: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| {
                CodegenError::Internal("concatMap: function returned void".to_string())
            })?;

        self.builder()
            .build_unconditional_branch(inner_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Inner loop header
        self.builder().position_at_end(inner_header);
        let inner_result_phi = self
            .builder()
            .build_phi(ptr_type, "concatmap_inner_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let inner_list_phi = self
            .builder()
            .build_phi(ptr_type, "concatmap_inner_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if inner list is empty
        let inner_tag =
            self.extract_adt_tag(inner_list_phi.as_basic_value().into_pointer_value())?;
        let inner_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                inner_tag,
                tm.i64_type().const_zero(),
                "inner_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(inner_is_empty, inner_exit, inner_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Inner loop body: cons head onto result
        self.builder().position_at_end(inner_body);
        let inner_head_ptr =
            self.extract_adt_field(inner_list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let inner_tail_ptr =
            self.extract_adt_field(inner_list_phi.as_basic_value().into_pointer_value(), 2, 1)?;
        let new_cons = self.build_cons(inner_head_ptr.into(), inner_result_phi.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(inner_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Inner phi incoming values
        inner_result_phi.add_incoming(&[
            (&result_phi.as_basic_value(), outer_body),
            (&new_cons, inner_body),
        ]);
        inner_list_phi
            .add_incoming(&[(&inner_list_ptr, outer_body), (&inner_tail_ptr, inner_body)]);

        // Inner loop exit: continue with outer loop
        self.builder().position_at_end(inner_exit);
        self.builder()
            .build_unconditional_branch(outer_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Outer phi incoming values
        result_phi.add_incoming(&[
            (&nil, entry_block),
            (&inner_result_phi.as_basic_value(), inner_exit),
        ]);
        outer_list_phi.add_incoming(&[(&list_ptr, entry_block), (&outer_tail_ptr, inner_exit)]);

        // Outer exit: reverse the result
        self.builder().position_at_end(outer_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, outer_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), outer_exit),
            (&rev_tail, rev_body),
        ]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `fst` - extract first element of a pair.
    fn lower_builtin_fst(
        &mut self,
        pair_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let pair_val = self
            .lower_expr(pair_expr)?
            .ok_or_else(|| CodegenError::Internal("fst: pair has no value".to_string()))?;

        let pair_ptr = match pair_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("fst expects a tuple".to_string())),
        };

        // Extract field 0 (first element)
        let fst_ptr = self.extract_adt_field(pair_ptr, 2, 0)?;
        Ok(Some(fst_ptr.into()))
    }

    /// Lower `snd` - extract second element of a pair.
    fn lower_builtin_snd(
        &mut self,
        pair_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let pair_val = self
            .lower_expr(pair_expr)?
            .ok_or_else(|| CodegenError::Internal("snd: pair has no value".to_string()))?;

        let pair_ptr = match pair_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("snd expects a tuple".to_string())),
        };

        // Extract field 1 (second element)
        let snd_ptr = self.extract_adt_field(pair_ptr, 2, 1)?;
        Ok(Some(snd_ptr.into()))
    }

    /// Lower `$sel_N` - extract Nth field from a tuple/dictionary.
    ///
    /// Field selectors are used for type class dictionary method extraction.
    /// The dictionary is represented as a tuple (ADT with tag 0 and N fields),
    /// and $sel_N extracts the Nth field.
    ///
    /// Memory layout of a tuple: { i64 tag, ptr field_0, ptr field_1, ... }
    /// So field N is at byte offset: 8 + N * 8 = (1 + N) * 8
    fn lower_builtin_field_selector(
        &mut self,
        tuple_expr: &Expr,
        field_index: u32,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let tuple_val = self.lower_expr(tuple_expr)?.ok_or_else(|| {
            CodegenError::Internal(format!("$sel_{}: tuple has no value", field_index))
        })?;

        let tuple_ptr = match tuple_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(format!(
                    "$sel_{} expects a tuple/dictionary",
                    field_index
                )))
            }
        };

        let tm = self.type_mapper();

        // Use raw pointer arithmetic to access the field at the correct offset.
        // ADT layout: { i64 tag, ptr field_0, ptr field_1, ... }
        // Field N is at index (1 + N) when treating as array of i64-sized elements.
        let field_offset = 1 + field_index; // Skip tag (index 0)

        let field_ptr = unsafe {
            self.builder()
                .build_gep(
                    tm.i64_type(), // Treating memory as array of 8-byte slots
                    tuple_ptr,
                    &[tm.i64_type().const_int(field_offset as u64, false)],
                    &format!("field_ptr_{}", field_index),
                )
                .map_err(|e| {
                    CodegenError::Internal(format!("failed to build field gep: {:?}", e))
                })?
        };

        // Load the field value (which is a pointer)
        let field_val = self
            .builder()
            .build_load(tm.ptr_type(), field_ptr, &format!("field_{}", field_index))
            .map_err(|e| CodegenError::Internal(format!("failed to load field: {:?}", e)))?;

        Ok(Some(field_val))
    }

    /// Lower `fromJust` - extract value from Just, error on Nothing.
    fn lower_builtin_from_just(
        &mut self,
        maybe_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let maybe_val = self
            .lower_expr(maybe_expr)?
            .ok_or_else(|| CodegenError::Internal("fromJust: maybe has no value".to_string()))?;

        let maybe_ptr = match maybe_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "fromJust expects Maybe".to_string(),
                ))
            }
        };

        let tag = self.extract_adt_tag(maybe_ptr)?;
        let tm = self.type_mapper();

        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let nothing_block = self
            .llvm_context()
            .append_basic_block(current_fn, "fromJust_nothing");
        let just_block = self
            .llvm_context()
            .append_basic_block(current_fn, "fromJust_just");

        // Tag: Nothing=0, Just=1
        let is_nothing = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_nothing",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_nothing, nothing_block, just_block)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Nothing case: error
        self.builder().position_at_end(nothing_block);
        let error_msg = self
            .module
            .add_global_string("fromJust_error", "fromJust: Nothing");
        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;
        self.builder()
            .build_call(*error_fn, &[error_msg.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;
        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        // Just case: extract value
        self.builder().position_at_end(just_block);
        let val_ptr = self.extract_adt_field(maybe_ptr, 1, 0)?;
        Ok(Some(val_ptr.into()))
    }

    /// Lower `isJust` - check if Maybe is Just.
    fn lower_builtin_is_just(
        &mut self,
        maybe_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let maybe_val = self
            .lower_expr(maybe_expr)?
            .ok_or_else(|| CodegenError::Internal("isJust: maybe has no value".to_string()))?;

        let maybe_ptr = match maybe_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("isJust expects Maybe".to_string())),
        };

        let tag = self.extract_adt_tag(maybe_ptr)?;
        let tm = self.type_mapper();

        // isJust = (tag == 1)
        let is_just = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_int(1, false),
                "is_just",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        let result = self
            .builder()
            .build_int_z_extend(is_just, tm.i64_type(), "isJust_result")
            .map_err(|e| CodegenError::Internal(format!("failed to extend: {:?}", e)))?;

        Ok(Some(result.into()))
    }

    /// Lower `isNothing` - check if Maybe is Nothing.
    fn lower_builtin_is_nothing(
        &mut self,
        maybe_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let maybe_val = self
            .lower_expr(maybe_expr)?
            .ok_or_else(|| CodegenError::Internal("isNothing: maybe has no value".to_string()))?;

        let maybe_ptr = match maybe_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "isNothing expects Maybe".to_string(),
                ))
            }
        };

        let tag = self.extract_adt_tag(maybe_ptr)?;
        let tm = self.type_mapper();

        // isNothing = (tag == 0)
        let is_nothing = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_nothing",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        let result = self
            .builder()
            .build_int_z_extend(is_nothing, tm.i64_type(), "isNothing_result")
            .map_err(|e| CodegenError::Internal(format!("failed to extend: {:?}", e)))?;

        Ok(Some(result.into()))
    }

    /// Lower `isLeft` - check if Either is Left.
    fn lower_builtin_is_left(
        &mut self,
        either_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let either_val = self
            .lower_expr(either_expr)?
            .ok_or_else(|| CodegenError::Internal("isLeft: either has no value".to_string()))?;

        let either_ptr = match either_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("isLeft expects Either".to_string())),
        };

        let tag = self.extract_adt_tag(either_ptr)?;
        let tm = self.type_mapper();

        // isLeft = (tag == 0)
        let is_left = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_left",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        let result = self
            .builder()
            .build_int_z_extend(is_left, tm.i64_type(), "isLeft_result")
            .map_err(|e| CodegenError::Internal(format!("failed to extend: {:?}", e)))?;

        Ok(Some(result.into()))
    }

    /// Lower `isRight` - check if Either is Right.
    fn lower_builtin_is_right(
        &mut self,
        either_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let either_val = self
            .lower_expr(either_expr)?
            .ok_or_else(|| CodegenError::Internal("isRight: either has no value".to_string()))?;

        let either_ptr = match either_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "isRight expects Either".to_string(),
                ))
            }
        };

        let tag = self.extract_adt_tag(either_ptr)?;
        let tm = self.type_mapper();

        // isRight = (tag == 1)
        let is_right = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_int(1, false),
                "is_right",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        let result = self
            .builder()
            .build_int_z_extend(is_right, tm.i64_type(), "isRight_result")
            .map_err(|e| CodegenError::Internal(format!("failed to extend: {:?}", e)))?;

        Ok(Some(result.into()))
    }

    /// Lower `error` - runtime error.
    fn lower_builtin_error(
        &mut self,
        msg_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let msg_val = self
            .lower_expr(msg_expr)?
            .ok_or_else(|| CodegenError::Internal("error: message has no value".to_string()))?;

        let msg_ptr = match msg_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                // If it's not a pointer, use a default error message
                self.module
                    .add_global_string("error_default", "error called")
            }
        };

        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;

        self.builder()
            .build_call(*error_fn, &[msg_ptr.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;

        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        // error never returns, but we need to return something for the type system
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `undefined` - always errors.
    fn lower_builtin_undefined(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let error_msg = self
            .module
            .add_global_string("undefined_error", "undefined");
        let error_fn = self
            .functions
            .get(&VarId::new(1000006))
            .ok_or_else(|| CodegenError::Internal("bhc_error not declared".to_string()))?;

        self.builder()
            .build_call(*error_fn, &[error_msg.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call error: {:?}", e)))?;

        self.builder()
            .build_unreachable()
            .map_err(|e| CodegenError::Internal(format!("failed to build unreachable: {:?}", e)))?;

        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `throw` / `throwIO` - call bhc_throw and return the sentinel.
    fn lower_builtin_throw(
        &mut self,
        msg_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let msg_val = self
            .lower_expr(msg_expr)?
            .ok_or_else(|| CodegenError::Internal("throw: message has no value".to_string()))?;

        let msg_ptr = self.value_to_ptr(msg_val)?;

        let throw_fn = self
            .functions
            .get(&VarId::new(1000080))
            .ok_or_else(|| CodegenError::Internal("bhc_throw not declared".to_string()))?;

        let result = self
            .builder()
            .build_call(*throw_fn, &[msg_ptr.into()], "throw_sentinel")
            .map_err(|e| CodegenError::Internal(format!("failed to call throw: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("throw: returned void".to_string()))?;

        Ok(Some(result))
    }

    /// Lower `catch` - call bhc_catch with action and handler closures.
    ///
    /// catch :: IO a -> (SomeException -> IO a) -> IO a
    ///
    /// Extracts fn_ptr and closure_ptr from both the action and handler,
    /// then calls bhc_catch(action_fn, action_env, handler_fn, handler_env).
    /// Wrap an IO action expression as a thunk (closure) for deferred execution.
    ///
    /// This creates a new function that evaluates the expression when called,
    /// and wraps it in a closure. Used for `catch`, `bracket`, and similar
    /// functions that need to defer IO actions.
    fn wrap_io_as_thunk(
        &mut self,
        expr: &Expr,
    ) -> CodegenResult<PointerValue<'ctx>> {
        // If the expression is already a lambda/closure, just lower it normally
        if matches!(expr, Expr::Lam(_, _, _)) {
            let val = self.lower_expr(expr)?
                .ok_or_else(|| CodegenError::Internal("wrap_io_as_thunk: no value".to_string()))?;
            return self.value_to_ptr(val);
        }

        // Compute free variables
        let free = self.free_vars(expr);

        // Collect captured variable values
        let mut captured: Vec<(VarId, BasicValueEnum<'ctx>)> = Vec::new();
        for var_id in &free {
            if let Some(val) = self.env.get(var_id) {
                captured.push((*var_id, *val));
            }
        }

        // Save current state
        let current_block = self.builder().get_insert_block();
        let fn_name = self.next_closure_name();

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();

        // Create function: fn(env_ptr) -> result_ptr
        let fn_type = ptr_type.fn_type(&[ptr_type.into()], false);
        let lifted_fn = self.module.add_function(&fn_name, fn_type);

        let entry = self.llvm_context().append_basic_block(lifted_fn, "entry");
        self.builder().position_at_end(entry);

        // Save and replace environment
        let old_env = std::mem::take(&mut self.env);

        // Restore captured variables from closure env
        if !captured.is_empty() {
            let closure_ptr = lifted_fn
                .get_first_param()
                .ok_or_else(|| CodegenError::Internal("missing closure param".to_string()))?
                .into_pointer_value();

            for (i, (var_id, _)) in captured.iter().enumerate() {
                let elem_ptr =
                    self.extract_closure_env_elem(closure_ptr, captured.len() as u32, i as u32)?;
                self.env.insert(*var_id, elem_ptr.into());
            }
        }

        // Lower the expression inside the thunk
        let result = self.lower_expr(expr)?;

        // Return result
        if let Some(val) = result {
            let ret_ptr = self.value_to_ptr(val)?;
            self.builder()
                .build_return(Some(&ret_ptr))
                .map_err(|e| CodegenError::Internal(format!("thunk return failed: {:?}", e)))?;
        } else {
            let null = ptr_type.const_null();
            self.builder()
                .build_return(Some(&null))
                .map_err(|e| CodegenError::Internal(format!("thunk null return failed: {:?}", e)))?;
        }

        // Restore environment and insertion point
        self.env = old_env;
        if let Some(block) = current_block {
            self.builder().position_at_end(block);
        }

        // Create closure
        let fn_ptr = lifted_fn.as_global_value().as_pointer_value();
        self.alloc_closure(fn_ptr, &captured)
    }

    fn lower_builtin_catch(
        &mut self,
        action_expr: &Expr,
        handler_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Wrap the action as a thunk so it's deferred (not eagerly evaluated)
        let action_closure = self.wrap_io_as_thunk(action_expr)?;
        let handler_val = self
            .lower_expr(handler_expr)?
            .ok_or_else(|| CodegenError::Internal("catch: handler has no value".to_string()))?;
        let handler_closure = self.value_to_ptr(handler_val)?;

        let action_fn = self.extract_closure_fn_ptr(action_closure)?;
        let handler_fn = self.extract_closure_fn_ptr(handler_closure)?;

        let catch_rts = self
            .functions
            .get(&VarId::new(1000081))
            .ok_or_else(|| CodegenError::Internal("bhc_catch not declared".to_string()))?;

        let result = self
            .builder()
            .build_call(
                *catch_rts,
                &[
                    action_fn.into(),
                    action_closure.into(),
                    handler_fn.into(),
                    handler_closure.into(),
                ],
                "catch_result",
            )
            .map_err(|e| CodegenError::Internal(format!("catch call failed: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("catch: returned void".to_string()))?;

        Ok(Some(result))
    }

    /// Lower `try` - execute action wrapped in catch.
    ///
    /// try :: IO a -> IO (Either SomeException a)
    ///
    /// Uses bhc_catch with a handler that returns the exception as a Left value.
    /// Simplified: wraps in catch; on success returns the result directly.
    /// Full Either construction would require ADT allocation at codegen level.
    fn lower_builtin_try(
        &mut self,
        action_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // For now, execute the action directly. A proper implementation would
        // wrap in bhc_catch and construct Either values, but that requires
        // ADT allocation infrastructure that's not yet available here.
        let result = self.lower_expr(action_expr)?;
        Ok(result)
    }

    /// Lower `bracket` - acquire/use/release with exception safety.
    ///
    /// bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
    ///
    /// Calls bhc_bracket(acquire_fn, acquire_env, release_fn, release_env, use_fn, use_env).
    /// The RTS ensures release always runs even if use throws.
    fn lower_builtin_bracket(
        &mut self,
        acquire_expr: &Expr,
        release_expr: &Expr,
        use_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Wrap acquire as a thunk (deferred IO action)
        let acquire_closure = self.wrap_io_as_thunk(acquire_expr)?;
        // release and use are functions (lambdas), lower normally
        let release_val = self
            .lower_expr(release_expr)?
            .ok_or_else(|| CodegenError::Internal("bracket: release has no value".to_string()))?;
        let use_val = self
            .lower_expr(use_expr)?
            .ok_or_else(|| CodegenError::Internal("bracket: use has no value".to_string()))?;

        let release_closure = self.value_to_ptr(release_val)?;
        let use_closure = self.value_to_ptr(use_val)?;

        let acquire_fn = self.extract_closure_fn_ptr(acquire_closure)?;
        let release_fn = self.extract_closure_fn_ptr(release_closure)?;
        let use_fn = self.extract_closure_fn_ptr(use_closure)?;

        let bracket_rts = self
            .functions
            .get(&VarId::new(1000090))
            .ok_or_else(|| CodegenError::Internal("bhc_bracket not declared".to_string()))?;

        let result = self
            .builder()
            .build_call(
                *bracket_rts,
                &[
                    acquire_fn.into(),
                    acquire_closure.into(),
                    release_fn.into(),
                    release_closure.into(),
                    use_fn.into(),
                    use_closure.into(),
                ],
                "bracket_result",
            )
            .map_err(|e| CodegenError::Internal(format!("bracket call failed: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("bracket: returned void".to_string()))?;

        Ok(Some(result))
    }

    /// Lower `finally` - execute action with guaranteed cleanup.
    ///
    /// finally :: IO a -> IO b -> IO a
    ///
    /// Calls bhc_finally(action_fn, action_env, cleanup_fn, cleanup_env).
    /// The RTS ensures cleanup always runs, re-throwing any exception afterward.
    fn lower_builtin_finally(
        &mut self,
        action_expr: &Expr,
        cleanup_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let action_val = self
            .lower_expr(action_expr)?
            .ok_or_else(|| CodegenError::Internal("finally: action has no value".to_string()))?;
        let cleanup_val = self
            .lower_expr(cleanup_expr)?
            .ok_or_else(|| CodegenError::Internal("finally: cleanup has no value".to_string()))?;

        let action_closure = self.value_to_ptr(action_val)?;
        let cleanup_closure = self.value_to_ptr(cleanup_val)?;

        let action_fn = self.extract_closure_fn_ptr(action_closure)?;
        let cleanup_fn = self.extract_closure_fn_ptr(cleanup_closure)?;

        let finally_rts = self
            .functions
            .get(&VarId::new(1000088))
            .ok_or_else(|| CodegenError::Internal("bhc_finally not declared".to_string()))?;

        let result = self
            .builder()
            .build_call(
                *finally_rts,
                &[
                    action_fn.into(),
                    action_closure.into(),
                    cleanup_fn.into(),
                    cleanup_closure.into(),
                ],
                "finally_result",
            )
            .map_err(|e| CodegenError::Internal(format!("finally call failed: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("finally: returned void".to_string()))?;

        Ok(Some(result))
    }

    /// Lower `onException` - execute action, run handler only on exception.
    ///
    /// onException :: IO a -> IO b -> IO a
    ///
    /// Calls bhc_on_exception(action_fn, action_env, handler_fn, handler_env).
    /// The RTS runs the handler only if the action throws, then re-throws.
    fn lower_builtin_on_exception(
        &mut self,
        action_expr: &Expr,
        handler_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let action_val = self
            .lower_expr(action_expr)?
            .ok_or_else(|| {
                CodegenError::Internal("onException: action has no value".to_string())
            })?;
        let handler_val = self
            .lower_expr(handler_expr)?
            .ok_or_else(|| {
                CodegenError::Internal("onException: handler has no value".to_string())
            })?;

        let action_closure = self.value_to_ptr(action_val)?;
        let handler_closure = self.value_to_ptr(handler_val)?;

        let action_fn = self.extract_closure_fn_ptr(action_closure)?;
        let handler_fn = self.extract_closure_fn_ptr(handler_closure)?;

        let on_exc_rts = self
            .functions
            .get(&VarId::new(1000089))
            .ok_or_else(|| {
                CodegenError::Internal("bhc_on_exception not declared".to_string())
            })?;

        let result = self
            .builder()
            .build_call(
                *on_exc_rts,
                &[
                    action_fn.into(),
                    action_closure.into(),
                    handler_fn.into(),
                    handler_closure.into(),
                ],
                "on_exception_result",
            )
            .map_err(|e| CodegenError::Internal(format!("onException call failed: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| {
                CodegenError::Internal("onException: returned void".to_string())
            })?;

        Ok(Some(result))
    }

    /// Lower `seq` - force evaluation of first argument, return second.
    fn lower_builtin_seq(
        &mut self,
        a_expr: &Expr,
        b_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Evaluate first argument (for its effect of forcing evaluation)
        let _a = self.lower_expr(a_expr)?;
        // Return second argument
        self.lower_expr(b_expr)
    }

    /// Lower `not` - boolean negation.
    fn lower_builtin_not(
        &mut self,
        bool_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let bool_val = self
            .lower_expr(bool_expr)?
            .ok_or_else(|| CodegenError::Internal("not: argument has no value".to_string()))?;

        let tm = self.type_mapper();

        // Handle different representations of Bool
        let result = match bool_val {
            BasicValueEnum::IntValue(i) => {
                // XOR with 1 to flip the boolean
                let one = i.get_type().const_int(1, false);
                self.builder()
                    .build_xor(i, one, "not_result")
                    .map_err(|e| CodegenError::Internal(format!("failed to build not: {:?}", e)))?
                    .into()
            }
            BasicValueEnum::PointerValue(p) => {
                // Convert pointer to int, XOR with 1, convert back
                let int_val = self
                    .builder()
                    .build_ptr_to_int(p, tm.i64_type(), "bool_to_int")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to convert bool: {:?}", e))
                    })?;
                let one = tm.i64_type().const_int(1, false);
                let xored = self
                    .builder()
                    .build_xor(int_val, one, "not_result")
                    .map_err(|e| CodegenError::Internal(format!("failed to build not: {:?}", e)))?;
                self.builder()
                    .build_int_to_ptr(xored, tm.ptr_type(), "not_to_ptr")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to convert not result: {:?}", e))
                    })?
                    .into()
            }
            _ => return Err(CodegenError::TypeError("not expects a boolean".to_string())),
        };

        Ok(Some(result))
    }

    // ========================================================================
    // IO Builtin Functions
    // ========================================================================

    /// Lower `putStrLn` - print a string followed by newline.
    fn lower_builtin_put_str_ln(
        &mut self,
        str_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Print the string (which is a [Char] linked list), then print a newline
        self.lower_print_char_list(str_expr)?;

        // Print newline
        let newline_fn = self.functions.get(&VarId::new(1000010)).ok_or_else(|| {
            CodegenError::Internal("bhc_print_newline not declared".to_string())
        })?;
        self.builder()
            .build_call(*newline_fn, &[], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call newline: {:?}", e)))?;

        // Return unit (null pointer for IO ())
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `putStr` - print a string without newline.
    fn lower_builtin_put_str(
        &mut self,
        str_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Print the string (which is a [Char] linked list)
        self.lower_print_char_list(str_expr)?;

        // Return unit
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Emit a loop that walks a [Char] linked list and prints each character.
    fn lower_print_char_list(
        &mut self,
        str_expr: &Expr,
    ) -> CodegenResult<()> {
        let str_val = self
            .lower_expr(str_expr)?
            .ok_or_else(|| CodegenError::Internal("print: string has no value".to_string()))?;

        let list_ptr = match str_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "print expects a string (pointer)".to_string(),
                ))
            }
        };

        let tm = self.type_mapper();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let print_char_fn = self.functions.get(&VarId::new(1000009)).ok_or_else(|| {
            CodegenError::Internal("bhc_print_char not declared".to_string())
        })?;

        // Create loop blocks
        let loop_header = self
            .llvm_context()
            .append_basic_block(current_fn, "print_loop");
        let loop_body = self
            .llvm_context()
            .append_basic_block(current_fn, "print_body");
        let loop_end = self
            .llvm_context()
            .append_basic_block(current_fn, "print_done");

        // Branch to loop header
        let pre_loop_block = self.builder().get_insert_block().unwrap();
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Loop header: phi node for current list pointer
        self.builder().position_at_end(loop_header);
        let current_node = self
            .builder()
            .build_phi(tm.ptr_type(), "cur_node")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        current_node.add_incoming(&[(&list_ptr, pre_loop_block)]);

        // Load tag from current node
        let tag = self.extract_adt_tag(current_node.as_basic_value().into_pointer_value())?;
        let is_nil = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_nil",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(is_nil, loop_end, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Loop body: extract char, print it, advance to tail
        self.builder().position_at_end(loop_body);
        let node_ptr = current_node.as_basic_value().into_pointer_value();

        // Extract head (char) at field 0
        let head_ptr = self.extract_adt_field(node_ptr, 2, 0)?;
        // The char was stored via int_to_ptr, so convert back to int
        let char_val = self
            .builder()
            .build_ptr_to_int(head_ptr, tm.i64_type(), "char_val")
            .map_err(|e| CodegenError::Internal(format!("failed to get char: {:?}", e)))?;
        // Truncate to i32 for bhc_print_char
        let char_i32 = self
            .builder()
            .build_int_truncate(char_val, tm.i32_type(), "char_i32")
            .map_err(|e| CodegenError::Internal(format!("failed to truncate: {:?}", e)))?;
        self.builder()
            .build_call(*print_char_fn, &[char_i32.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call print_char: {:?}", e)))?;

        // Extract tail at field 1
        let tail_ptr = self.extract_adt_field(node_ptr, 2, 1)?;
        current_node.add_incoming(&[(&tail_ptr, loop_body)]);

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Continue after loop
        self.builder().position_at_end(loop_end);
        Ok(())
    }

    /// Lower `putChar` - print a single character.
    fn lower_builtin_put_char(
        &mut self,
        char_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let char_val = self
            .lower_expr(char_expr)?
            .ok_or_else(|| CodegenError::Internal("putChar: char has no value".to_string()))?;

        let char_int = match char_val {
            BasicValueEnum::IntValue(i) => i,
            BasicValueEnum::PointerValue(p) => {
                // Might be a boxed char - unbox it
                self.builder()
                    .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_char")
                    .map_err(|e| CodegenError::Internal(format!("failed to unbox char: {:?}", e)))?
            }
            _ => {
                return Err(CodegenError::TypeError(
                    "putChar expects a Char".to_string(),
                ))
            }
        };

        // Truncate to i32 for the RTS call
        let char_i32 = self
            .builder()
            .build_int_truncate(char_int, self.type_mapper().i32_type(), "char_i32")
            .map_err(|e| CodegenError::Internal(format!("failed to truncate char: {:?}", e)))?;

        // Call bhc_print_char
        let print_fn = self
            .functions
            .get(&VarId::new(1000009))
            .ok_or_else(|| CodegenError::Internal("bhc_print_char not declared".to_string()))?;

        self.builder()
            .build_call(*print_fn, &[char_i32.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to call print_char: {:?}", e)))?;

        // Return unit
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `print` - print a value with its Show instance (simplified).
    ///
    /// For now, we detect the type at codegen time and call the appropriate
    /// print function. This is a simplification - real Haskell uses type classes.
    fn lower_builtin_print(
        &mut self,
        val_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Get the type of the expression to decide how to print
        let expr_ty = val_expr.ty();

        let val = self
            .lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("print: value has no result".to_string()))?;

        match val {
            BasicValueEnum::IntValue(i) => {
                // Check if this is a boolean (from comparison or boolean function)
                if self.is_bool_type(&expr_ty) || self.expr_looks_like_bool(val_expr) {
                    // Print as boolean (True/False)
                    let print_fn = self.functions.get(&VarId::new(1000008)).ok_or_else(|| {
                        CodegenError::Internal("bhc_print_bool_ln not declared".to_string())
                    })?;

                    self.builder()
                        .build_call(*print_fn, &[i.into()], "")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to call print_bool: {:?}", e))
                        })?;
                } else {
                    // Print as integer
                    let print_fn = self.functions.get(&VarId::new(1000000)).ok_or_else(|| {
                        CodegenError::Internal("bhc_print_int_ln not declared".to_string())
                    })?;

                    self.builder()
                        .build_call(*print_fn, &[i.into()], "")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to call print_int: {:?}", e))
                        })?;
                }
            }
            BasicValueEnum::FloatValue(f) => {
                // Print as double
                let print_fn = self.functions.get(&VarId::new(1000001)).ok_or_else(|| {
                    CodegenError::Internal("bhc_print_double_ln not declared".to_string())
                })?;

                // Extend float to double if needed (check if it's f32)
                let f64_type = self.type_mapper().f64_type();
                let f32_type = self.type_mapper().f32_type();
                let f64_val = if f.get_type() == f32_type {
                    self.builder()
                        .build_float_ext(f, f64_type, "to_f64")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to extend float: {:?}", e))
                        })?
                } else {
                    f
                };

                self.builder()
                    .build_call(*print_fn, &[f64_val.into()], "")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to call print_double: {:?}", e))
                    })?;
            }
            BasicValueEnum::PointerValue(p) => {
                // Pointer could be a boxed value from closure call, string, or ADT.
                // Use the expression's type to decide how to print.
                // Check list first - by type or by expression structure (for when type is Error)
                if self.is_list_type(&expr_ty) || self.expr_looks_like_list(val_expr) {
                    // Print list: [el1, el2, ...]
                    self.print_list(p)?;
                } else if self.is_int_type(&expr_ty) || self.is_type_variable_or_error(&expr_ty) {
                    // Boxed integer (or polymorphic type that might be int) - unbox and print as int.
                    // For type variables from closures, we assume int since that's the most common case.
                    // This is safe because boxed ints use int_to_ptr which stores the value in the
                    // pointer bits, not as an actual memory reference.
                    let int_val = self
                        .builder()
                        .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_int")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to unbox int: {:?}", e))
                        })?;

                    let print_fn = self.functions.get(&VarId::new(1000000)).ok_or_else(|| {
                        CodegenError::Internal("bhc_print_int_ln not declared".to_string())
                    })?;

                    self.builder()
                        .build_call(*print_fn, &[int_val.into()], "")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to call print_int: {:?}", e))
                        })?;
                } else if self.is_float_type(&expr_ty) {
                    // Boxed float - unbox and print as double
                    let bits = self
                        .builder()
                        .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_float_bits")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to unbox float: {:?}", e))
                        })?;
                    let float_val = self
                        .builder()
                        .build_bit_cast(bits, self.type_mapper().f64_type(), "to_double")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to cast to double: {:?}", e))
                        })?;

                    let print_fn = self.functions.get(&VarId::new(1000001)).ok_or_else(|| {
                        CodegenError::Internal("bhc_print_double_ln not declared".to_string())
                    })?;

                    self.builder()
                        .build_call(*print_fn, &[float_val.into()], "")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to call print_double: {:?}", e))
                        })?;
                } else if self.is_bool_type(&expr_ty) || self.expr_looks_like_bool(val_expr) {
                    // Boxed bool - unbox (ptr_to_int) and print as True/False
                    // Bools are boxed via int_to_ptr (the value is in the pointer bits)
                    let bool_val = self
                        .builder()
                        .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_bool")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to unbox bool: {:?}", e))
                        })?;

                    let print_fn = self.functions.get(&VarId::new(1000008)).ok_or_else(|| {
                        CodegenError::Internal("bhc_print_bool_ln not declared".to_string())
                    })?;

                    self.builder()
                        .build_call(*print_fn, &[bool_val.into()], "")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to call print_bool: {:?}", e))
                        })?;
                } else {
                    // Assume it's a string or other pointer type
                    let print_fn = self.functions.get(&VarId::new(1000002)).ok_or_else(|| {
                        CodegenError::Internal("bhc_print_string_ln not declared".to_string())
                    })?;

                    self.builder()
                        .build_call(*print_fn, &[p.into()], "")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to call print_string: {:?}", e))
                        })?;
                }
            }
            _ => {
                return Err(CodegenError::Unsupported(
                    "print: unsupported value type".to_string(),
                ));
            }
        }

        // Return unit
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Check if a type is an integer type.
    fn is_int_type(&self, ty: &Ty) -> bool {
        match ty {
            Ty::Con(con) => {
                let name = con.name.as_str();
                matches!(
                    name,
                    "Int" | "Int#" | "Int64" | "Int32" | "Integer" | "Word" | "Word64" | "Word32"
                )
            }
            Ty::Prim(prim) => {
                use bhc_types::PrimTy;
                matches!(prim, PrimTy::I32 | PrimTy::I64 | PrimTy::U32 | PrimTy::U64)
            }
            Ty::App(f, _) => self.is_int_type(f),
            Ty::Forall(_, body) => self.is_int_type(body),
            _ => false,
        }
    }

    /// Check if a type is a float type.
    fn is_float_type(&self, ty: &Ty) -> bool {
        match ty {
            Ty::Con(con) => {
                let name = con.name.as_str();
                matches!(name, "Float" | "Float#" | "Double" | "Double#")
            }
            Ty::Prim(prim) => {
                use bhc_types::PrimTy;
                matches!(prim, PrimTy::F32 | PrimTy::F64)
            }
            Ty::App(f, _) => self.is_float_type(f),
            Ty::Forall(_, body) => self.is_float_type(body),
            _ => false,
        }
    }

    /// Check if a type is a Bool type.
    fn is_bool_type(&self, ty: &Ty) -> bool {
        match ty {
            Ty::Con(con) => {
                let name = con.name.as_str();
                matches!(name, "Bool" | "Boolean")
            }
            Ty::App(f, _) => self.is_bool_type(f),
            Ty::Forall(_, body) => self.is_bool_type(body),
            _ => false,
        }
    }

    /// Check if a type is a type variable (polymorphic) or error type.
    /// We treat error types the same as type variables since we don't know
    /// the concrete type and should default to treating it as a potential integer.
    fn is_type_variable_or_error(&self, ty: &Ty) -> bool {
        match ty {
            Ty::Var(_) => true,
            Ty::Error => true, // Error type might be unresolved - treat as unknown
            Ty::App(f, _) => self.is_type_variable_or_error(f),
            Ty::Forall(_, body) => self.is_type_variable_or_error(body),
            _ => false,
        }
    }

    /// Check if a type is a list type.
    fn is_list_type(&self, ty: &Ty) -> bool {
        match ty {
            // Direct list type
            Ty::List(_) => true,
            // Type application form: [] a
            Ty::App(f, _) => {
                // Check if the type constructor is []
                if let Ty::Con(con) = f.as_ref() {
                    con.name.as_str() == "[]" || con.name.as_str() == "List"
                } else {
                    false
                }
            }
            // Just "[]" without argument (unlikely but handle it)
            Ty::Con(con) => con.name.as_str() == "[]" || con.name.as_str() == "List",
            Ty::Forall(_, body) => self.is_list_type(body),
            _ => false,
        }
    }

    /// Check if an expression looks like a list based on its structure.
    /// This is used when type information is unavailable (Error type).
    fn expr_looks_like_list(&self, expr: &Expr) -> bool {
        match expr {
            // Application of a constructor or function
            Expr::App(f, _, _) => self.expr_looks_like_list(f),
            // Type application
            Expr::TyApp(e, _, _) => self.expr_looks_like_list(e),
            // Let binding - check the body
            Expr::Let(_, body, _) => self.expr_looks_like_list(body),
            // Variable that's a list constructor or function returning a list
            Expr::Var(var, _) => {
                let name = var.name.as_str();
                // List constructors and functions that return lists
                matches!(
                    name,
                    ":" | "[]"
                        | "Nil"
                        | "Cons"
                        | "map"
                        | "filter"
                        | "reverse"
                        | "take"
                        | "drop"
                        | "enumFromTo"
                        | "replicate"
                        | "append"
                        | "tail"
                )
            }
            _ => false,
        }
    }

    /// Check if an expression looks like a boolean based on its structure.
    /// This is used when type information is unavailable (Error type).
    fn expr_looks_like_bool(&self, expr: &Expr) -> bool {
        match expr {
            // Application of comparison or boolean function
            Expr::App(f, _, _) => self.expr_looks_like_bool(f),
            // Type application
            Expr::TyApp(e, _, _) => self.expr_looks_like_bool(e),
            // Let binding - check the body
            Expr::Let(_, body, _) => self.expr_looks_like_bool(body),
            // Variable that's a comparison operator or boolean function
            Expr::Var(var, _) => {
                let name = var.name.as_str();
                // Comparison operators and boolean functions
                matches!(
                    name,
                    ">" | "<"
                        | ">="
                        | "<="
                        | "=="
                        | "/="
                        | "True"
                        | "False"
                        | "not"
                        | "&&"
                        | "||"
                        | "and"
                        | "or"
                        | "isJust"
                        | "isNothing"
                        | "isLeft"
                        | "isRight"
                        | "null"
                        | "elem"
                        | "notElem"
                        | "even"
                        | "odd"
                        | "greaterThan"
                        | "lessThan"
                        | "equals"
                )
            }
            _ => false,
        }
    }

    /// Print a list value: [el1, el2, ...]
    fn print_list(&mut self, list_ptr: inkwell::values::PointerValue<'ctx>) -> CodegenResult<()> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();

        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Get print functions
        let print_char_fn = self
            .functions
            .get(&VarId::new(1000009))
            .ok_or_else(|| CodegenError::Internal("bhc_print_char not declared".to_string()))?;
        let print_int_fn = self
            .functions
            .get(&VarId::new(1000003))
            .ok_or_else(|| CodegenError::Internal("bhc_print_int not declared".to_string()))?;

        // Print opening bracket (print_char takes i32)
        self.builder()
            .build_call(
                *print_char_fn,
                &[tm.i32_type().const_int('[' as u64, false).into()],
                "",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to print char: {:?}", e)))?;

        // Create loop blocks
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_header = self
            .llvm_ctx
            .append_basic_block(current_fn, "print_list_header");
        let loop_body = self
            .llvm_ctx
            .append_basic_block(current_fn, "print_list_body");
        let loop_exit = self
            .llvm_ctx
            .append_basic_block(current_fn, "print_list_exit");

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop header: phi for list and first flag
        self.builder().position_at_end(loop_header);
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "print_list_ptr")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let is_first_phi = self
            .builder()
            .build_phi(tm.i64_type(), "is_first")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

        // Check if list is empty
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare tag: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Loop body: print separator if not first, then print element
        self.builder().position_at_end(loop_body);

        // Check if we need to print ", "
        let need_separator = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                is_first_phi.as_basic_value().into_int_value(),
                tm.i64_type().const_zero(),
                "need_sep",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;

        let sep_block = self.llvm_ctx.append_basic_block(current_fn, "print_sep");
        let after_sep = self.llvm_ctx.append_basic_block(current_fn, "after_sep");

        self.builder()
            .build_conditional_branch(need_separator, sep_block, after_sep)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Print ", "
        self.builder().position_at_end(sep_block);
        self.builder()
            .build_call(
                *print_char_fn,
                &[tm.i32_type().const_int(',' as u64, false).into()],
                "",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to print char: {:?}", e)))?;
        self.builder()
            .build_call(
                *print_char_fn,
                &[tm.i32_type().const_int(' ' as u64, false).into()],
                "",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to print char: {:?}", e)))?;
        self.builder()
            .build_unconditional_branch(after_sep)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Continue printing element
        self.builder().position_at_end(after_sep);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Print head as int (for now assume list of ints)
        let head_int = self
            .builder()
            .build_ptr_to_int(head_ptr, tm.i64_type(), "head_int")
            .map_err(|e| CodegenError::Internal(format!("failed to ptr_to_int: {:?}", e)))?;
        self.builder()
            .build_call(*print_int_fn, &[head_int.into()], "")
            .map_err(|e| CodegenError::Internal(format!("failed to print int: {:?}", e)))?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;

        // Update phi nodes
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, after_sep)]);
        is_first_phi.add_incoming(&[
            (&tm.i64_type().const_int(1, false), entry_block),
            (&tm.i64_type().const_zero(), after_sep),
        ]);

        // Loop exit: print closing bracket and newline
        self.builder().position_at_end(loop_exit);
        self.builder()
            .build_call(
                *print_char_fn,
                &[tm.i32_type().const_int(']' as u64, false).into()],
                "",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to print char: {:?}", e)))?;
        self.builder()
            .build_call(
                *print_char_fn,
                &[tm.i32_type().const_int('\n' as u64, false).into()],
                "",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to print char: {:?}", e)))?;

        Ok(())
    }

    /// Lower `getLine` - read a line from stdin via RTS `bhc_getLine`.
    fn lower_builtin_get_line(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000071)).ok_or_else(|| {
            CodegenError::Internal("bhc_getLine not declared".to_string())
        })?;
        let result = self
            .builder()
            .build_call(*rts_fn, &[], "getline_result")
            .map_err(|e| {
                CodegenError::Internal(format!("getLine call failed: {:?}", e))
            })?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| {
                CodegenError::Internal("getLine: returned void".to_string())
            })?;
        Ok(Some(result))
    }

    /// Lower `>>=` (bind) for monads.
    /// For IO: execute first action, pass result to function, execute result.
    fn lower_builtin_bind(
        &mut self,
        action_expr: &Expr,
        func_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Execute the first action
        let action_result = self
            .lower_expr(action_expr)?
            .ok_or_else(|| CodegenError::Internal(">>=: action has no value".to_string()))?;

        // Lower the function
        let func_val = self
            .lower_expr(func_expr)?
            .ok_or_else(|| CodegenError::Internal(">>=: function has no value".to_string()))?;

        // Apply the function to the action's result
        let func_ptr = match func_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    ">>=: function must be a closure".to_string(),
                ))
            }
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();

        // Convert action result to pointer for uniform calling convention
        let action_ptr = self.value_to_ptr(action_result)?;

        // Call the function with the action result
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let result = self
            .builder()
            .build_indirect_call(
                fn_type,
                fn_ptr,
                &[func_ptr.into(), action_ptr.into()],
                "bind_result",
            )
            .map_err(|e| CodegenError::Internal(format!("failed to call bind function: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal(">>=: function returned void".to_string()))?;

        Ok(Some(result))
    }

    /// Lower `>>` (then) for monads.
    /// For IO: execute first action, ignore result, execute second action.
    fn lower_builtin_then(
        &mut self,
        action1_expr: &Expr,
        action2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Execute the first action (result is discarded)
        let _action1_result = self.lower_expr(action1_expr)?;

        // Execute the second action and return its result
        self.lower_expr(action2_expr)
    }

    /// Lower `return` / `pure` for monads.
    /// For IO: just return the value wrapped (identity for our simple model).
    fn lower_builtin_return(
        &mut self,
        value_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // For our simple IO model, return is identity
        self.lower_expr(value_expr)
    }

    // ========================================================================
    // Monad Transformer Helpers
    // ========================================================================

    /// Helper to build a closure that captures values from the current scope.
    /// `body_name` is a unique name for the closure function.
    /// `num_captures` is how many captured values there are.
    /// `build_body` receives (builder, env_ptr, arg) and should build the body + return.
    fn build_transformer_closure(
        &mut self,
        body_name: &str,
        captures: &[BasicValueEnum<'ctx>],
    ) -> CodegenResult<PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let num_captures = captures.len() as u32;

        // Create the closure function: (ptr env, ptr arg) -> ptr
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let func = self
            .module
            .llvm_module()
            .add_function(body_name, fn_type, None);

        // Allocate closure with captures
        let capture_pairs: Vec<(VarId, BasicValueEnum<'ctx>)> = captures
            .iter()
            .enumerate()
            .map(|(i, v)| (VarId::new(900000 + i), *v))
            .collect();

        let fn_ptr = func.as_global_value().as_pointer_value();
        let closure_ptr = self.alloc_closure(fn_ptr, &capture_pairs)?;
        Ok(closure_ptr)
    }

    /// Helper: emit a transformer closure body function that has already been added to the module.
    /// Returns the function value so the caller can build its body.
    fn get_or_create_transformer_fn(
        &mut self,
        name: &str,
    ) -> FunctionValue<'ctx> {
        let ptr_type = self.type_mapper().ptr_type();
        if let Some(existing) = self.module.llvm_module().get_function(name) {
            existing
        } else {
            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            self.module.llvm_module().add_function(name, fn_type, None)
        }
    }

    /// Helper: get or create a list append function for use in WriterT.
    /// The function has signature: (ptr, ptr) -> ptr (list1, list2) -> appended
    fn get_or_create_list_append_fn(&mut self) -> CodegenResult<FunctionValue<'ctx>> {
        let fn_name = "bhc_list_append";
        let ptr_type = self.type_mapper().ptr_type();

        if let Some(existing) = self.module.llvm_module().get_function(fn_name) {
            return Ok(existing);
        }

        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let func = self.module.llvm_module().add_function(fn_name, fn_type, None);

        // Build the function body - implements: append xs ys = foldr (:) ys xs
        // which reverses xs, then conses each element onto ys
        let entry = self.llvm_ctx.append_basic_block(func, "entry");
        let rev_header = self.llvm_ctx.append_basic_block(func, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(func, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(func, "rev_exit");
        let fold_header = self.llvm_ctx.append_basic_block(func, "fold_header");
        let fold_body = self.llvm_ctx.append_basic_block(func, "fold_body");
        let fold_exit = self.llvm_ctx.append_basic_block(func, "fold_exit");

        let saved_bb = self.builder().get_insert_block();
        self.builder().position_at_end(entry);

        let list1 = func.get_nth_param(0).unwrap().into_pointer_value();
        let list2 = func.get_nth_param(1).unwrap().into_pointer_value();
        let tm = self.type_mapper();

        // Start with empty accumulator for reverse
        let nil = self.build_nil()?;
        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("append branch: {:?}", e)))?;

        // Reverse loop header
        self.builder().position_at_end(rev_header);
        let rev_acc_phi = self.builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("append phi: {:?}", e)))?;
        let rev_list_phi = self.builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("append phi: {:?}", e)))?;

        rev_acc_phi.add_incoming(&[(&nil, entry)]);
        rev_list_phi.add_incoming(&[(&list1, entry)]);

        let rev_current = rev_list_phi.as_basic_value().into_pointer_value();
        let rev_tag = self.extract_adt_tag(rev_current)?;
        let rev_is_empty = self.builder()
            .build_int_compare(inkwell::IntPredicate::EQ, rev_tag, tm.i64_type().const_zero(), "rev_is_empty")
            .map_err(|e| CodegenError::Internal(format!("append cmp: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("append branch: {:?}", e)))?;

        // Reverse loop body
        self.builder().position_at_end(rev_body);
        let rev_head = self.extract_adt_field(rev_current, 2, 0)?;
        let rev_tail = self.extract_adt_field(rev_current, 2, 1)?;
        let rev_new_acc = self.build_cons(rev_head.into(), rev_acc_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("append branch: {:?}", e)))?;

        rev_acc_phi.add_incoming(&[(&rev_new_acc, rev_body)]);
        rev_list_phi.add_incoming(&[(&rev_tail, rev_body)]);

        // Reverse done, start fold
        self.builder().position_at_end(rev_exit);
        let reversed = rev_acc_phi.as_basic_value();
        self.builder()
            .build_unconditional_branch(fold_header)
            .map_err(|e| CodegenError::Internal(format!("append branch: {:?}", e)))?;

        // Fold loop header
        self.builder().position_at_end(fold_header);
        let fold_acc_phi = self.builder()
            .build_phi(ptr_type, "fold_acc")
            .map_err(|e| CodegenError::Internal(format!("append phi: {:?}", e)))?;
        let fold_list_phi = self.builder()
            .build_phi(ptr_type, "fold_list")
            .map_err(|e| CodegenError::Internal(format!("append phi: {:?}", e)))?;

        fold_acc_phi.add_incoming(&[(&list2, rev_exit)]);
        fold_list_phi.add_incoming(&[(&reversed, rev_exit)]);

        let fold_current = fold_list_phi.as_basic_value().into_pointer_value();
        let fold_tag = self.extract_adt_tag(fold_current)?;
        let fold_is_empty = self.builder()
            .build_int_compare(inkwell::IntPredicate::EQ, fold_tag, tm.i64_type().const_zero(), "fold_is_empty")
            .map_err(|e| CodegenError::Internal(format!("append cmp: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(fold_is_empty, fold_exit, fold_body)
            .map_err(|e| CodegenError::Internal(format!("append branch: {:?}", e)))?;

        // Fold loop body
        self.builder().position_at_end(fold_body);
        let fold_head = self.extract_adt_field(fold_current, 2, 0)?;
        let fold_tail = self.extract_adt_field(fold_current, 2, 1)?;
        let fold_new_acc = self.build_cons(fold_head.into(), fold_acc_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(fold_header)
            .map_err(|e| CodegenError::Internal(format!("append branch: {:?}", e)))?;

        fold_acc_phi.add_incoming(&[(&fold_new_acc, fold_body)]);
        fold_list_phi.add_incoming(&[(&fold_tail, fold_body)]);

        // Return result
        self.builder().position_at_end(fold_exit);
        self.builder().build_return(Some(&fold_acc_phi.as_basic_value()))
            .map_err(|e| CodegenError::Internal(format!("append return: {:?}", e)))?;

        if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        Ok(func)
    }

    // ========================================================================
    // ReaderT Operations
    // ========================================================================

    /// runReaderT m r = m(r)
    fn lower_builtin_run_reader_t(
        &mut self,
        m_expr: &Expr,
        r_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.push_monad_context(MonadContext::ReaderT);
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("runReaderT: m has no value".to_string()))?;
        self.pop_monad_context();
        let r_val = self.lower_expr(r_expr)?
            .ok_or_else(|| CodegenError::Internal("runReaderT: r has no value".to_string()))?;

        let m_ptr = m_val.into_pointer_value();
        let r_ptr = self.value_to_ptr(r_val)?;
        let fn_ptr = self.extract_closure_fn_ptr(m_ptr)?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let result = self.builder()
            .build_indirect_call(fn_type, fn_ptr, &[m_ptr.into(), r_ptr.into()], "run_reader_t")
            .map_err(|e| CodegenError::Internal(format!("runReaderT call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("runReaderT: void".to_string()))?;
        Ok(Some(result))
    }

    /// ask = closure \r -> r (returns env)
    fn lower_builtin_ask(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_ask";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, r) -> r
            let r = func.get_nth_param(1).unwrap();
            self.builder().build_return(Some(&r))
                .map_err(|e| CodegenError::Internal(format!("ask return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let closure_ptr = self.alloc_closure(fn_ptr, &[])?;
        Ok(Some(closure_ptr.into()))
    }

    /// asks f = closure \r -> f(r)
    fn lower_builtin_asks(
        &mut self,
        f_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("asks: f has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_asks";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, r) -> f(r) where f = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let r = func.get_nth_param(1).unwrap();
            let f = self.extract_closure_env_elem(env, 1, 0)?;
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let r_ptr = self.value_to_ptr(r)?;
            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let result = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), r_ptr.into()], "asks_result")
                .map_err(|e| CodegenError::Internal(format!("asks call: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("asks: void".to_string()))?;
            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("asks return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), f_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// local f m = closure \r -> m(f(r))
    fn lower_builtin_local(
        &mut self,
        f_expr: &Expr,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("local: f has no value".to_string()))?;
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("local: m has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_local";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, r) -> m(f(r)) where f = env[0], m = env[1]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let r = func.get_nth_param(1).unwrap();
            let f = self.extract_closure_env_elem(env, 2, 0)?;
            let m = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // r' = f(r)
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let r_ptr = self.value_to_ptr(r)?;
            let r_prime = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), r_ptr.into()], "local_r")
                .map_err(|e| CodegenError::Internal(format!("local f call: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("local f: void".to_string()))?;

            // result = m(r')
            let m_fn = self.extract_closure_fn_ptr(m)?;
            let result = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), r_prime.into()], "local_result")
                .map_err(|e| CodegenError::Internal(format!("local m call: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("local m: void".to_string()))?;

            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("local return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let m_ptr = self.value_to_ptr(m_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), f_ptr.into()),
            (VarId::new(900001), m_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ReaderT.pure x = closure \r -> x
    fn lower_builtin_reader_t_pure(
        &mut self,
        x_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let x_val = self.lower_expr(x_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.pure: x has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_pure";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _r) -> x where x = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let x = self.extract_closure_env_elem(env, 1, 0)?;
            self.builder().build_return(Some(&x))
                .map_err(|e| CodegenError::Internal(format!("reader_t_pure return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let x_ptr = self.value_to_ptr(x_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), x_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ReaderT.>>= m k = closure \r -> let a = m(r) in k(a)(r)
    fn lower_builtin_reader_t_bind(
        &mut self,
        m_expr: &Expr,
        k_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.>>=: m has no value".to_string()))?;
        let k_val = self.lower_expr(k_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.>>=: k has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_bind";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, r) -> let a = m(r); kr = k(a); kr(r)
            // where m = env[0], k = env[1]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let r = func.get_nth_param(1).unwrap();
            let m = self.extract_closure_env_elem(env, 2, 0)?;
            let k = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // a = m(r)
            let m_fn = self.extract_closure_fn_ptr(m)?;
            let a = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), r.into()], "bind_a")
                .map_err(|e| CodegenError::Internal(format!("ReaderT bind m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT bind m: void".to_string()))?;

            // kr = k(a)
            let k_fn = self.extract_closure_fn_ptr(k)?;
            let kr = self.builder()
                .build_indirect_call(fn_type, k_fn, &[k.into(), a.into()], "bind_kr")
                .map_err(|e| CodegenError::Internal(format!("ReaderT bind k: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT bind k: void".to_string()))?;

            // result = kr(r)
            let kr_ptr = kr.into_pointer_value();
            let kr_fn = self.extract_closure_fn_ptr(kr_ptr)?;
            let result = self.builder()
                .build_indirect_call(fn_type, kr_fn, &[kr_ptr.into(), r.into()], "bind_result")
                .map_err(|e| CodegenError::Internal(format!("ReaderT bind kr: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT bind kr: void".to_string()))?;

            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("reader_t_bind return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m_ptr = self.value_to_ptr(m_val)?;
        let k_ptr = self.value_to_ptr(k_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m_ptr.into()),
            (VarId::new(900001), k_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ReaderT.>> m1 m2 = closure \r -> m1(r); m2(r)
    fn lower_builtin_reader_t_then(
        &mut self,
        m1_expr: &Expr,
        m2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1_val = self.lower_expr(m1_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.>>: m1 has no value".to_string()))?;
        let m2_val = self.lower_expr(m2_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.>>: m2 has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_then";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, r) -> m1(r); m2(r) where m1 = env[0], m2 = env[1]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let r = func.get_nth_param(1).unwrap();
            let m1 = self.extract_closure_env_elem(env, 2, 0)?;
            let m2 = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // m1(r) - discard result
            let m1_fn = self.extract_closure_fn_ptr(m1)?;
            self.builder()
                .build_indirect_call(fn_type, m1_fn, &[m1.into(), r.into()], "then_m1")
                .map_err(|e| CodegenError::Internal(format!("ReaderT then m1: {:?}", e)))?;

            // result = m2(r)
            let m2_fn = self.extract_closure_fn_ptr(m2)?;
            let result = self.builder()
                .build_indirect_call(fn_type, m2_fn, &[m2.into(), r.into()], "then_result")
                .map_err(|e| CodegenError::Internal(format!("ReaderT then m2: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT then m2: void".to_string()))?;

            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("reader_t_then return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m1_ptr = self.value_to_ptr(m1_val)?;
        let m2_ptr = self.value_to_ptr(m2_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m1_ptr.into()),
            (VarId::new(900001), m2_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ReaderT.fmap f m = closure \r -> f(m(r))
    fn lower_builtin_reader_t_fmap(
        &mut self,
        f_expr: &Expr,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.fmap: f has no value".to_string()))?;
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.fmap: m has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_fmap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let r = func.get_nth_param(1).unwrap();
            let f = self.extract_closure_env_elem(env, 2, 0)?;
            let m = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // a = m(r)
            let m_fn = self.extract_closure_fn_ptr(m)?;
            let a = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), r.into()], "fmap_a")
                .map_err(|e| CodegenError::Internal(format!("ReaderT fmap m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT fmap m: void".to_string()))?;

            // result = f(a)
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let result = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "fmap_result")
                .map_err(|e| CodegenError::Internal(format!("ReaderT fmap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT fmap f: void".to_string()))?;

            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("reader_t_fmap return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let m_ptr = self.value_to_ptr(m_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), f_ptr.into()),
            (VarId::new(900001), m_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ReaderT.<*> mf mx = closure \r -> mf(r)(mx(r))
    fn lower_builtin_reader_t_ap(
        &mut self,
        mf_expr: &Expr,
        mx_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Same structure as fmap but applied differently
        // For simplicity, implement as: mf >>= \f -> fmap f mx
        // Which compiles to same closure pattern
        let mf_val = self.lower_expr(mf_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.<*>: mf has no value".to_string()))?;
        let mx_val = self.lower_expr(mx_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.<*>: mx has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_ap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let r = func.get_nth_param(1).unwrap();
            let mf = self.extract_closure_env_elem(env, 2, 0)?;
            let mx = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // f = mf(r)
            let mf_fn = self.extract_closure_fn_ptr(mf)?;
            let f = self.builder()
                .build_indirect_call(fn_type, mf_fn, &[mf.into(), r.into()], "ap_f")
                .map_err(|e| CodegenError::Internal(format!("ReaderT ap mf: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT ap mf: void".to_string()))?;

            // x = mx(r)
            let mx_fn = self.extract_closure_fn_ptr(mx)?;
            let x = self.builder()
                .build_indirect_call(fn_type, mx_fn, &[mx.into(), r.into()], "ap_x")
                .map_err(|e| CodegenError::Internal(format!("ReaderT ap mx: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT ap mx: void".to_string()))?;

            // result = f(x)
            let f_ptr = f.into_pointer_value();
            let f_fn = self.extract_closure_fn_ptr(f_ptr)?;
            let result = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f_ptr.into(), x.into()], "ap_result")
                .map_err(|e| CodegenError::Internal(format!("ReaderT ap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ReaderT ap f: void".to_string()))?;

            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("reader_t_ap return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let mf_ptr = self.value_to_ptr(mf_val)?;
        let mx_ptr = self.value_to_ptr(mx_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), mf_ptr.into()),
            (VarId::new(900001), mx_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ReaderT.lift action = closure \r -> action (ignore r, return action)
    fn lower_builtin_reader_t_lift(
        &mut self,
        action_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let action_val = self.lower_expr(action_expr)?
            .ok_or_else(|| CodegenError::Internal("ReaderT.lift: action has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_reader_t_lift";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _r) -> action where action = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let action = self.extract_closure_env_elem(env, 1, 0)?;
            self.builder().build_return(Some(&action))
                .map_err(|e| CodegenError::Internal(format!("reader_t_lift return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let action_ptr = self.value_to_ptr(action_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), action_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    // ========================================================================
    // StateT Operations
    // ========================================================================

    /// runStateT m s = m(s)
    fn lower_builtin_run_state_t(
        &mut self,
        m_expr: &Expr,
        s_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.push_monad_context(MonadContext::StateT);
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("runStateT: m has no value".to_string()))?;
        self.pop_monad_context();
        let s_val = self.lower_expr(s_expr)?
            .ok_or_else(|| CodegenError::Internal("runStateT: s has no value".to_string()))?;

        let m_ptr = m_val.into_pointer_value();
        let s_ptr = self.value_to_ptr(s_val)?;
        let fn_ptr = self.extract_closure_fn_ptr(m_ptr)?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let result = self.builder()
            .build_indirect_call(fn_type, fn_ptr, &[m_ptr.into(), s_ptr.into()], "run_state_t")
            .map_err(|e| CodegenError::Internal(format!("runStateT call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("runStateT: void".to_string()))?;
        Ok(Some(result))
    }

    /// Helper: allocate a pair (a, s) as a 2-element ADT (tag=0, field0=a, field1=s)
    fn alloc_pair(
        &mut self,
        fst_val: BasicValueEnum<'ctx>,
        snd_val: BasicValueEnum<'ctx>,
    ) -> CodegenResult<PointerValue<'ctx>> {
        let adt_ty = self.adt_type(2);
        let i64_type = self.type_mapper().i64_type();

        // Allocate: tag(i64) + 2 fields (ptr each) = 24 bytes
        let alloc_fn = *self.functions.get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;
        let size = i64_type.const_int(24, false);
        let raw = self.builder()
            .build_call(alloc_fn, &[size.into()], "pair_alloc")
            .map_err(|e| CodegenError::Internal(format!("pair alloc: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("pair alloc: void".to_string()))?
            .into_pointer_value();

        // Tag = 0 (tuple constructor)
        let tag_ptr = self.builder()
            .build_struct_gep(adt_ty, raw, 0, "pair_tag")
            .map_err(|e| CodegenError::Internal(format!("pair tag gep: {:?}", e)))?;
        self.builder().build_store(tag_ptr, i64_type.const_zero())
            .map_err(|e| CodegenError::Internal(format!("pair tag store: {:?}", e)))?;

        // Field 0 - use store_adt_field pattern
        self.store_adt_field(raw, 2, 0, fst_val)?;

        // Field 1
        self.store_adt_field(raw, 2, 1, snd_val)?;

        Ok(raw)
    }

    /// Helper: extract fst from pair (tag + 2 fields)
    fn extract_pair_fst(&self, pair: PointerValue<'ctx>) -> CodegenResult<PointerValue<'ctx>> {
        self.extract_adt_field(pair, 2, 0)
    }

    /// Helper: extract snd from pair (tag + 2 fields)
    fn extract_pair_snd(&self, pair: PointerValue<'ctx>) -> CodegenResult<PointerValue<'ctx>> {
        self.extract_adt_field(pair, 2, 1)
    }

    /// get = closure \s -> (s, s)
    fn lower_builtin_get(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_get";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(_env, s) -> (s, s)
            let s = func.get_nth_param(1).unwrap();
            let pair = self.alloc_pair(s, s)?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_get return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let closure_ptr = self.alloc_closure(fn_ptr, &[])?;
        Ok(Some(closure_ptr.into()))
    }

    /// put s' = closure \_ -> ((), s')
    fn lower_builtin_put(
        &mut self,
        s_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let s_val = self.lower_expr(s_expr)?
            .ok_or_else(|| CodegenError::Internal("put: s has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_put";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _s) -> ((), s') where s' = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s_new = self.extract_closure_env_elem(env, 1, 0)?;
            let unit = ptr_type.const_null();
            let pair = self.alloc_pair(unit.into(), s_new.into())?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_put return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let s_ptr = self.value_to_ptr(s_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), s_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// modify f = closure \s -> ((), f(s))
    fn lower_builtin_modify(
        &mut self,
        f_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("modify: f has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_modify";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, s) -> ((), f(s)) where f = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let f = self.extract_closure_env_elem(env, 1, 0)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let s_ptr = self.value_to_ptr(s)?;
            let s_new = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), s_ptr.into()], "modify_s")
                .map_err(|e| CodegenError::Internal(format!("modify f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("modify f: void".to_string()))?;

            let unit = ptr_type.const_null();
            let pair = self.alloc_pair(unit.into(), s_new)?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_modify return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), f_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// gets f = closure \s -> (f(s), s)
    fn lower_builtin_gets(
        &mut self,
        f_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("gets: f has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_gets";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let f = self.extract_closure_env_elem(env, 1, 0)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let s_ptr = self.value_to_ptr(s)?;
            let result = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), s_ptr.into()], "gets_result")
                .map_err(|e| CodegenError::Internal(format!("gets f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("gets f: void".to_string()))?;

            let pair = self.alloc_pair(result, s)?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_gets return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), f_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// StateT.pure x = closure \s -> (x, s)
    fn lower_builtin_state_t_pure(
        &mut self,
        x_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let x_val = self.lower_expr(x_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.pure: x has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_pure";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, s) -> (x, s) where x = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let x = self.extract_closure_env_elem(env, 1, 0)?;
            let pair = self.alloc_pair(x.into(), s)?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_pure return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let x_ptr = self.value_to_ptr(x_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), x_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// StateT.>>= m k = closure \s -> let (a, s') = m(s) in k(a)(s')
    fn lower_builtin_state_t_bind(
        &mut self,
        m_expr: &Expr,
        k_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.>>=: m has no value".to_string()))?;
        let k_val = self.lower_expr(k_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.>>=: k has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_bind";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let m = self.extract_closure_env_elem(env, 2, 0)?;
            let k = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // pair = m(s)
            let m_fn = self.extract_closure_fn_ptr(m)?;
            let pair = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), s.into()], "st_bind_pair")
                .map_err(|e| CodegenError::Internal(format!("StateT bind m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT bind m: void".to_string()))?
                .into_pointer_value();

            // a = fst(pair), s' = snd(pair)
            let a = self.extract_pair_fst(pair)?;
            let s_prime = self.extract_pair_snd(pair)?;

            // kr = k(a)
            let k_fn = self.extract_closure_fn_ptr(k)?;
            let kr = self.builder()
                .build_indirect_call(fn_type, k_fn, &[k.into(), a.into()], "st_bind_kr")
                .map_err(|e| CodegenError::Internal(format!("StateT bind k: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT bind k: void".to_string()))?;

            // result = kr(s')
            let kr_ptr = kr.into_pointer_value();
            let kr_fn = self.extract_closure_fn_ptr(kr_ptr)?;
            let result = self.builder()
                .build_indirect_call(fn_type, kr_fn, &[kr_ptr.into(), s_prime.into()], "st_bind_result")
                .map_err(|e| CodegenError::Internal(format!("StateT bind kr: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT bind kr: void".to_string()))?;

            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("state_t_bind return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m_ptr = self.value_to_ptr(m_val)?;
        let k_ptr = self.value_to_ptr(k_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m_ptr.into()),
            (VarId::new(900001), k_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// StateT.>> m1 m2 = closure \s -> let (_, s') = m1(s) in m2(s')
    fn lower_builtin_state_t_then(
        &mut self,
        m1_expr: &Expr,
        m2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1_val = self.lower_expr(m1_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.>>: m1 has no value".to_string()))?;
        let m2_val = self.lower_expr(m2_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.>>: m2 has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_then";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let m1 = self.extract_closure_env_elem(env, 2, 0)?;
            let m2 = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // pair = m1(s)
            let m1_fn = self.extract_closure_fn_ptr(m1)?;
            let pair = self.builder()
                .build_indirect_call(fn_type, m1_fn, &[m1.into(), s.into()], "st_then_pair")
                .map_err(|e| CodegenError::Internal(format!("StateT then m1: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT then m1: void".to_string()))?
                .into_pointer_value();

            // s' = snd(pair)
            let s_prime = self.extract_pair_snd(pair)?;

            // result = m2(s')
            let m2_fn = self.extract_closure_fn_ptr(m2)?;
            let result = self.builder()
                .build_indirect_call(fn_type, m2_fn, &[m2.into(), s_prime.into()], "st_then_result")
                .map_err(|e| CodegenError::Internal(format!("StateT then m2: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT then m2: void".to_string()))?;

            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("state_t_then return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m1_ptr = self.value_to_ptr(m1_val)?;
        let m2_ptr = self.value_to_ptr(m2_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m1_ptr.into()),
            (VarId::new(900001), m2_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// StateT.fmap f m = closure \s -> let (a, s') = m(s) in (f(a), s')
    fn lower_builtin_state_t_fmap(
        &mut self,
        f_expr: &Expr,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.fmap: f has no value".to_string()))?;
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.fmap: m has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_fmap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let f = self.extract_closure_env_elem(env, 2, 0)?;
            let m = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            let m_fn = self.extract_closure_fn_ptr(m)?;
            let pair = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), s.into()], "st_fmap_pair")
                .map_err(|e| CodegenError::Internal(format!("StateT fmap m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT fmap m: void".to_string()))?
                .into_pointer_value();

            let a = self.extract_pair_fst(pair)?;
            let s_prime = self.extract_pair_snd(pair)?;

            let f_fn = self.extract_closure_fn_ptr(f)?;
            let b = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "st_fmap_b")
                .map_err(|e| CodegenError::Internal(format!("StateT fmap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT fmap f: void".to_string()))?;

            let result_pair = self.alloc_pair(b, s_prime.into())?;
            self.builder().build_return(Some(&result_pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_fmap return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let m_ptr = self.value_to_ptr(m_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), f_ptr.into()),
            (VarId::new(900001), m_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// StateT.<*> = use bind and fmap composition
    fn lower_builtin_state_t_ap(
        &mut self,
        mf_expr: &Expr,
        mx_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // ap mf mx = mf >>= \f -> fmap f mx
        // For simplicity, implement directly like reader_t_ap but with state threading
        let mf_val = self.lower_expr(mf_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.<*>: mf has no value".to_string()))?;
        let mx_val = self.lower_expr(mx_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.<*>: mx has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_ap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let mf = self.extract_closure_env_elem(env, 2, 0)?;
            let mx = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

            // (f, s') = mf(s)
            let mf_fn = self.extract_closure_fn_ptr(mf)?;
            let pair1 = self.builder()
                .build_indirect_call(fn_type, mf_fn, &[mf.into(), s.into()], "st_ap_pair1")
                .map_err(|e| CodegenError::Internal(format!("StateT ap mf: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT ap mf: void".to_string()))?
                .into_pointer_value();
            let f = self.extract_pair_fst(pair1)?;
            let s_prime = self.extract_pair_snd(pair1)?;

            // (x, s'') = mx(s')
            let mx_fn = self.extract_closure_fn_ptr(mx)?;
            let pair2 = self.builder()
                .build_indirect_call(fn_type, mx_fn, &[mx.into(), s_prime.into()], "st_ap_pair2")
                .map_err(|e| CodegenError::Internal(format!("StateT ap mx: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT ap mx: void".to_string()))?
                .into_pointer_value();
            let x = self.extract_pair_fst(pair2)?;
            let s_double_prime = self.extract_pair_snd(pair2)?;

            // result = f(x)
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let b = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), x.into()], "st_ap_result")
                .map_err(|e| CodegenError::Internal(format!("StateT ap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("StateT ap f: void".to_string()))?;

            let result_pair = self.alloc_pair(b, s_double_prime.into())?;
            self.builder().build_return(Some(&result_pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_ap return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let mf_ptr = self.value_to_ptr(mf_val)?;
        let mx_ptr = self.value_to_ptr(mx_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), mf_ptr.into()),
            (VarId::new(900001), mx_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// StateT.lift action = closure \s -> (action, s)
    fn lower_builtin_state_t_lift(
        &mut self,
        action_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let action_val = self.lower_expr(action_expr)?
            .ok_or_else(|| CodegenError::Internal("StateT.lift: action has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_state_t_lift";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, s) -> (action, s) where action = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let s = func.get_nth_param(1).unwrap();
            let action = self.extract_closure_env_elem(env, 1, 0)?;
            let pair = self.alloc_pair(action.into(), s)?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("state_t_lift return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let action_ptr = self.value_to_ptr(action_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), action_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// evalStateT m s = fst(m(s))
    fn lower_builtin_eval_state_t(
        &mut self,
        m_expr: &Expr,
        s_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let result = self.lower_builtin_run_state_t(m_expr, s_expr)?;
        let pair = result
            .ok_or_else(|| CodegenError::Internal("evalStateT: no result".to_string()))?
            .into_pointer_value();
        let fst = self.extract_pair_fst(pair)?;
        Ok(Some(fst.into()))
    }

    /// execStateT m s = snd(m(s))
    fn lower_builtin_exec_state_t(
        &mut self,
        m_expr: &Expr,
        s_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let result = self.lower_builtin_run_state_t(m_expr, s_expr)?;
        let pair = result
            .ok_or_else(|| CodegenError::Internal("execStateT: no result".to_string()))?
            .into_pointer_value();
        let snd = self.extract_pair_snd(pair)?;
        Ok(Some(snd.into()))
    }

    // ========================================================================
    // ExceptT Transformer Operations
    // ========================================================================

    /// runExceptT m = m(_)  runs the computation, returns Either e a
    fn lower_builtin_run_except_t(
        &mut self,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.push_monad_context(MonadContext::ExceptT);
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("runExceptT: m has no value".to_string()))?;
        self.pop_monad_context();

        let m_ptr = match m_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("runExceptT: expected closure".to_string())),
        };

        let ptr_type = self.type_mapper().ptr_type();
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let m_fn = self.extract_closure_fn_ptr(m_ptr)?;
        let null_arg = ptr_type.const_null();
        let result = self.builder()
            .build_indirect_call(fn_type, m_fn, &[m_ptr.into(), null_arg.into()], "run_except_t")
            .map_err(|e| CodegenError::Internal(format!("runExceptT call: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("runExceptT: void".to_string()))?;
        Ok(Some(result))
    }

    /// ExceptT.pure x = closure \_ -> Right x
    fn lower_builtin_except_t_pure(
        &mut self,
        x_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let x_val = self.lower_expr(x_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.pure: x has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_pure";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _) -> Right(x) where x = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let x = self.extract_closure_env_elem(env, 1, 0)?;
            // Allocate Right ADT: tag=1, arity=1
            let right_adt = self.alloc_adt(1, 1)?;
            self.store_adt_field(right_adt, 1, 0, x.into())?;
            self.builder().build_return(Some(&right_adt))
                .map_err(|e| CodegenError::Internal(format!("except_t_pure return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let x_ptr = self.value_to_ptr(x_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), x_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// throwE e = closure \_ -> Left e
    fn lower_builtin_throw_e(
        &mut self,
        e_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let e_val = self.lower_expr(e_expr)?
            .ok_or_else(|| CodegenError::Internal("throwE: e has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_throw";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _) -> Left(e) where e = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let e = self.extract_closure_env_elem(env, 1, 0)?;
            // Allocate Left ADT: tag=0, arity=1
            let left_adt = self.alloc_adt(0, 1)?;
            self.store_adt_field(left_adt, 1, 0, e.into())?;
            self.builder().build_return(Some(&left_adt))
                .map_err(|e| CodegenError::Internal(format!("throw_e return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let e_ptr = self.value_to_ptr(e_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), e_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ExceptT.>>= m k = closure \_ -> let either = m(_) in case tag of
    ///   0 (Left) -> either (short-circuit)
    ///   1 (Right) -> let a = field0(either); kr = k(a) in kr(_)
    fn lower_builtin_except_t_bind(
        &mut self,
        m_expr: &Expr,
        k_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.>>=: m has no value".to_string()))?;
        let k_val = self.lower_expr(k_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.>>=: k has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_bind";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let right_bb = self.llvm_ctx.append_basic_block(func, "right");
            let left_bb = self.llvm_ctx.append_basic_block(func, "left");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let m = self.extract_closure_env_elem(env, 2, 0)?;
            let k = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            // either = m(_)
            let m_fn = self.extract_closure_fn_ptr(m)?;
            let either = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), null_arg.into()], "except_bind_either")
                .map_err(|e| CodegenError::Internal(format!("ExceptT bind m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT bind m: void".to_string()))?
                .into_pointer_value();

            // Check tag (0 = Left, 1 = Right)
            let tag = self.extract_adt_tag(either)?;
            let tm = self.type_mapper();
            let is_right = self.builder()
                .build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_int(1, false), "is_right")
                .map_err(|e| CodegenError::Internal(format!("ExceptT tag cmp: {:?}", e)))?;
            self.builder()
                .build_conditional_branch(is_right, right_bb, left_bb)
                .map_err(|e| CodegenError::Internal(format!("ExceptT branch: {:?}", e)))?;

            // Left case: short-circuit, return either
            self.builder().position_at_end(left_bb);
            self.builder().build_return(Some(&either))
                .map_err(|e| CodegenError::Internal(format!("except_t_bind left return: {:?}", e)))?;

            // Right case: extract a, call k(a), call result(_)
            self.builder().position_at_end(right_bb);
            let a = self.extract_adt_field(either, 1, 0)?;
            let k_fn = self.extract_closure_fn_ptr(k)?;
            let kr = self.builder()
                .build_indirect_call(fn_type, k_fn, &[k.into(), a.into()], "except_bind_kr")
                .map_err(|e| CodegenError::Internal(format!("ExceptT bind k: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT bind k: void".to_string()))?
                .into_pointer_value();
            let kr_fn = self.extract_closure_fn_ptr(kr)?;
            let result = self.builder()
                .build_indirect_call(fn_type, kr_fn, &[kr.into(), null_arg.into()], "except_bind_result")
                .map_err(|e| CodegenError::Internal(format!("ExceptT bind kr: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT bind kr: void".to_string()))?;
            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("except_t_bind right return: {:?}", e)))?;

            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m_ptr = self.value_to_ptr(m_val)?;
        let k_ptr = self.value_to_ptr(k_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m_ptr.into()),
            (VarId::new(900001), k_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ExceptT.>> m1 m2 = m1 >>= \_ -> m2
    fn lower_builtin_except_t_then(
        &mut self,
        m1_expr: &Expr,
        m2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1_val = self.lower_expr(m1_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.>>: m1 has no value".to_string()))?;
        let m2_val = self.lower_expr(m2_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.>>: m2 has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_then";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let right_bb = self.llvm_ctx.append_basic_block(func, "right");
            let left_bb = self.llvm_ctx.append_basic_block(func, "left");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let m1 = self.extract_closure_env_elem(env, 2, 0)?;
            let m2 = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            // either = m1(_)
            let m1_fn = self.extract_closure_fn_ptr(m1)?;
            let either = self.builder()
                .build_indirect_call(fn_type, m1_fn, &[m1.into(), null_arg.into()], "except_then_either")
                .map_err(|e| CodegenError::Internal(format!("ExceptT then m1: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT then m1: void".to_string()))?
                .into_pointer_value();

            let tag = self.extract_adt_tag(either)?;
            let tm = self.type_mapper();
            let is_right = self.builder()
                .build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_int(1, false), "is_right")
                .map_err(|e| CodegenError::Internal(format!("ExceptT then cmp: {:?}", e)))?;
            self.builder()
                .build_conditional_branch(is_right, right_bb, left_bb)
                .map_err(|e| CodegenError::Internal(format!("ExceptT then branch: {:?}", e)))?;

            // Left case: return either
            self.builder().position_at_end(left_bb);
            self.builder().build_return(Some(&either))
                .map_err(|e| CodegenError::Internal(format!("except_t_then left return: {:?}", e)))?;

            // Right case: call m2(_)
            self.builder().position_at_end(right_bb);
            let m2_fn = self.extract_closure_fn_ptr(m2)?;
            let result = self.builder()
                .build_indirect_call(fn_type, m2_fn, &[m2.into(), null_arg.into()], "except_then_result")
                .map_err(|e| CodegenError::Internal(format!("ExceptT then m2: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT then m2: void".to_string()))?;
            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("except_t_then right return: {:?}", e)))?;

            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m1_ptr = self.value_to_ptr(m1_val)?;
        let m2_ptr = self.value_to_ptr(m2_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m1_ptr.into()),
            (VarId::new(900001), m2_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// catchE m handler = closure \_ -> let either = m(_) in case tag of
    ///   0 (Left) -> let e = field0; h = handler(e) in h(_)
    ///   1 (Right) -> either
    fn lower_builtin_catch_e(
        &mut self,
        m_expr: &Expr,
        handler_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("catchE: m has no value".to_string()))?;
        let handler_val = self.lower_expr(handler_expr)?
            .ok_or_else(|| CodegenError::Internal("catchE: handler has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_catch";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let right_bb = self.llvm_ctx.append_basic_block(func, "right");
            let left_bb = self.llvm_ctx.append_basic_block(func, "left");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let m = self.extract_closure_env_elem(env, 2, 0)?;
            let handler = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            // either = m(_)
            let m_fn = self.extract_closure_fn_ptr(m)?;
            let either = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), null_arg.into()], "catch_either")
                .map_err(|e| CodegenError::Internal(format!("catchE m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("catchE m: void".to_string()))?
                .into_pointer_value();

            let tag = self.extract_adt_tag(either)?;
            let tm = self.type_mapper();
            let is_right = self.builder()
                .build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_int(1, false), "is_right")
                .map_err(|e| CodegenError::Internal(format!("catchE tag cmp: {:?}", e)))?;
            self.builder()
                .build_conditional_branch(is_right, right_bb, left_bb)
                .map_err(|e| CodegenError::Internal(format!("catchE branch: {:?}", e)))?;

            // Right case: pass through
            self.builder().position_at_end(right_bb);
            self.builder().build_return(Some(&either))
                .map_err(|e| CodegenError::Internal(format!("catch_e right return: {:?}", e)))?;

            // Left case: run handler
            self.builder().position_at_end(left_bb);
            let e = self.extract_adt_field(either, 1, 0)?;
            let handler_fn = self.extract_closure_fn_ptr(handler)?;
            let h = self.builder()
                .build_indirect_call(fn_type, handler_fn, &[handler.into(), e.into()], "catch_handler")
                .map_err(|e| CodegenError::Internal(format!("catchE handler: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("catchE handler: void".to_string()))?
                .into_pointer_value();
            let h_fn = self.extract_closure_fn_ptr(h)?;
            let result = self.builder()
                .build_indirect_call(fn_type, h_fn, &[h.into(), null_arg.into()], "catch_result")
                .map_err(|e| CodegenError::Internal(format!("catchE h: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("catchE h: void".to_string()))?;
            self.builder().build_return(Some(&result))
                .map_err(|e| CodegenError::Internal(format!("catch_e left return: {:?}", e)))?;

            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m_ptr = self.value_to_ptr(m_val)?;
        let handler_ptr = self.value_to_ptr(handler_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m_ptr.into()),
            (VarId::new(900001), handler_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ExceptT.lift io = closure \_ -> let a = io in Right(a)
    fn lower_builtin_except_t_lift(
        &mut self,
        io_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let io_val = self.lower_expr(io_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.lift: io has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_lift";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _) -> Right(io_result) where io = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let io = self.extract_closure_env_elem(env, 1, 0)?;
            // For now, IO actions are already executed, so just wrap the value
            // Allocate Right ADT: tag=1, arity=1
            let right_adt = self.alloc_adt(1, 1)?;
            self.store_adt_field(right_adt, 1, 0, io.into())?;
            self.builder().build_return(Some(&right_adt))
                .map_err(|e| CodegenError::Internal(format!("except_t_lift return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let io_ptr = self.value_to_ptr(io_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), io_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ExceptT.fmap f m = closure \_ -> let either = m(_) in case tag of
    ///   0 (Left) -> either
    ///   1 (Right) -> Right(f(field0))
    fn lower_builtin_except_t_fmap(
        &mut self,
        f_expr: &Expr,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.fmap: f has no value".to_string()))?;
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.fmap: m has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_fmap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let right_bb = self.llvm_ctx.append_basic_block(func, "right");
            let left_bb = self.llvm_ctx.append_basic_block(func, "left");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let f = self.extract_closure_env_elem(env, 2, 0)?;
            let m = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            let m_fn = self.extract_closure_fn_ptr(m)?;
            let either = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), null_arg.into()], "fmap_either")
                .map_err(|e| CodegenError::Internal(format!("ExceptT fmap m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT fmap m: void".to_string()))?
                .into_pointer_value();

            let tag = self.extract_adt_tag(either)?;
            let tm = self.type_mapper();
            let is_right = self.builder()
                .build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_int(1, false), "is_right")
                .map_err(|e| CodegenError::Internal(format!("ExceptT fmap cmp: {:?}", e)))?;
            self.builder()
                .build_conditional_branch(is_right, right_bb, left_bb)
                .map_err(|e| CodegenError::Internal(format!("ExceptT fmap branch: {:?}", e)))?;

            // Left case: pass through
            self.builder().position_at_end(left_bb);
            self.builder().build_return(Some(&either))
                .map_err(|e| CodegenError::Internal(format!("except_t_fmap left return: {:?}", e)))?;

            // Right case: apply f
            self.builder().position_at_end(right_bb);
            let a = self.extract_adt_field(either, 1, 0)?;
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let b = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "fmap_b")
                .map_err(|e| CodegenError::Internal(format!("ExceptT fmap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT fmap f: void".to_string()))?;
            let right_adt = self.alloc_adt(1, 1)?;
            self.store_adt_field(right_adt, 1, 0, b)?;
            self.builder().build_return(Some(&right_adt))
                .map_err(|e| CodegenError::Internal(format!("except_t_fmap right return: {:?}", e)))?;

            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let m_ptr = self.value_to_ptr(m_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), f_ptr.into()),
            (VarId::new(900001), m_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// ExceptT.<*> mf ma  applicative apply
    fn lower_builtin_except_t_ap(
        &mut self,
        mf_expr: &Expr,
        ma_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let mf_val = self.lower_expr(mf_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.<*>: mf has no value".to_string()))?;
        let ma_val = self.lower_expr(ma_expr)?
            .ok_or_else(|| CodegenError::Internal("ExceptT.<*>: ma has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_except_t_ap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let mf_right_bb = self.llvm_ctx.append_basic_block(func, "mf_right");
            let mf_left_bb = self.llvm_ctx.append_basic_block(func, "mf_left");
            let ma_right_bb = self.llvm_ctx.append_basic_block(func, "ma_right");
            let ma_left_bb = self.llvm_ctx.append_basic_block(func, "ma_left");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let mf = self.extract_closure_env_elem(env, 2, 0)?;
            let ma = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();
            let tm = self.type_mapper();

            // either_f = mf(_)
            let mf_fn = self.extract_closure_fn_ptr(mf)?;
            let either_f = self.builder()
                .build_indirect_call(fn_type, mf_fn, &[mf.into(), null_arg.into()], "ap_either_f")
                .map_err(|e| CodegenError::Internal(format!("ExceptT ap mf: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT ap mf: void".to_string()))?
                .into_pointer_value();

            let tag_f = self.extract_adt_tag(either_f)?;
            let is_right_f = self.builder()
                .build_int_compare(inkwell::IntPredicate::EQ, tag_f, tm.i64_type().const_int(1, false), "is_right_f")
                .map_err(|e| CodegenError::Internal(format!("ExceptT ap tag_f cmp: {:?}", e)))?;
            self.builder()
                .build_conditional_branch(is_right_f, mf_right_bb, mf_left_bb)
                .map_err(|e| CodegenError::Internal(format!("ExceptT ap branch_f: {:?}", e)))?;

            // mf Left: return either_f
            self.builder().position_at_end(mf_left_bb);
            self.builder().build_return(Some(&either_f))
                .map_err(|e| CodegenError::Internal(format!("except_t_ap mf_left return: {:?}", e)))?;

            // mf Right: run ma
            self.builder().position_at_end(mf_right_bb);
            let f = self.extract_adt_field(either_f, 1, 0)?;
            let ma_fn = self.extract_closure_fn_ptr(ma)?;
            let either_a = self.builder()
                .build_indirect_call(fn_type, ma_fn, &[ma.into(), null_arg.into()], "ap_either_a")
                .map_err(|e| CodegenError::Internal(format!("ExceptT ap ma: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT ap ma: void".to_string()))?
                .into_pointer_value();

            let tag_a = self.extract_adt_tag(either_a)?;
            let is_right_a = self.builder()
                .build_int_compare(inkwell::IntPredicate::EQ, tag_a, tm.i64_type().const_int(1, false), "is_right_a")
                .map_err(|e| CodegenError::Internal(format!("ExceptT ap tag_a cmp: {:?}", e)))?;
            self.builder()
                .build_conditional_branch(is_right_a, ma_right_bb, ma_left_bb)
                .map_err(|e| CodegenError::Internal(format!("ExceptT ap branch_a: {:?}", e)))?;

            // ma Left: return either_a
            self.builder().position_at_end(ma_left_bb);
            self.builder().build_return(Some(&either_a))
                .map_err(|e| CodegenError::Internal(format!("except_t_ap ma_left return: {:?}", e)))?;

            // Both Right: apply f to a
            self.builder().position_at_end(ma_right_bb);
            let a = self.extract_adt_field(either_a, 1, 0)?;
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let b = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "ap_b")
                .map_err(|e| CodegenError::Internal(format!("ExceptT ap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("ExceptT ap f: void".to_string()))?;
            let right_adt = self.alloc_adt(1, 1)?;
            self.store_adt_field(right_adt, 1, 0, b)?;
            self.builder().build_return(Some(&right_adt))
                .map_err(|e| CodegenError::Internal(format!("except_t_ap ma_right return: {:?}", e)))?;

            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let mf_ptr = self.value_to_ptr(mf_val)?;
        let ma_ptr = self.value_to_ptr(ma_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), mf_ptr.into()),
            (VarId::new(900001), ma_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    // ========================================================================
    // WriterT Transformer Operations
    // ========================================================================

    /// runWriterT m = m(_)  runs the computation, returns (a, w) pair
    fn lower_builtin_run_writer_t(
        &mut self,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.push_monad_context(MonadContext::WriterT);
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("runWriterT: m has no value".to_string()))?;
        self.pop_monad_context();

        let m_ptr = match m_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("runWriterT: expected closure".to_string())),
        };

        let ptr_type = self.type_mapper().ptr_type();
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let m_fn = self.extract_closure_fn_ptr(m_ptr)?;
        let null_arg = ptr_type.const_null();
        let result = self.builder()
            .build_indirect_call(fn_type, m_fn, &[m_ptr.into(), null_arg.into()], "run_writer_t")
            .map_err(|e| CodegenError::Internal(format!("runWriterT call: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("runWriterT: void".to_string()))?;
        Ok(Some(result))
    }

    /// execWriterT m = snd(m(_))  runs computation, returns just the output
    fn lower_builtin_exec_writer_t(
        &mut self,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let result = self.lower_builtin_run_writer_t(m_expr)?;
        let pair = result
            .ok_or_else(|| CodegenError::Internal("execWriterT: no result".to_string()))?
            .into_pointer_value();
        let snd = self.extract_pair_snd(pair)?;
        Ok(Some(snd.into()))
    }

    /// WriterT.pure x = closure \_ -> (x, "")
    fn lower_builtin_writer_t_pure(
        &mut self,
        x_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let x_val = self.lower_expr(x_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.pure: x has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_writer_t_pure";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _) -> (x, "") where x = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let x = self.extract_closure_env_elem(env, 1, 0)?;
            // Empty string = nil list
            let empty = self.build_nil()?;
            let pair = self.alloc_pair(x.into(), empty.into())?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("writer_t_pure return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let x_ptr = self.value_to_ptr(x_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), x_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// tell w = closure \_ -> ((), w)
    fn lower_builtin_tell(
        &mut self,
        w_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let w_val = self.lower_expr(w_expr)?
            .ok_or_else(|| CodegenError::Internal("tell: w has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_writer_t_tell";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _) -> ((), w) where w = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let w = self.extract_closure_env_elem(env, 1, 0)?;
            let unit = ptr_type.const_null();
            let pair = self.alloc_pair(unit.into(), w.into())?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("writer_t_tell return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let w_ptr = self.value_to_ptr(w_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), w_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// WriterT.>>= m k = closure \_ ->
    ///   let (a, w1) = m(_)
    ///   let (b, w2) = k(a)(_)
    ///   (b, w1 ++ w2)
    fn lower_builtin_writer_t_bind(
        &mut self,
        m_expr: &Expr,
        k_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.>>=: m has no value".to_string()))?;
        let k_val = self.lower_expr(k_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.>>=: k has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_writer_t_bind";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let m = self.extract_closure_env_elem(env, 2, 0)?;
            let k = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            // pair1 = m(_)
            let m_fn = self.extract_closure_fn_ptr(m)?;
            let pair1 = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), null_arg.into()], "wt_bind_pair1")
                .map_err(|e| CodegenError::Internal(format!("WriterT bind m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT bind m: void".to_string()))?
                .into_pointer_value();

            let a = self.extract_pair_fst(pair1)?;
            let w1 = self.extract_pair_snd(pair1)?;

            // kr = k(a)
            let k_fn = self.extract_closure_fn_ptr(k)?;
            let kr = self.builder()
                .build_indirect_call(fn_type, k_fn, &[k.into(), a.into()], "wt_bind_kr")
                .map_err(|e| CodegenError::Internal(format!("WriterT bind k: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT bind k: void".to_string()))?
                .into_pointer_value();

            // pair2 = kr(_)
            let kr_fn = self.extract_closure_fn_ptr(kr)?;
            let pair2 = self.builder()
                .build_indirect_call(fn_type, kr_fn, &[kr.into(), null_arg.into()], "wt_bind_pair2")
                .map_err(|e| CodegenError::Internal(format!("WriterT bind kr: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT bind kr: void".to_string()))?
                .into_pointer_value();

            let b = self.extract_pair_fst(pair2)?;
            let w2 = self.extract_pair_snd(pair2)?;

            // w_combined = append(w1, w2) via list append
            let append_fn = self.get_or_create_list_append_fn()?;
            let w_combined = self.builder()
                .build_call(append_fn, &[w1.into(), w2.into()], "wt_bind_append")
                .map_err(|e| CodegenError::Internal(format!("WriterT append: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT append: void".to_string()))?;

            let result_pair = self.alloc_pair(b.into(), w_combined)?;
            self.builder().build_return(Some(&result_pair))
                .map_err(|e| CodegenError::Internal(format!("writer_t_bind return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m_ptr = self.value_to_ptr(m_val)?;
        let k_ptr = self.value_to_ptr(k_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m_ptr.into()),
            (VarId::new(900001), k_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// WriterT.>> m1 m2 = m1 >>= \_ -> m2
    fn lower_builtin_writer_t_then(
        &mut self,
        m1_expr: &Expr,
        m2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1_val = self.lower_expr(m1_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.>>: m1 has no value".to_string()))?;
        let m2_val = self.lower_expr(m2_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.>>: m2 has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_writer_t_then";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let m1 = self.extract_closure_env_elem(env, 2, 0)?;
            let m2 = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            // pair1 = m1(_)
            let m1_fn = self.extract_closure_fn_ptr(m1)?;
            let pair1 = self.builder()
                .build_indirect_call(fn_type, m1_fn, &[m1.into(), null_arg.into()], "wt_then_pair1")
                .map_err(|e| CodegenError::Internal(format!("WriterT then m1: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT then m1: void".to_string()))?
                .into_pointer_value();

            let w1 = self.extract_pair_snd(pair1)?;

            // pair2 = m2(_)
            let m2_fn = self.extract_closure_fn_ptr(m2)?;
            let pair2 = self.builder()
                .build_indirect_call(fn_type, m2_fn, &[m2.into(), null_arg.into()], "wt_then_pair2")
                .map_err(|e| CodegenError::Internal(format!("WriterT then m2: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT then m2: void".to_string()))?
                .into_pointer_value();

            let b = self.extract_pair_fst(pair2)?;
            let w2 = self.extract_pair_snd(pair2)?;

            // w_combined = append(w1, w2) via list append
            let append_fn = self.get_or_create_list_append_fn()?;
            let w_combined = self.builder()
                .build_call(append_fn, &[w1.into(), w2.into()], "wt_then_append")
                .map_err(|e| CodegenError::Internal(format!("WriterT then append: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT then append: void".to_string()))?;

            let result_pair = self.alloc_pair(b.into(), w_combined)?;
            self.builder().build_return(Some(&result_pair))
                .map_err(|e| CodegenError::Internal(format!("writer_t_then return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let m1_ptr = self.value_to_ptr(m1_val)?;
        let m2_ptr = self.value_to_ptr(m2_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), m1_ptr.into()),
            (VarId::new(900001), m2_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// WriterT.lift io = closure \_ -> (io_result, "")
    fn lower_builtin_writer_t_lift(
        &mut self,
        io_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let io_val = self.lower_expr(io_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.lift: io has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_writer_t_lift";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            // \(env, _) -> (io_result, "") where io = env[0]
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let io_result = self.extract_closure_env_elem(env, 1, 0)?;
            let empty = self.build_nil()?;
            let pair = self.alloc_pair(io_result.into(), empty.into())?;
            self.builder().build_return(Some(&pair))
                .map_err(|e| CodegenError::Internal(format!("writer_t_lift return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let io_ptr = self.value_to_ptr(io_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), io_ptr.into())])?;
        Ok(Some(closure_ptr.into()))
    }

    /// WriterT.fmap f m = closure \_ -> let (a, w) = m(_) in (f(a), w)
    fn lower_builtin_writer_t_fmap(
        &mut self,
        f_expr: &Expr,
        m_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.fmap: f has no value".to_string()))?;
        let m_val = self.lower_expr(m_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.fmap: m has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_writer_t_fmap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let f = self.extract_closure_env_elem(env, 2, 0)?;
            let m = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            let m_fn = self.extract_closure_fn_ptr(m)?;
            let pair = self.builder()
                .build_indirect_call(fn_type, m_fn, &[m.into(), null_arg.into()], "wt_fmap_pair")
                .map_err(|e| CodegenError::Internal(format!("WriterT fmap m: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT fmap m: void".to_string()))?
                .into_pointer_value();

            let a = self.extract_pair_fst(pair)?;
            let w = self.extract_pair_snd(pair)?;

            let f_fn = self.extract_closure_fn_ptr(f)?;
            let b = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "wt_fmap_b")
                .map_err(|e| CodegenError::Internal(format!("WriterT fmap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT fmap f: void".to_string()))?;

            let result_pair = self.alloc_pair(b, w.into())?;
            self.builder().build_return(Some(&result_pair))
                .map_err(|e| CodegenError::Internal(format!("writer_t_fmap return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let f_ptr = self.value_to_ptr(f_val)?;
        let m_ptr = self.value_to_ptr(m_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), f_ptr.into()),
            (VarId::new(900001), m_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    /// WriterT.<*> mf ma  applicative apply
    fn lower_builtin_writer_t_ap(
        &mut self,
        mf_expr: &Expr,
        ma_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let mf_val = self.lower_expr(mf_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.<*>: mf has no value".to_string()))?;
        let ma_val = self.lower_expr(ma_expr)?
            .ok_or_else(|| CodegenError::Internal("WriterT.<*>: ma has no value".to_string()))?;

        let ptr_type = self.type_mapper().ptr_type();
        let fn_name = "bhc_writer_t_ap";

        let func = self.get_or_create_transformer_fn(fn_name);
        if func.count_basic_blocks() == 0 {
            let entry = self.llvm_ctx.append_basic_block(func, "entry");
            let saved_bb = self.builder().get_insert_block();
            self.builder().position_at_end(entry);
            let env = func.get_nth_param(0).unwrap().into_pointer_value();
            let mf = self.extract_closure_env_elem(env, 2, 0)?;
            let ma = self.extract_closure_env_elem(env, 2, 1)?;

            let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
            let null_arg = ptr_type.const_null();

            // (f, w1) = mf(_)
            let mf_fn = self.extract_closure_fn_ptr(mf)?;
            let pair1 = self.builder()
                .build_indirect_call(fn_type, mf_fn, &[mf.into(), null_arg.into()], "wt_ap_pair1")
                .map_err(|e| CodegenError::Internal(format!("WriterT ap mf: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT ap mf: void".to_string()))?
                .into_pointer_value();

            let f = self.extract_pair_fst(pair1)?;
            let w1 = self.extract_pair_snd(pair1)?;

            // (a, w2) = ma(_)
            let ma_fn = self.extract_closure_fn_ptr(ma)?;
            let pair2 = self.builder()
                .build_indirect_call(fn_type, ma_fn, &[ma.into(), null_arg.into()], "wt_ap_pair2")
                .map_err(|e| CodegenError::Internal(format!("WriterT ap ma: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT ap ma: void".to_string()))?
                .into_pointer_value();

            let a = self.extract_pair_fst(pair2)?;
            let w2 = self.extract_pair_snd(pair2)?;

            // b = f(a)
            let f_fn = self.extract_closure_fn_ptr(f)?;
            let b = self.builder()
                .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "wt_ap_b")
                .map_err(|e| CodegenError::Internal(format!("WriterT ap f: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT ap f: void".to_string()))?;

            // w_combined = append(w1, w2) via list append
            let append_fn = self.get_or_create_list_append_fn()?;
            let w_combined = self.builder()
                .build_call(append_fn, &[w1.into(), w2.into()], "wt_ap_append")
                .map_err(|e| CodegenError::Internal(format!("WriterT ap append: {:?}", e)))?
                .try_as_basic_value().basic()
                .ok_or_else(|| CodegenError::Internal("WriterT ap append: void".to_string()))?;

            let result_pair = self.alloc_pair(b, w_combined)?;
            self.builder().build_return(Some(&result_pair))
                .map_err(|e| CodegenError::Internal(format!("writer_t_ap return: {:?}", e)))?;
            if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
        }

        let fn_ptr = func.as_global_value().as_pointer_value();
        let mf_ptr = self.value_to_ptr(mf_val)?;
        let ma_ptr = self.value_to_ptr(ma_val)?;
        let closure_ptr = self.alloc_closure(fn_ptr, &[
            (VarId::new(900000), mf_ptr.into()),
            (VarId::new(900001), ma_ptr.into()),
        ])?;
        Ok(Some(closure_ptr.into()))
    }

    // ========================================================================
    // Phase 1: Numeric & Character Operation Handlers
    // ========================================================================

    /// Lower `negate` - negate a numeric value.
    fn lower_builtin_negate(
        &mut self,
        expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self
            .lower_expr(expr)?
            .ok_or_else(|| CodegenError::Internal("negate: no value".to_string()))?;
        let int_val = self.coerce_to_int(val)?;
        let zero = self.type_mapper().i64_type().const_zero();
        let result = self
            .builder()
            .build_int_sub(zero, int_val, "negate")
            .map_err(|e| CodegenError::Internal(format!("negate failed: {:?}", e)))?;
        Ok(Some(self.int_to_ptr(result)?.into()))
    }

    /// Lower `abs` - absolute value.
    fn lower_builtin_abs(
        &mut self,
        expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self
            .lower_expr(expr)?
            .ok_or_else(|| CodegenError::Internal("abs: no value".to_string()))?;
        let int_val = self.coerce_to_int(val)?;
        let zero = self.type_mapper().i64_type().const_zero();
        let is_neg = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::SLT, int_val, zero, "is_neg")
            .map_err(|e| CodegenError::Internal(format!("abs cmp failed: {:?}", e)))?;
        let neg_val = self
            .builder()
            .build_int_sub(zero, int_val, "neg")
            .map_err(|e| CodegenError::Internal(format!("abs neg failed: {:?}", e)))?;
        let result = self
            .builder()
            .build_select(is_neg, neg_val, int_val, "abs")
            .map_err(|e| CodegenError::Internal(format!("abs select failed: {:?}", e)))?
            .into_int_value();
        Ok(Some(self.int_to_ptr(result)?.into()))
    }

    /// Lower `signum` - sign of a value (-1, 0, or 1).
    fn lower_builtin_signum(
        &mut self,
        expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self
            .lower_expr(expr)?
            .ok_or_else(|| CodegenError::Internal("signum: no value".to_string()))?;
        let int_val = self.coerce_to_int(val)?;
        let tm = self.type_mapper();
        let zero = tm.i64_type().const_zero();
        let one = tm.i64_type().const_int(1, false);
        let neg_one = tm.i64_type().const_all_ones();
        let is_pos = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::SGT, int_val, zero, "is_pos")
            .map_err(|e| CodegenError::Internal(format!("signum failed: {:?}", e)))?;
        let is_neg = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::SLT, int_val, zero, "is_neg")
            .map_err(|e| CodegenError::Internal(format!("signum failed: {:?}", e)))?;
        let step1 = self
            .builder()
            .build_select(is_pos, one, zero, "signum_step1")
            .map_err(|e| CodegenError::Internal(format!("signum failed: {:?}", e)))?
            .into_int_value();
        let result = self
            .builder()
            .build_select(is_neg, neg_one, step1, "signum")
            .map_err(|e| CodegenError::Internal(format!("signum failed: {:?}", e)))?
            .into_int_value();
        Ok(Some(self.int_to_ptr(result)?.into()))
    }

    /// Lower a unary math function (sqrt, exp, log, sin, cos, etc.)
    fn lower_builtin_math_unary(
        &mut self,
        expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self
            .lower_expr(expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no value", name)))?;
        let f64_val = self.coerce_to_f64(val)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("RTS function {} not declared", name))
        })?;
        let result = self
            .builder()
            .build_call(*rts_fn, &[f64_val.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(self.f64_to_ptr(result.into_float_value())?.into()))
    }

    /// Lower a binary math function (atan2).
    fn lower_builtin_math_binary(
        &mut self,
        expr1: &Expr,
        expr2: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val1 = self.lower_expr(expr1)?.ok_or_else(|| CodegenError::Internal(format!("{}: no arg1", name)))?;
        let val2 = self.lower_expr(expr2)?.ok_or_else(|| CodegenError::Internal(format!("{}: no arg2", name)))?;
        let f1 = self.coerce_to_f64(val1)?;
        let f2 = self.coerce_to_f64(val2)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("RTS function {} not declared", name))
        })?;
        let result = self
            .builder()
            .build_call(*rts_fn, &[f1.into(), f2.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(self.f64_to_ptr(result.into_float_value())?.into()))
    }

    /// Lower float-to-int conversion (ceiling, floor, round, truncate).
    fn lower_builtin_float_to_int(
        &mut self,
        expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?.ok_or_else(|| CodegenError::Internal(format!("{}: no value", name)))?;
        let f64_val = self.coerce_to_f64(val)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("RTS function {} not declared", name))
        })?;
        let result = self
            .builder()
            .build_call(*rts_fn, &[f64_val.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `ord` - character to integer (identity in our representation).
    fn lower_builtin_ord(&mut self, expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(expr)
    }

    /// Lower `chr` - integer to character (identity in our representation).
    fn lower_builtin_chr(&mut self, expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(expr)
    }

    /// Lower a character predicate (isAlpha, isDigit, isSpace, etc.)
    fn lower_builtin_char_pred(
        &mut self,
        expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?.ok_or_else(|| CodegenError::Internal(format!("{}: no value", name)))?;
        let int_val = self.coerce_to_int(val)?;
        let i32_type = self.type_mapper().i32_type();
        let char_val = self.builder()
            .build_int_truncate(int_val, i32_type, "char_val")
            .map_err(|e| CodegenError::Internal(format!("{}: truncate failed: {:?}", name, e)))?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("char pred {} not declared", name))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[char_val.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        let bool_val = result.into_int_value();
        let extended = self.builder()
            .build_int_z_extend(bool_val, self.type_mapper().i64_type(), "bool_ext")
            .map_err(|e| CodegenError::Internal(format!("{}: extend failed: {:?}", name, e)))?;
        Ok(Some(self.int_to_ptr(extended)?.into()))
    }

    /// Lower a character conversion (toLower, toUpper).
    fn lower_builtin_char_conv(
        &mut self,
        expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?.ok_or_else(|| CodegenError::Internal(format!("{}: no value", name)))?;
        let int_val = self.coerce_to_int(val)?;
        let i32_type = self.type_mapper().i32_type();
        let char_val = self.builder()
            .build_int_truncate(int_val, i32_type, "char_val")
            .map_err(|e| CodegenError::Internal(format!("{}: truncate failed: {:?}", name, e)))?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("char conv {} not declared", name))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[char_val.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        let u32_val = result.into_int_value();
        let extended = self.builder()
            .build_int_z_extend(u32_val, self.type_mapper().i64_type(), "char_ext")
            .map_err(|e| CodegenError::Internal(format!("{}: extend failed: {:?}", name, e)))?;
        Ok(Some(self.int_to_ptr(extended)?.into()))
    }

    /// Lower `digitToInt` - convert digit char to integer.
    fn lower_builtin_digit_to_int(&mut self, expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?.ok_or_else(|| CodegenError::Internal("digitToInt: no value".to_string()))?;
        let int_val = self.coerce_to_int(val)?;
        let i32_type = self.type_mapper().i32_type();
        let char_val = self.builder().build_int_truncate(int_val, i32_type, "char_val")
            .map_err(|e| CodegenError::Internal(format!("digitToInt: truncate failed: {:?}", e)))?;
        let rts_fn = self.functions.get(&VarId::new(1000046)).ok_or_else(|| CodegenError::Internal("bhc_char_digit_to_int not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[char_val.into()], "digit_to_int")
            .map_err(|e| CodegenError::Internal(format!("digitToInt call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("digitToInt: returned void".to_string()))?;
        let i32_val = result.into_int_value();
        let extended = self.builder().build_int_s_extend(i32_val, self.type_mapper().i64_type(), "digit_ext")
            .map_err(|e| CodegenError::Internal(format!("digitToInt: extend failed: {:?}", e)))?;
        Ok(Some(self.int_to_ptr(extended)?.into()))
    }

    /// Lower `intToDigit` - convert integer to digit char.
    fn lower_builtin_int_to_digit(&mut self, expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?.ok_or_else(|| CodegenError::Internal("intToDigit: no value".to_string()))?;
        let int_val = self.coerce_to_int(val)?;
        let i32_type = self.type_mapper().i32_type();
        let truncated = self.builder().build_int_truncate(int_val, i32_type, "int_val")
            .map_err(|e| CodegenError::Internal(format!("intToDigit: truncate failed: {:?}", e)))?;
        let rts_fn = self.functions.get(&VarId::new(1000047)).ok_or_else(|| CodegenError::Internal("bhc_char_int_to_digit not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[truncated.into()], "int_to_digit")
            .map_err(|e| CodegenError::Internal(format!("intToDigit call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("intToDigit: returned void".to_string()))?;
        let u32_val = result.into_int_value();
        let extended = self.builder().build_int_z_extend(u32_val, self.type_mapper().i64_type(), "digit_char_ext")
            .map_err(|e| CodegenError::Internal(format!("intToDigit: extend failed: {:?}", e)))?;
        Ok(Some(self.int_to_ptr(extended)?.into()))
    }

    // ========================================================================
    // Phase 4: IO & System Operation Handlers
    // ========================================================================

    /// Lower `readFile` - read file contents.
    fn lower_builtin_read_file(&mut self, path_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal("readFile: no path".to_string()))?;
        // Convert [Char] path to C-string for RTS
        let path_ptr = self.value_to_ptr(path_val)?;
        let path_cstr = self.char_list_to_cstring(path_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000050)).ok_or_else(|| CodegenError::Internal("bhc_readFile not declared".to_string()))?;
        let cstr_result = self.builder().build_call(*rts_fn, &[path_cstr.into()], "read_file")
            .map_err(|e| CodegenError::Internal(format!("readFile call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("readFile: returned void".to_string()))?;

        // Check for exception sentinel (null return from bhc_throw).
        // If null, return null immediately from current function so bhc_catch
        // can detect the exception via TLS instead of continuing execution.
        let result_ptr = cstr_result.into_pointer_value();
        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("readFile: no current function".to_string()))?;
        let early_ret_block = self.llvm_context().append_basic_block(current_fn, "readfile_exc");
        let ok_block = self.llvm_context().append_basic_block(current_fn, "readfile_ok");

        let is_null = self.builder().build_is_null(result_ptr, "readfile_null")
            .map_err(|e| CodegenError::Internal(format!("readFile null check: {:?}", e)))?;
        self.builder().build_conditional_branch(is_null, early_ret_block, ok_block)
            .map_err(|e| CodegenError::Internal(format!("readFile branch: {:?}", e)))?;

        // Exception path: return null sentinel to propagate to bhc_catch
        self.builder().position_at_end(early_ret_block);
        self.builder().build_return(Some(&tm.ptr_type().const_null()))
            .map_err(|e| CodegenError::Internal(format!("readFile exc return: {:?}", e)))?;

        // OK path: convert C-string result to [Char] linked list
        self.builder().position_at_end(ok_block);
        let char_list = self.cstring_to_char_list(result_ptr)?;
        Ok(Some(char_list.into()))
    }

    /// Lower `writeFile` - write string to file.
    fn lower_builtin_write_file(&mut self, path_expr: &Expr, content_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal("writeFile: no path".to_string()))?;
        let content_val = self.lower_expr(content_expr)?.ok_or_else(|| CodegenError::Internal("writeFile: no content".to_string()))?;
        // Convert [Char] args to C-strings for RTS
        let path_ptr = self.value_to_ptr(path_val)?;
        let path_cstr = self.char_list_to_cstring(path_ptr)?;
        let content_ptr = self.value_to_ptr(content_val)?;
        let content_cstr = self.char_list_to_cstring(content_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000051)).ok_or_else(|| CodegenError::Internal("bhc_writeFile not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[path_cstr.into(), content_cstr.into()], "")
            .map_err(|e| CodegenError::Internal(format!("writeFile call failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `appendFile` - append string to file.
    fn lower_builtin_append_file(&mut self, path_expr: &Expr, content_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal("appendFile: no path".to_string()))?;
        let content_val = self.lower_expr(content_expr)?.ok_or_else(|| CodegenError::Internal("appendFile: no content".to_string()))?;
        // Convert [Char] args to C-strings for RTS
        let path_ptr = self.value_to_ptr(path_val)?;
        let path_cstr = self.char_list_to_cstring(path_ptr)?;
        let content_ptr = self.value_to_ptr(content_val)?;
        let content_cstr = self.char_list_to_cstring(content_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000052)).ok_or_else(|| CodegenError::Internal("bhc_appendFile not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[path_cstr.into(), content_cstr.into()], "")
            .map_err(|e| CodegenError::Internal(format!("appendFile call failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `openFile` - open a file handle.
    fn lower_builtin_open_file(&mut self, path_expr: &Expr, mode_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal("openFile: no path".to_string()))?;
        let mode_val = self.lower_expr(mode_expr)?.ok_or_else(|| CodegenError::Internal("openFile: no mode".to_string()))?;
        // Convert [Char] path to C-string for RTS
        let path_ptr = self.value_to_ptr(path_val)?;
        let path_cstr = self.char_list_to_cstring(path_ptr)?;
        // mode_val is an IOMode ADT pointer  load the tag (first i64) to get the mode integer
        let mode_int = match mode_val {
            BasicValueEnum::PointerValue(p) => {
                self.builder().build_load(self.type_mapper().i64_type(), p, "mode_tag")
                    .map_err(|e| CodegenError::Internal(format!("openFile: load mode tag failed: {:?}", e)))?
                    .into_int_value()
            }
            BasicValueEnum::IntValue(i) => i,
            _ => return Err(CodegenError::TypeError("openFile: unexpected mode type".to_string())),
        };
        let mode_i32 = self.builder().build_int_truncate(mode_int, self.type_mapper().i32_type(), "mode")
            .map_err(|e| CodegenError::Internal(format!("openFile: truncate failed: {:?}", e)))?;
        let rts_fn = self.functions.get(&VarId::new(1000053)).ok_or_else(|| CodegenError::Internal("bhc_open_file not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[path_cstr.into(), mode_i32.into()], "handle")
            .map_err(|e| CodegenError::Internal(format!("openFile call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("openFile: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `hClose` - close a file handle.
    fn lower_builtin_hclose(&mut self, handle_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hClose: no handle".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hClose expects handle".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000054)).ok_or_else(|| CodegenError::Internal("bhc_close_handle not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[handle_ptr.into()], "").map_err(|e| CodegenError::Internal(format!("hClose call failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `hGetChar` - read a character from handle.
    fn lower_builtin_hgetchar(&mut self, handle_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hGetChar: no handle".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hGetChar expects handle".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000055)).ok_or_else(|| CodegenError::Internal("bhc_hGetChar not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[handle_ptr.into()], "hgetchar")
            .map_err(|e| CodegenError::Internal(format!("hGetChar call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("hGetChar: returned void".to_string()))?;
        let char_val = result.into_int_value();
        let extended = self.builder().build_int_z_extend(char_val, self.type_mapper().i64_type(), "char_ext")
            .map_err(|e| CodegenError::Internal(format!("hGetChar: extend failed: {:?}", e)))?;
        Ok(Some(self.int_to_ptr(extended)?.into()))
    }

    /// Lower `hGetLine` - read a line from handle.
    fn lower_builtin_hgetline(&mut self, handle_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hGetLine: no handle".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hGetLine expects handle".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000056)).ok_or_else(|| CodegenError::Internal("bhc_hGetLine not declared".to_string()))?;
        let cstr_result = self.builder().build_call(*rts_fn, &[handle_ptr.into()], "hgetline")
            .map_err(|e| CodegenError::Internal(format!("hGetLine call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("hGetLine: returned void".to_string()))?;
        // Convert C-string result to [Char] linked list
        let char_list = self.cstring_to_char_list(cstr_result.into_pointer_value())?;
        Ok(Some(char_list.into()))
    }

    /// Lower `hPutStr` - write string to handle.
    fn lower_builtin_hputstr(&mut self, handle_expr: &Expr, str_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hPutStr: no handle".to_string()))?;
        let str_val = self.lower_expr(str_expr)?.ok_or_else(|| CodegenError::Internal("hPutStr: no string".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hPutStr expects handle".to_string())) };
        // Convert [Char] string to C-string for RTS
        let str_ptr = self.value_to_ptr(str_val)?;
        let str_cstr = self.char_list_to_cstring(str_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000057)).ok_or_else(|| CodegenError::Internal("bhc_hPutStr not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[handle_ptr.into(), str_cstr.into()], "").map_err(|e| CodegenError::Internal(format!("hPutStr call failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `hPutStrLn` - write string + newline to handle.
    fn lower_builtin_hputstrln(&mut self, handle_expr: &Expr, str_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hPutStrLn: no handle".to_string()))?;
        let str_val = self.lower_expr(str_expr)?.ok_or_else(|| CodegenError::Internal("hPutStrLn: no string".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hPutStrLn expects handle".to_string())) };
        // Convert [Char] string to C-string for RTS
        let str_ptr = self.value_to_ptr(str_val)?;
        let str_cstr = self.char_list_to_cstring(str_ptr)?;
        let put_fn = self.functions.get(&VarId::new(1000057)).ok_or_else(|| CodegenError::Internal("bhc_hPutStr not declared".to_string()))?;
        self.builder().build_call(*put_fn, &[handle_ptr.into(), str_cstr.into()], "").map_err(|e| CodegenError::Internal(format!("hPutStrLn put failed: {:?}", e)))?;
        let nl = self.module.add_global_string("hputstrln_nl", "\n");
        self.builder().build_call(*put_fn, &[handle_ptr.into(), nl.into()], "").map_err(|e| CodegenError::Internal(format!("hPutStrLn nl failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `hFlush`.
    fn lower_builtin_hflush(&mut self, handle_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hFlush: no handle".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hFlush expects handle".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000058)).ok_or_else(|| CodegenError::Internal("bhc_hFlush not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[handle_ptr.into()], "").map_err(|e| CodegenError::Internal(format!("hFlush call failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `hIsEOF`.
    fn lower_builtin_hiseof(&mut self, handle_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hIsEOF: no handle".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hIsEOF expects handle".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000059)).ok_or_else(|| CodegenError::Internal("bhc_hIsEOF not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[handle_ptr.into()], "is_eof")
            .map_err(|e| CodegenError::Internal(format!("hIsEOF call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("hIsEOF: returned void".to_string()))?;
        let bool_val = result.into_int_value();
        let extended = self.builder().build_int_z_extend(bool_val, self.type_mapper().i64_type(), "eof_ext")
            .map_err(|e| CodegenError::Internal(format!("hIsEOF: extend failed: {:?}", e)))?;
        Ok(Some(self.int_to_ptr(extended)?.into()))
    }

    /// Lower `hSetBuffering` (stub).
    fn lower_builtin_hset_buffering(&mut self, handle_expr: &Expr, mode_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(handle_expr)?;
        let _ = self.lower_expr(mode_expr)?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower stdin/stdout/stderr.
    fn lower_builtin_std_handle(&mut self, rts_id: usize, name: &str) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| CodegenError::Internal(format!("bhc_{} not declared", name)))?;
        let result = self.builder().build_call(*rts_fn, &[], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(result))
    }

    /// Lower file predicate (doesFileExist, doesDirectoryExist).
    fn lower_builtin_file_pred(&mut self, path_expr: &Expr, rts_id: usize, name: &str) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal(format!("{}: no path", name)))?;
        // Convert [Char] path to C-string for RTS
        let path_ptr = self.value_to_ptr(path_val)?;
        let path_cstr = self.char_list_to_cstring(path_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| CodegenError::Internal(format!("{} not declared", name)))?;
        let result = self.builder().build_call(*rts_fn, &[path_cstr.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        let bool_i32 = result.into_int_value();
        // Convert i32 result (0/1) to a proper Bool ADT constructor
        // True = tag 1, False = tag 0
        let i64_type = self.type_mapper().i64_type();
        let extended = self.builder().build_int_z_extend(bool_i32, i64_type, "pred_ext")
            .map_err(|e| CodegenError::Internal(format!("{}: extend failed: {:?}", name, e)))?;

        // Allocate a Bool ADT: 8-byte tag followed by no fields
        let ptr_type = self.type_mapper().ptr_type();
        let alloc_fn = self.functions.get(&VarId::new(1000005)).ok_or_else(|| {
            CodegenError::Internal("bhc_alloc not declared".to_string())
        })?;
        let size = i64_type.const_int(8, false); // Just the tag
        let adt_ptr = self.builder()
            .build_call(*alloc_fn, &[size.into()], "bool_adt")
            .map_err(|e| CodegenError::Internal(format!("{}: alloc failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: alloc returned void", name)))?
            .into_pointer_value();
        // Store the tag
        self.builder().build_store(adt_ptr, extended)
            .map_err(|e| CodegenError::Internal(format!("{}: store tag failed: {:?}", name, e)))?;
        Ok(Some(adt_ptr.into()))
    }

    /// Lower `removeFile`.
    fn lower_builtin_remove_file(&mut self, path_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal("removeFile: no path".to_string()))?;
        let path_ptr = match path_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("removeFile expects string".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000312)).ok_or_else(|| CodegenError::Internal("bhc_remove_file not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[path_ptr.into()], "")
            .map_err(|e| CodegenError::Internal(format!("removeFile call failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `getArgs`: returns list of command-line arguments.
    fn lower_builtin_get_args(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000315)).ok_or_else(|| CodegenError::Internal("bhc_get_args not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[], "get_args")
            .map_err(|e| CodegenError::Internal(format!("getArgs call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("getArgs: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `getProgName`: returns program name.
    fn lower_builtin_get_prog_name(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000316)).ok_or_else(|| CodegenError::Internal("bhc_get_prog_name not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[], "get_prog_name")
            .map_err(|e| CodegenError::Internal(format!("getProgName call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("getProgName: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `getEnv`.
    fn lower_builtin_get_env(&mut self, name_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let name_val = self.lower_expr(name_expr)?.ok_or_else(|| CodegenError::Internal("getEnv: no name".to_string()))?;
        let name_ptr = match name_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("getEnv expects string".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000068)).ok_or_else(|| CodegenError::Internal("bhc_get_env not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[name_ptr.into()], "get_env")
            .map_err(|e| CodegenError::Internal(format!("getEnv call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("getEnv: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `lookupEnv` (simplified: wraps getEnv).
    fn lower_builtin_lookup_env(&mut self, name_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_get_env(name_expr)
    }

    /// Lower `exitSuccess`.
    fn lower_builtin_exit_success(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000066)).ok_or_else(|| CodegenError::Internal("bhc_exit_success not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[], "").map_err(|e| CodegenError::Internal(format!("exitSuccess failed: {:?}", e)))?;
        self.builder().build_unreachable().map_err(|e| CodegenError::Internal(format!("unreachable failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `exitFailure`.
    fn lower_builtin_exit_failure(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000067)).ok_or_else(|| CodegenError::Internal("bhc_exit_failure not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[], "").map_err(|e| CodegenError::Internal(format!("exitFailure failed: {:?}", e)))?;
        self.builder().build_unreachable().map_err(|e| CodegenError::Internal(format!("unreachable failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `exitWith`.
    fn lower_builtin_exit_with(&mut self, code_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let code_val = self.lower_expr(code_expr)?.ok_or_else(|| CodegenError::Internal("exitWith: no code".to_string()))?;
        let int_val = self.coerce_to_int(code_val)?;
        let code_i32 = self.builder().build_int_truncate(int_val, self.type_mapper().i32_type(), "exit_code")
            .map_err(|e| CodegenError::Internal(format!("exitWith: truncate failed: {:?}", e)))?;
        let rts_fn = self.functions.get(&VarId::new(1000065)).ok_or_else(|| CodegenError::Internal("bhc_exit not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[code_i32.into()], "").map_err(|e| CodegenError::Internal(format!("exitWith failed: {:?}", e)))?;
        self.builder().build_unreachable().map_err(|e| CodegenError::Internal(format!("unreachable failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `hGetContents`: read all remaining contents from a handle.
    fn lower_builtin_hgetcontents(&mut self, handle_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let handle_val = self.lower_expr(handle_expr)?.ok_or_else(|| CodegenError::Internal("hGetContents: no handle".to_string()))?;
        let handle_ptr = match handle_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("hGetContents expects handle".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000300)).ok_or_else(|| CodegenError::Internal("bhc_hGetContents not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[handle_ptr.into()], "hgetcontents")
            .map_err(|e| CodegenError::Internal(format!("hGetContents call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("hGetContents: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `getCurrentDirectory`.
    fn lower_builtin_get_current_directory(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000317)).ok_or_else(|| CodegenError::Internal("bhc_get_current_directory not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[], "getcwd")
            .map_err(|e| CodegenError::Internal(format!("getCurrentDirectory call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("getCurrentDirectory: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `createDirectory`.
    fn lower_builtin_create_directory(&mut self, path_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal("createDirectory: no path".to_string()))?;
        let path_ptr = match path_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("createDirectory expects string".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000311)).ok_or_else(|| CodegenError::Internal("bhc_create_directory not declared".to_string()))?;
        self.builder().build_call(*rts_fn, &[path_ptr.into()], "")
            .map_err(|e| CodegenError::Internal(format!("createDirectory call failed: {:?}", e)))?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `listDirectory`.
    fn lower_builtin_list_directory(&mut self, path_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let path_val = self.lower_expr(path_expr)?.ok_or_else(|| CodegenError::Internal("listDirectory: no path".to_string()))?;
        let path_ptr = match path_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("listDirectory expects string".to_string())) };
        let rts_fn = self.functions.get(&VarId::new(1000313)).ok_or_else(|| CodegenError::Internal("bhc_list_directory not declared".to_string()))?;
        let result = self.builder().build_call(*rts_fn, &[path_ptr.into()], "listdir")
            .map_err(|e| CodegenError::Internal(format!("listDirectory call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("listDirectory: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `show` (default: treat as integer).
    fn lower_builtin_show(&mut self, expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?.ok_or_else(|| CodegenError::Internal("show: no value".to_string()))?;
        let int_val = self.coerce_to_int(val)?;
        let rts_fn = self.functions.get(&VarId::new(1000072)).ok_or_else(|| CodegenError::Internal("bhc_show_int not declared".to_string()))?;
        let cstr_result = self.builder().build_call(*rts_fn, &[int_val.into()], "show")
            .map_err(|e| CodegenError::Internal(format!("show call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("show: returned void".to_string()))?;
        // Convert C-string result to [Char] linked list
        let char_list = self.cstring_to_char_list(cstr_result.into_pointer_value())?;
        Ok(Some(char_list.into()))
    }

    // ========================================================================
    // Phase 5: Monadic & Higher-Order Operation Handlers
    // ========================================================================

    /// Lower `fmap` / `<$>`.
    fn lower_builtin_fmap(&mut self, func_expr: &Expr, action_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let action_result = self.lower_expr(action_expr)?.ok_or_else(|| CodegenError::Internal("fmap: no value".to_string()))?;
        let func_val = self.lower_expr(func_expr)?.ok_or_else(|| CodegenError::Internal("fmap: no function".to_string()))?;
        let func_ptr = match func_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("fmap: function must be closure".to_string())) };
        let ptr_type = self.type_mapper().ptr_type();
        let action_ptr = self.value_to_ptr(action_result)?;
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let result = self.builder().build_indirect_call(fn_type, fn_ptr, &[func_ptr.into(), action_ptr.into()], "fmap_result")
            .map_err(|e| CodegenError::Internal(format!("fmap call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("fmap: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `<*>`.
    fn lower_builtin_ap(&mut self, func_expr: &Expr, val_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let func_result = self.lower_expr(func_expr)?.ok_or_else(|| CodegenError::Internal("<*>: no func".to_string()))?;
        let val_result = self.lower_expr(val_expr)?.ok_or_else(|| CodegenError::Internal("<*>: no val".to_string()))?;
        let func_ptr = match func_result { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("<*>: function must be closure".to_string())) };
        let ptr_type = self.type_mapper().ptr_type();
        let val_ptr = self.value_to_ptr(val_result)?;
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let result = self.builder().build_indirect_call(fn_type, fn_ptr, &[func_ptr.into(), val_ptr.into()], "ap_result")
            .map_err(|e| CodegenError::Internal(format!("<*> call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("<*>: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `join`.
    fn lower_builtin_join(&mut self, expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(expr)
    }

    /// Lower `=<<` (reverse bind).
    fn lower_builtin_bind_flipped(&mut self, func_expr: &Expr, action_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_bind(action_expr, func_expr)
    }

    /// Lower `when`.
    fn lower_builtin_when(&mut self, cond_expr: &Expr, action_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let cond_val = self.lower_expr(cond_expr)?.ok_or_else(|| CodegenError::Internal("when: no cond".to_string()))?;
        let cond_int = self.coerce_to_int(cond_val)?;
        let is_true = self.builder().build_int_compare(inkwell::IntPredicate::NE, cond_int, self.type_mapper().i64_type().const_zero(), "when_cond")
            .map_err(|e| CodegenError::Internal(format!("when: cmp failed: {:?}", e)))?;
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent()).ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let then_block = self.llvm_context().append_basic_block(current_fn, "when_then");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "when_merge");
        self.builder().build_conditional_branch(is_true, then_block, merge_block).map_err(|e| CodegenError::Internal(format!("when: branch failed: {:?}", e)))?;
        self.builder().position_at_end(then_block);
        let _ = self.lower_expr(action_expr)?;
        self.builder().build_unconditional_branch(merge_block).map_err(|e| CodegenError::Internal(format!("when: branch failed: {:?}", e)))?;
        self.builder().position_at_end(merge_block);
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `unless`.
    fn lower_builtin_unless(&mut self, cond_expr: &Expr, action_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let cond_val = self.lower_expr(cond_expr)?.ok_or_else(|| CodegenError::Internal("unless: no cond".to_string()))?;
        let cond_int = self.coerce_to_int(cond_val)?;
        let is_false = self.builder().build_int_compare(inkwell::IntPredicate::EQ, cond_int, self.type_mapper().i64_type().const_zero(), "unless_cond")
            .map_err(|e| CodegenError::Internal(format!("unless: cmp failed: {:?}", e)))?;
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent()).ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let then_block = self.llvm_context().append_basic_block(current_fn, "unless_then");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "unless_merge");
        self.builder().build_conditional_branch(is_false, then_block, merge_block).map_err(|e| CodegenError::Internal(format!("unless: branch failed: {:?}", e)))?;
        self.builder().position_at_end(then_block);
        let _ = self.lower_expr(action_expr)?;
        self.builder().build_unconditional_branch(merge_block).map_err(|e| CodegenError::Internal(format!("unless: branch failed: {:?}", e)))?;
        self.builder().position_at_end(merge_block);
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `void`.
    fn lower_builtin_void(&mut self, action_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(action_expr)?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `mapM`.
    fn lower_builtin_mapm(&mut self, func_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_map(func_expr, list_expr)
    }

    /// Lower `mapM_`.
    fn lower_builtin_mapm_(&mut self, func_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_builtin_map(func_expr, list_expr)?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `sequence`.
    fn lower_builtin_sequence(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(list_expr)
    }

    /// Lower `sequence_`.
    fn lower_builtin_sequence_(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(list_expr)?;
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    /// Lower `forever`.
    fn lower_builtin_forever(&mut self, action_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent()).ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let loop_block = self.llvm_context().append_basic_block(current_fn, "forever_loop");
        self.builder().build_unconditional_branch(loop_block).map_err(|e| CodegenError::Internal(format!("forever: branch failed: {:?}", e)))?;
        self.builder().position_at_end(loop_block);
        let _ = self.lower_expr(action_expr)?;
        self.builder().build_unconditional_branch(loop_block).map_err(|e| CodegenError::Internal(format!("forever: branch failed: {:?}", e)))?;
        let after_block = self.llvm_context().append_basic_block(current_fn, "forever_after");
        self.builder().position_at_end(after_block);
        Ok(Some(self.type_mapper().ptr_type().const_null().into()))
    }

    // Data.Function handlers

    /// Lower `flip f x y = f y x`.
    fn lower_builtin_flip(&mut self, func_expr: &Expr, arg1_expr: &Expr, arg2_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let func_val = self.lower_expr(func_expr)?.ok_or_else(|| CodegenError::Internal("flip: no function".to_string()))?;
        let _arg1 = self.lower_expr(arg1_expr)?.ok_or_else(|| CodegenError::Internal("flip: no arg1".to_string()))?;
        let arg2_val = self.lower_expr(arg2_expr)?.ok_or_else(|| CodegenError::Internal("flip: no arg2".to_string()))?;
        let func_ptr = match func_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("flip: function must be closure".to_string())) };
        let ptr_type = self.type_mapper().ptr_type();
        let arg1_ptr = self.value_to_ptr(_arg1)?;
        let arg2_ptr = self.value_to_ptr(arg2_val)?;
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let partial = self.builder().build_indirect_call(fn_type, fn_ptr, &[func_ptr.into(), arg2_ptr.into()], "flip_partial")
            .map_err(|e| CodegenError::Internal(format!("flip partial failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("flip: partial returned void".to_string()))?;
        let partial_ptr = match partial { BasicValueEnum::PointerValue(p) => p, _ => return Ok(Some(partial)) };
        let fn_ptr2 = self.extract_closure_fn_ptr(partial_ptr)?;
        let result = self.builder().build_indirect_call(fn_type, fn_ptr2, &[partial_ptr.into(), arg1_ptr.into()], "flip_result")
            .map_err(|e| CodegenError::Internal(format!("flip result failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("flip: result returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `on f g x y = f (g x) (g y)`.
    fn lower_builtin_on(&mut self, f_expr: &Expr, g_expr: &Expr, x_expr: &Expr, y_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?.ok_or_else(|| CodegenError::Internal("on: no f".to_string()))?;
        let g_val = self.lower_expr(g_expr)?.ok_or_else(|| CodegenError::Internal("on: no g".to_string()))?;
        let x_val = self.lower_expr(x_expr)?.ok_or_else(|| CodegenError::Internal("on: no x".to_string()))?;
        let y_val = self.lower_expr(y_expr)?.ok_or_else(|| CodegenError::Internal("on: no y".to_string()))?;
        let g_ptr = match g_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("on: g must be closure".to_string())) };
        let f_ptr = match f_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("on: f must be closure".to_string())) };
        let ptr_type = self.type_mapper().ptr_type();
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let x_ptr = self.value_to_ptr(x_val)?;
        let g_fn_ptr = self.extract_closure_fn_ptr(g_ptr)?;
        let gx = self.builder().build_indirect_call(fn_type, g_fn_ptr, &[g_ptr.into(), x_ptr.into()], "gx")
            .map_err(|e| CodegenError::Internal(format!("on: g(x) failed: {:?}", e)))?.try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("on: g(x) void".to_string()))?;
        let y_ptr = self.value_to_ptr(y_val)?;
        let gy = self.builder().build_indirect_call(fn_type, g_fn_ptr, &[g_ptr.into(), y_ptr.into()], "gy")
            .map_err(|e| CodegenError::Internal(format!("on: g(y) failed: {:?}", e)))?.try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("on: g(y) void".to_string()))?;
        let f_fn_ptr = self.extract_closure_fn_ptr(f_ptr)?;
        let gx_ptr = self.value_to_ptr(gx)?;
        let partial = self.builder().build_indirect_call(fn_type, f_fn_ptr, &[f_ptr.into(), gx_ptr.into()], "f_gx")
            .map_err(|e| CodegenError::Internal(format!("on: f(gx) failed: {:?}", e)))?.try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("on: f(gx) void".to_string()))?;
        let partial_ptr = match partial { BasicValueEnum::PointerValue(p) => p, _ => return Ok(Some(partial)) };
        let gy_ptr = self.value_to_ptr(gy)?;
        let p_fn = self.extract_closure_fn_ptr(partial_ptr)?;
        let result = self.builder().build_indirect_call(fn_type, p_fn, &[partial_ptr.into(), gy_ptr.into()], "on_result")
            .map_err(|e| CodegenError::Internal(format!("on: result failed: {:?}", e)))?.try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("on: result void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `fix` (simplified).
    fn lower_builtin_fix(&mut self, func_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(func_expr)
    }

    /// Lower `$` - function application.
    fn lower_builtin_apply(&mut self, func_expr: &Expr, arg_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let func_val = self.lower_expr(func_expr)?.ok_or_else(|| CodegenError::Internal("$: no function".to_string()))?;
        let arg_val = self.lower_expr(arg_expr)?.ok_or_else(|| CodegenError::Internal("$: no argument".to_string()))?;
        let func_ptr = match func_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError("$: function must be closure".to_string())) };
        let ptr_type = self.type_mapper().ptr_type();
        let arg_ptr = self.value_to_ptr(arg_val)?;
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let result = self.builder().build_indirect_call(fn_type, fn_ptr, &[func_ptr.into(), arg_ptr.into()], "apply_result")
            .map_err(|e| CodegenError::Internal(format!("$ call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("$: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `.` - function composition: (f . g) x = f (g x).
    fn lower_builtin_compose(&mut self, f_expr: &Expr, g_expr: &Expr, x_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let f_val = self.lower_expr(f_expr)?.ok_or_else(|| CodegenError::Internal(".: no f".to_string()))?;
        let g_val = self.lower_expr(g_expr)?.ok_or_else(|| CodegenError::Internal(".: no g".to_string()))?;
        let x_val = self.lower_expr(x_expr)?.ok_or_else(|| CodegenError::Internal(".: no x".to_string()))?;
        let g_ptr = match g_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError(".: g must be closure".to_string())) };
        let f_ptr = match f_val { BasicValueEnum::PointerValue(p) => p, _ => return Err(CodegenError::TypeError(".: f must be closure".to_string())) };
        let ptr_type = self.type_mapper().ptr_type();
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let x_ptr = self.value_to_ptr(x_val)?;
        let g_fn = self.extract_closure_fn_ptr(g_ptr)?;
        let gx = self.builder().build_indirect_call(fn_type, g_fn, &[g_ptr.into(), x_ptr.into()], "gx")
            .map_err(|e| CodegenError::Internal(format!(".: g(x) failed: {:?}", e)))?.try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(".: g(x) void".to_string()))?;
        let gx_ptr = self.value_to_ptr(gx)?;
        let f_fn = self.extract_closure_fn_ptr(f_ptr)?;
        let result = self.builder().build_indirect_call(fn_type, f_fn, &[f_ptr.into(), gx_ptr.into()], "compose")
            .map_err(|e| CodegenError::Internal(format!(".: f(g(x)) failed: {:?}", e)))?.try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(".: f(g(x)) void".to_string()))?;
        Ok(Some(result))
    }

    // ========================================================================
    // Phase 2: Advanced List Operation Handlers (stubs and implementations)
    // ========================================================================

    /// Lower `any`.
    fn lower_builtin_any(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Simplified: evaluate both, return False (proper impl needs loop)
        let _ = self.lower_expr(pred_expr)?;
        let _ = self.lower_expr(list_expr)?;
        Ok(Some(self.int_to_ptr(self.type_mapper().i64_type().const_zero())?.into()))
    }

    /// Lower `all`.
    fn lower_builtin_all(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(pred_expr)?;
        let _ = self.lower_expr(list_expr)?;
        Ok(Some(self.int_to_ptr(self.type_mapper().i64_type().const_int(1, false))?.into()))
    }

    /// Lower `and`.
    fn lower_builtin_and(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_product(list_expr)
    }

    /// Lower `or`.
    fn lower_builtin_or(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_sum(list_expr)
    }

    /// Lower `maximum`.
    fn lower_builtin_maximum(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(list_expr)
    }

    /// Lower `minimum`.
    fn lower_builtin_minimum(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(list_expr)
    }

    /// Lower `elem`.
    fn lower_builtin_elem(&mut self, val_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the value to search for
        let val_val = self
            .lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("elem: value has no value".to_string()))?;
        let val_ptr = self.value_to_ptr(val_val)?;

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("elem: list has no value".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("elem expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "elem_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "elem_body");
        let found_block = self.llvm_ctx.append_basic_block(current_fn, "elem_found");
        let not_found_block = self.llvm_ctx.append_basic_block(current_fn, "elem_not_found");
        let merge_block = self.llvm_ctx.append_basic_block(current_fn, "elem_merge");

        // Convert search value to i64 for comparison
        let val_int = self
            .builder()
            .build_ptr_to_int(val_ptr, tm.i64_type(), "val_int")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "elem_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, not_found_block, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: extract head, compare via ptr_to_int
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let head_int = self
            .builder()
            .build_ptr_to_int(head_ptr, tm.i64_type(), "head_int")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_equal = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                head_int,
                val_int,
                "is_equal",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_equal, found_block, loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Found: return True = int_to_ptr(1)
        self.builder().position_at_end(found_block);
        let true_val = self.int_to_ptr(tm.i64_type().const_int(1, false))?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Not found: return False = int_to_ptr(0)
        self.builder().position_at_end(not_found_block);
        let false_val = self.int_to_ptr(tm.i64_type().const_zero())?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Merge
        self.builder().position_at_end(merge_block);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "elem_result")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        result_phi.add_incoming(&[(&true_val, found_block), (&false_val, not_found_block)]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `notElem :: Eq a => a -> [a] -> Bool`.
    /// Inverse of elem: returns True if element is NOT in the list.
    fn lower_builtin_not_elem(&mut self, val_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the value to search for
        let val_val = self
            .lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("notElem: value has no value".to_string()))?;
        let val_ptr = self.value_to_ptr(val_val)?;

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("notElem: list has no value".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("notElem expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "notelem_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "notelem_body");
        let found_block = self.llvm_ctx.append_basic_block(current_fn, "notelem_found");
        let not_found_block = self.llvm_ctx.append_basic_block(current_fn, "notelem_not_found");
        let merge_block = self.llvm_ctx.append_basic_block(current_fn, "notelem_merge");

        // Convert search value to i64 for comparison
        let val_int = self
            .builder()
            .build_ptr_to_int(val_ptr, tm.i64_type(), "val_int")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "notelem_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, not_found_block, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: extract head, compare via ptr_to_int
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let head_int = self
            .builder()
            .build_ptr_to_int(head_ptr, tm.i64_type(), "head_int")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_equal = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                head_int,
                val_int,
                "is_equal",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_equal, found_block, loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Found: element IS in list, so notElem returns False = int_to_ptr(0)
        self.builder().position_at_end(found_block);
        let false_val = self.int_to_ptr(tm.i64_type().const_zero())?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Not found: element is NOT in list, so notElem returns True = int_to_ptr(1)
        self.builder().position_at_end(not_found_block);
        let true_val = self.int_to_ptr(tm.i64_type().const_int(1, false))?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Merge
        self.builder().position_at_end(merge_block);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "notelem_result")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        result_phi.add_incoming(&[(&false_val, found_block), (&true_val, not_found_block)]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `iterate` (stub: single-element list).
    fn lower_builtin_iterate(&mut self, _func_expr: &Expr, seed_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(_func_expr)?;
        let seed_val = self.lower_expr(seed_expr)?.ok_or_else(|| CodegenError::Internal("iterate: no seed".to_string()))?;
        let seed_ptr = self.value_to_ptr(seed_val)?;
        let nil = self.alloc_adt(0, 0)?;
        let cons = self.alloc_adt(1, 2)?;
        self.store_adt_field(cons, 2, 0, seed_ptr.into())?;
        self.store_adt_field(cons, 2, 1, nil.into())?;
        Ok(Some(cons.into()))
    }

    /// Lower `repeat` (stub).
    fn lower_builtin_repeat(&mut self, val_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_iterate(val_expr, val_expr)
    }

    /// Lower `cycle` (stub).
    fn lower_builtin_cycle(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_expr(list_expr)
    }

    /// Lower `takeWhile`  take longest prefix where predicate holds.
    fn lower_builtin_take_while(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let pred_val = self.lower_expr(pred_expr)?.ok_or_else(|| CodegenError::Internal("takeWhile: no predicate".to_string()))?;
        let pred_ptr = match pred_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("takeWhile: predicate must be a closure".to_string())),
        };
        let list_val = self.lower_expr(list_expr)?.ok_or_else(|| CodegenError::Internal("takeWhile: no list".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("takeWhile expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self.builder().get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "tw_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "tw_body");
        let tw_keep = self.llvm_ctx.append_basic_block(current_fn, "tw_keep");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "tw_exit");

        let nil = self.build_nil()?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "tw_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self.builder().build_phi(ptr_type, "tw_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let pred_fn_ptr = self.extract_closure_fn_ptr(pred_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let pred_result = self.builder()
            .build_indirect_call(fn_type, pred_fn_ptr, &[pred_ptr.into(), head_ptr.into()], "pred_result")
            .map_err(|e| CodegenError::Internal(format!("call predicate: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("predicate returned void".to_string()))?;
        let pred_bool = self.builder()
            .build_ptr_to_int(pred_result.into_pointer_value(), tm.i64_type(), "pred_bool")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_true = self.builder().build_int_compare(
            inkwell::IntPredicate::NE, pred_bool, tm.i64_type().const_zero(), "is_true",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        // If pred is true, keep; if false, stop
        self.builder().build_conditional_branch(is_true, tw_keep, loop_exit)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(tw_keep);
        let new_cons = self.build_cons(head_ptr.into(), acc_phi.as_basic_value())?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_cons, tw_keep)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, tw_keep)]);

        // Exit: reverse accumulated prefix
        self.builder().position_at_end(loop_exit);
        let acc_at_exit = self.builder().build_phi(ptr_type, "tw_acc_exit")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        acc_at_exit.add_incoming(&[
            (&acc_phi.as_basic_value(), loop_header),
            (&acc_phi.as_basic_value(), loop_body),
        ]);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "tw_rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "tw_rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "tw_rev_exit");
        let nil2 = self.build_nil()?;
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self.builder().build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_list = self.builder().build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, rev_tag, tm.i64_type().const_zero(), "rev_is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[(&acc_at_exit.as_basic_value(), loop_exit), (&rev_tail, rev_body)]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `dropWhile`  drop longest prefix where predicate holds.
    fn lower_builtin_drop_while(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let pred_val = self.lower_expr(pred_expr)?.ok_or_else(|| CodegenError::Internal("dropWhile: no predicate".to_string()))?;
        let pred_ptr = match pred_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("dropWhile: predicate must be a closure".to_string())),
        };
        let list_val = self.lower_expr(list_expr)?.ok_or_else(|| CodegenError::Internal("dropWhile: no list".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("dropWhile expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self.builder().get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "dw_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "dw_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "dw_exit");

        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let list_phi = self.builder().build_phi(ptr_type, "dw_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let pred_fn_ptr = self.extract_closure_fn_ptr(pred_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let pred_result = self.builder()
            .build_indirect_call(fn_type, pred_fn_ptr, &[pred_ptr.into(), head_ptr.into()], "pred_result")
            .map_err(|e| CodegenError::Internal(format!("call predicate: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("predicate returned void".to_string()))?;
        let pred_bool = self.builder()
            .build_ptr_to_int(pred_result.into_pointer_value(), tm.i64_type(), "pred_bool")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_true = self.builder().build_int_compare(
            inkwell::IntPredicate::NE, pred_bool, tm.i64_type().const_zero(), "is_true",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        // If pred true, continue dropping (advance to tail); if false, stop
        self.builder().build_conditional_branch(is_true, loop_header, loop_exit)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Note: when branching back from body, we use tail_ptr
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: return the remaining list
        self.builder().position_at_end(loop_exit);
        let result_phi = self.builder().build_phi(ptr_type, "dw_result")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        result_phi.add_incoming(&[
            (&list_phi.as_basic_value(), loop_header),  // empty list case
            (&list_phi.as_basic_value(), loop_body),    // pred became false case
        ]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `span :: (a -> Bool) -> [a] -> ([a], [a])`.
    /// Takes the longest prefix of elements satisfying the predicate.
    /// Returns (prefix, rest) as a pair ADT (tag=0, arity=2).
    fn lower_builtin_span(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower predicate closure
        let pred_val = self
            .lower_expr(pred_expr)?
            .ok_or_else(|| CodegenError::Internal("span: predicate has no value".to_string()))?;
        let pred_ptr = match pred_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "span: predicate must be a closure".to_string(),
                ))
            }
        };

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("span: list has no value".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("span expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "span_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "span_body");
        let span_keep = self.llvm_ctx.append_basic_block(current_fn, "span_keep");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "span_exit");

        let nil = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header: phi for reversed prefix and current list
        self.builder().position_at_end(loop_header);
        let prefix_phi = self
            .builder()
            .build_phi(ptr_type, "span_prefix")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "span_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        // Check if list is empty
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: test predicate on head
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call predicate
        let pred_fn_ptr = self.extract_closure_fn_ptr(pred_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let pred_result = self
            .builder()
            .build_indirect_call(
                fn_type,
                pred_fn_ptr,
                &[pred_ptr.into(), head_ptr.into()],
                "pred_result",
            )
            .map_err(|e| CodegenError::Internal(format!("call predicate: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("predicate returned void".to_string()))?;

        let pred_bool = self
            .builder()
            .build_ptr_to_int(pred_result.into_pointer_value(), tm.i64_type(), "pred_bool")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_true = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::NE,
                pred_bool,
                tm.i64_type().const_zero(),
                "is_true",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_true, span_keep, loop_exit)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Keep block: cons head onto prefix, continue with tail
        self.builder().position_at_end(span_keep);
        let new_cons = self.build_cons(head_ptr.into(), prefix_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Add phi incoming values
        prefix_phi.add_incoming(&[(&nil, entry_block), (&new_cons, span_keep)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, span_keep)]);

        // Exit: we have reversed prefix and rest = current list_phi
        self.builder().position_at_end(loop_exit);

        // Phi nodes for values arriving at exit from header (empty list) or body (pred false)
        let rest_phi = self
            .builder()
            .build_phi(ptr_type, "span_rest")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        rest_phi.add_incoming(&[
            (&list_phi.as_basic_value(), loop_header),
            (&list_phi.as_basic_value(), loop_body),
        ]);

        let prefix_at_exit = self
            .builder()
            .build_phi(ptr_type, "span_prefix_exit")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        prefix_at_exit.add_incoming(&[
            (&prefix_phi.as_basic_value(), loop_header),
            (&prefix_phi.as_basic_value(), loop_body),
        ]);

        // Inline reverse of prefix
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "span_rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "span_rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "span_rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&prefix_at_exit.as_basic_value(), loop_exit),
            (&rev_tail, rev_body),
        ]);

        // Build pair (reversed_prefix, rest) as ADT (tag=0, arity=2)
        self.builder().position_at_end(rev_exit);
        let pair = self.alloc_adt(0, 2)?;
        self.store_adt_field(pair, 2, 0, rev_acc.as_basic_value())?;
        self.store_adt_field(pair, 2, 1, rest_phi.as_basic_value())?;

        Ok(Some(pair.into()))
    }

    /// Lower `break`  split list at first element where predicate is True.
    /// break p xs = span (not . p) xs
    /// Takes prefix where pred is False, rest starts where pred becomes True.
    fn lower_builtin_break(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let pred_val = self.lower_expr(pred_expr)?.ok_or_else(|| CodegenError::Internal("break: no predicate".to_string()))?;
        let pred_ptr = match pred_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("break: predicate must be a closure".to_string())),
        };
        let list_val = self.lower_expr(list_expr)?.ok_or_else(|| CodegenError::Internal("break: no list".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("break expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self.builder().get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "break_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "break_body");
        let break_keep = self.llvm_ctx.append_basic_block(current_fn, "break_keep");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "break_exit");

        let nil = self.build_nil()?;

        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let prefix_phi = self.builder().build_phi(ptr_type, "break_prefix")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self.builder().build_phi(ptr_type, "break_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder().build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: test predicate
        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let pred_fn_ptr = self.extract_closure_fn_ptr(pred_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let pred_result = self.builder()
            .build_indirect_call(fn_type, pred_fn_ptr, &[pred_ptr.into(), head_ptr.into()], "pred_result")
            .map_err(|e| CodegenError::Internal(format!("call predicate: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("predicate returned void".to_string()))?;

        let pred_bool = self.builder()
            .build_ptr_to_int(pred_result.into_pointer_value(), tm.i64_type(), "pred_bool")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        // break stops when pred is TRUE (opposite of span)
        let is_true = self.builder().build_int_compare(
            inkwell::IntPredicate::NE, pred_bool, tm.i64_type().const_zero(), "is_true",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        // If pred is true, exit (break found). If false, keep going.
        self.builder().build_conditional_branch(is_true, loop_exit, break_keep)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Keep block: pred is false, cons head onto prefix
        self.builder().position_at_end(break_keep);
        let new_cons = self.build_cons(head_ptr.into(), prefix_phi.as_basic_value())?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        prefix_phi.add_incoming(&[(&nil, entry_block), (&new_cons, break_keep)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, break_keep)]);

        // Exit
        self.builder().position_at_end(loop_exit);

        let rest_phi = self.builder().build_phi(ptr_type, "break_rest")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        rest_phi.add_incoming(&[
            (&list_phi.as_basic_value(), loop_header),
            (&list_phi.as_basic_value(), loop_body),
        ]);

        let prefix_at_exit = self.builder().build_phi(ptr_type, "break_prefix_exit")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        prefix_at_exit.add_incoming(&[
            (&prefix_phi.as_basic_value(), loop_header),
            (&prefix_phi.as_basic_value(), loop_body),
        ]);

        // Inline reverse prefix
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "brk_rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "brk_rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "brk_rev_exit");
        let nil2 = self.build_nil()?;
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self.builder().build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_list = self.builder().build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, rev_tag, tm.i64_type().const_zero(), "rev_is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[(&prefix_at_exit.as_basic_value(), loop_exit), (&rev_tail, rev_body)]);

        self.builder().position_at_end(rev_exit);
        let pair = self.alloc_adt(0, 2)?;
        self.store_adt_field(pair, 2, 0, rev_acc.as_basic_value())?;
        self.store_adt_field(pair, 2, 1, rest_phi.as_basic_value())?;

        Ok(Some(pair.into()))
    }

    /// Lower `splitAt`  split list at position n.
    /// splitAt n xs = (take n xs, drop n xs)
    fn lower_builtin_split_at(&mut self, n_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let n_val = self.lower_expr(n_expr)?.ok_or_else(|| CodegenError::Internal("splitAt: no n".to_string()))?;
        let n_int = self.coerce_to_int(n_val)?;
        let list_val = self.lower_expr(list_expr)?.ok_or_else(|| CodegenError::Internal("splitAt: no list".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("splitAt expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let i64_type = tm.i64_type();
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self.builder().get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "splitat_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "splitat_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "splitat_exit");

        let nil = self.build_nil()?;

        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let prefix_phi = self.builder().build_phi(ptr_type, "splitat_prefix")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self.builder().build_phi(ptr_type, "splitat_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let counter_phi = self.builder().build_phi(i64_type, "splitat_counter")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        // Check if counter reached n or list is empty
        let counter_done = self.builder().build_int_compare(
            inkwell::IntPredicate::SGE, counter_phi.as_basic_value().into_int_value(), n_int, "counter_done",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, tag, i64_type.const_zero(), "is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        let should_stop = self.builder().build_or(counter_done, is_empty, "should_stop")
            .map_err(|e| CodegenError::Internal(format!("or: {:?}", e)))?;

        self.builder().build_conditional_branch(should_stop, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: take one element
        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;
        let new_cons = self.build_cons(head_ptr.into(), prefix_phi.as_basic_value())?;
        let next_counter = self.builder().build_int_add(
            counter_phi.as_basic_value().into_int_value(), i64_type.const_int(1, false), "next_counter",
        ).map_err(|e| CodegenError::Internal(format!("add: {:?}", e)))?;

        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        prefix_phi.add_incoming(&[(&nil, entry_block), (&new_cons, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);
        counter_phi.add_incoming(&[(&i64_type.const_zero(), entry_block), (&next_counter, loop_body)]);

        // Exit: reverse prefix, rest = current list
        self.builder().position_at_end(loop_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "sa_rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "sa_rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "sa_rev_exit");
        let nil2 = self.build_nil()?;
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self.builder().build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_list = self.builder().build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, rev_tag, i64_type.const_zero(), "rev_is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[(&prefix_phi.as_basic_value(), loop_exit), (&rev_tail, rev_body)]);

        self.builder().position_at_end(rev_exit);
        let pair = self.alloc_adt(0, 2)?;
        self.store_adt_field(pair, 2, 0, rev_acc.as_basic_value())?;
        self.store_adt_field(pair, 2, 1, list_phi.as_basic_value())?;

        Ok(Some(pair.into()))
    }

    /// Lower `find :: (a -> Bool) -> [a] -> Maybe a`.
    /// Traverses the list, applying predicate to each element.
    /// Returns Just element for the first match, or Nothing if none found.
    fn lower_builtin_find(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower predicate closure
        let pred_val = self
            .lower_expr(pred_expr)?
            .ok_or_else(|| CodegenError::Internal("find: predicate has no value".to_string()))?;
        let pred_ptr = match pred_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "find: predicate must be a closure".to_string(),
                ))
            }
        };

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("find: list has no value".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("find expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "find_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "find_body");
        let found_block = self.llvm_ctx.append_basic_block(current_fn, "find_found");
        let not_found_block = self.llvm_ctx.append_basic_block(current_fn, "find_not_found");
        let merge_block = self.llvm_ctx.append_basic_block(current_fn, "find_merge");

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header: phi for current list pointer
        self.builder().position_at_end(loop_header);
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "find_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        // Check if list is empty (tag == 0 means nil)
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, not_found_block, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: extract head, apply predicate
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call predicate: pred(pred_ptr, head)
        let pred_fn_ptr = self.extract_closure_fn_ptr(pred_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let pred_result = self
            .builder()
            .build_indirect_call(
                fn_type,
                pred_fn_ptr,
                &[pred_ptr.into(), head_ptr.into()],
                "pred_result",
            )
            .map_err(|e| CodegenError::Internal(format!("call predicate: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("predicate returned void".to_string()))?;

        // Check boolean result
        let pred_bool = self
            .builder()
            .build_ptr_to_int(pred_result.into_pointer_value(), tm.i64_type(), "pred_bool")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_true = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::NE,
                pred_bool,
                tm.i64_type().const_zero(),
                "is_true",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_true, found_block, loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Add phi incoming for list_phi
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Found block: return Just element (tag=1, arity=1)
        self.builder().position_at_end(found_block);
        let just = self.alloc_adt(1, 1)?;
        self.store_adt_field(just, 1, 0, head_ptr.into())?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Not found block: return Nothing (tag=0, arity=0)
        self.builder().position_at_end(not_found_block);
        let nothing = self.alloc_adt(0, 0)?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Merge block: phi to select Just or Nothing
        self.builder().position_at_end(merge_block);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "find_result")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        result_phi.add_incoming(&[(&just, found_block), (&nothing, not_found_block)]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `lookup :: Eq k => k -> [(k,v)] -> Maybe v`.
    /// Traverses an association list (list of pairs). Each head element is a pair
    /// ADT (tag=0, arity=2) with field 0 = key, field 1 = value.
    /// Compares key via ptr_to_int equality.
    fn lower_builtin_lookup(&mut self, key_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the key
        let key_val = self
            .lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("lookup: key has no value".to_string()))?;
        let key_ptr = self.value_to_ptr(key_val)?;

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("lookup: list has no value".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("lookup expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "lookup_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "lookup_body");
        let found_block = self.llvm_ctx.append_basic_block(current_fn, "lookup_found");
        let not_found_block = self.llvm_ctx.append_basic_block(current_fn, "lookup_not_found");
        let merge_block = self.llvm_ctx.append_basic_block(current_fn, "lookup_merge");

        // Convert search key to i64 for comparison
        let key_int = self
            .builder()
            .build_ptr_to_int(key_ptr, tm.i64_type(), "key_int")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "lookup_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, not_found_block, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: extract head (a pair), then extract key and value from it
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // head_ptr is a pair (tag=0, arity=2): extract field 0 (key) and field 1 (value)
        let pair_key = self.extract_adt_field(head_ptr, 2, 0)?;
        let pair_val = self.extract_adt_field(head_ptr, 2, 1)?;

        // Compare pair key with search key
        let pair_key_int = self
            .builder()
            .build_ptr_to_int(pair_key, tm.i64_type(), "pair_key_int")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_match = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                pair_key_int,
                key_int,
                "is_match",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_match, found_block, loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Add phi incoming
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Found: return Just value (tag=1, arity=1)
        self.builder().position_at_end(found_block);
        let just = self.alloc_adt(1, 1)?;
        self.store_adt_field(just, 1, 0, pair_val.into())?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Not found: return Nothing (tag=0, arity=0)
        self.builder().position_at_end(not_found_block);
        let nothing = self.alloc_adt(0, 0)?;
        self.builder()
            .build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Merge
        self.builder().position_at_end(merge_block);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "lookup_result")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        result_phi.add_incoming(&[(&just, found_block), (&nothing, not_found_block)]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `partition :: (a -> Bool) -> [a] -> ([a], [a])`.
    /// Splits the list into (elements satisfying pred, elements not satisfying).
    /// Both sublists built in reverse during traversal, then reversed.
    fn lower_builtin_partition(&mut self, pred_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower predicate closure
        let pred_val = self
            .lower_expr(pred_expr)?
            .ok_or_else(|| {
                CodegenError::Internal("partition: predicate has no value".to_string())
            })?;
        let pred_ptr = match pred_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "partition: predicate must be a closure".to_string(),
                ))
            }
        };

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("partition: list has no value".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("partition expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "part_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "part_body");
        let part_yes = self.llvm_ctx.append_basic_block(current_fn, "part_yes");
        let part_no = self.llvm_ctx.append_basic_block(current_fn, "part_no");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "part_exit");

        let nil = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header: phi for yes_list (reversed), no_list (reversed), current list
        self.builder().position_at_end(loop_header);
        let yes_phi = self
            .builder()
            .build_phi(ptr_type, "part_yes_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let no_phi = self
            .builder()
            .build_phi(ptr_type, "part_no_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "part_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        // Check if list is empty
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: test predicate
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call predicate
        let pred_fn_ptr = self.extract_closure_fn_ptr(pred_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
        let pred_result = self
            .builder()
            .build_indirect_call(
                fn_type,
                pred_fn_ptr,
                &[pred_ptr.into(), head_ptr.into()],
                "pred_result",
            )
            .map_err(|e| CodegenError::Internal(format!("call predicate: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("predicate returned void".to_string()))?;

        let pred_bool = self
            .builder()
            .build_ptr_to_int(pred_result.into_pointer_value(), tm.i64_type(), "pred_bool")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_true = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::NE,
                pred_bool,
                tm.i64_type().const_zero(),
                "is_true",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_true, part_yes, part_no)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Yes block: cons head onto yes_list
        self.builder().position_at_end(part_yes);
        let yes_new_cons = self.build_cons(head_ptr.into(), yes_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // No block: cons head onto no_list
        self.builder().position_at_end(part_no);
        let no_new_cons = self.build_cons(head_ptr.into(), no_phi.as_basic_value())?;
        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Add phi incoming values
        yes_phi.add_incoming(&[
            (&nil, entry_block),
            (&yes_new_cons, part_yes),
            (&yes_phi.as_basic_value(), part_no),
        ]);
        no_phi.add_incoming(&[
            (&nil, entry_block),
            (&no_phi.as_basic_value(), part_yes),
            (&no_new_cons, part_no),
        ]);
        list_phi.add_incoming(&[
            (&list_ptr, entry_block),
            (&tail_ptr, part_yes),
            (&tail_ptr, part_no),
        ]);

        // Exit: reverse both lists
        self.builder().position_at_end(loop_exit);

        // --- Reverse yes_list ---
        let rev1_header = self.llvm_ctx.append_basic_block(current_fn, "rev1_header");
        let rev1_body = self.llvm_ctx.append_basic_block(current_fn, "rev1_body");
        let rev1_exit = self.llvm_ctx.append_basic_block(current_fn, "rev1_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev1_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev1_header);
        let rev1_acc = self
            .builder()
            .build_phi(ptr_type, "rev1_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev1_list = self
            .builder()
            .build_phi(ptr_type, "rev1_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let rev1_tag = self.extract_adt_tag(rev1_list.as_basic_value().into_pointer_value())?;
        let rev1_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev1_tag,
                tm.i64_type().const_zero(),
                "rev1_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev1_is_empty, rev1_exit, rev1_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev1_body);
        let rev1_head =
            self.extract_adt_field(rev1_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev1_tail =
            self.extract_adt_field(rev1_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev1_new_cons = self.build_cons(rev1_head.into(), rev1_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev1_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev1_acc.add_incoming(&[(&nil2, loop_exit), (&rev1_new_cons, rev1_body)]);
        rev1_list.add_incoming(&[
            (&yes_phi.as_basic_value(), loop_exit),
            (&rev1_tail, rev1_body),
        ]);

        // --- Reverse no_list ---
        self.builder().position_at_end(rev1_exit);

        let rev2_header = self.llvm_ctx.append_basic_block(current_fn, "rev2_header");
        let rev2_body = self.llvm_ctx.append_basic_block(current_fn, "rev2_body");
        let rev2_exit = self.llvm_ctx.append_basic_block(current_fn, "rev2_exit");

        let nil3 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev2_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev2_header);
        let rev2_acc = self
            .builder()
            .build_phi(ptr_type, "rev2_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev2_list = self
            .builder()
            .build_phi(ptr_type, "rev2_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let rev2_tag = self.extract_adt_tag(rev2_list.as_basic_value().into_pointer_value())?;
        let rev2_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev2_tag,
                tm.i64_type().const_zero(),
                "rev2_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev2_is_empty, rev2_exit, rev2_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev2_body);
        let rev2_head =
            self.extract_adt_field(rev2_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev2_tail =
            self.extract_adt_field(rev2_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev2_new_cons = self.build_cons(rev2_head.into(), rev2_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev2_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev2_acc.add_incoming(&[(&nil3, rev1_exit), (&rev2_new_cons, rev2_body)]);
        rev2_list.add_incoming(&[
            (&no_phi.as_basic_value(), rev1_exit),
            (&rev2_tail, rev2_body),
        ]);

        // Build pair (reversed_yes, reversed_no) as ADT (tag=0, arity=2)
        self.builder().position_at_end(rev2_exit);
        let pair = self.alloc_adt(0, 2)?;
        self.store_adt_field(pair, 2, 0, rev1_acc.as_basic_value())?;
        self.store_adt_field(pair, 2, 1, rev2_acc.as_basic_value())?;

        Ok(Some(pair.into()))
    }

    /// Lower `intersperse :: a -> [a] -> [a]`.
    /// Inserts separator between each element. Empty/singleton lists unchanged.
    fn lower_builtin_intersperse(&mut self, sep_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the separator
        let sep_val = self
            .lower_expr(sep_expr)?
            .ok_or_else(|| {
                CodegenError::Internal("intersperse: separator has no value".to_string())
            })?;
        let sep_ptr = self.value_to_ptr(sep_val)?;

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| {
                CodegenError::Internal("intersperse: list has no value".to_string())
            })?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "intersperse expects a list".to_string(),
                ))
            }
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Check if list is empty first
        let empty_block = self.llvm_ctx.append_basic_block(current_fn, "inter_empty");
        let first_block = self.llvm_ctx.append_basic_block(current_fn, "inter_first");
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "inter_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "inter_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "inter_exit");
        let final_merge = self.llvm_ctx.append_basic_block(current_fn, "inter_merge");

        let tag = self.extract_adt_tag(list_ptr)?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, empty_block, first_block)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Empty list: return nil
        self.builder().position_at_end(empty_block);
        let empty_nil = self.build_nil()?;
        self.builder()
            .build_unconditional_branch(final_merge)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // First element: extract head, start reversed result with just head
        self.builder().position_at_end(first_block);
        let first_head = self.extract_adt_field(list_ptr, 2, 0)?;
        let first_tail = self.extract_adt_field(list_ptr, 2, 1)?;

        let nil = self.build_nil()?;
        let first_cons = self.build_cons(first_head.into(), nil.into())?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header: process remaining elements, prepending sep then element
        self.builder().position_at_end(loop_header);
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "inter_result")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "inter_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let loop_tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let loop_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                loop_tag,
                tm.i64_type().const_zero(),
                "loop_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(loop_is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: cons element, then cons sep (building reversed)
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // In reverse: cons element first, then sep on top
        let with_elem = self.build_cons(head_ptr.into(), result_phi.as_basic_value())?;
        let with_sep = self.build_cons(sep_ptr.into(), with_elem.into())?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        result_phi.add_incoming(&[(&first_cons, first_block), (&with_sep, loop_body)]);
        list_phi.add_incoming(&[(&first_tail, first_block), (&tail_ptr, loop_body)]);

        // Loop exit: reverse the result
        self.builder().position_at_end(loop_exit);

        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[
            (&result_phi.as_basic_value(), loop_exit),
            (&rev_tail, rev_body),
        ]);

        // After reverse, branch to final merge
        self.builder().position_at_end(rev_exit);
        self.builder()
            .build_unconditional_branch(final_merge)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Final merge: either empty nil or reversed result
        self.builder().position_at_end(final_merge);
        let final_phi = self
            .builder()
            .build_phi(ptr_type, "inter_final")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        final_phi.add_incoming(&[(&empty_nil, empty_block), (&rev_acc.as_basic_value(), rev_exit)]);

        Ok(Some(final_phi.as_basic_value()))
    }

    /// Lower `intercalate`  call RTS bhc_list_intercalate.
    fn lower_builtin_intercalate(&mut self, sep_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let sep_val = self.lower_expr(sep_expr)?
            .ok_or_else(|| CodegenError::Internal("intercalate: no sep".to_string()))?;
        let sep_ptr = self.value_to_ptr(sep_val)?;
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("intercalate: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000174)).ok_or_else(|| {
            CodegenError::Internal("bhc_list_intercalate not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[sep_ptr.into(), list_ptr.into()], "intercalate")
            .map_err(|e| CodegenError::Internal(format!("intercalate call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("intercalate: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `transpose`  call RTS bhc_list_transpose.
    fn lower_builtin_transpose(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("transpose: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000175)).ok_or_else(|| {
            CodegenError::Internal("bhc_list_transpose not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[list_ptr.into()], "transpose")
            .map_err(|e| CodegenError::Internal(format!("transpose call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("transpose: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `nub`  call RTS bhc_list_nub.
    fn lower_builtin_nub(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("nub: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000172)).ok_or_else(|| {
            CodegenError::Internal("bhc_list_nub not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[list_ptr.into()], "nub")
            .map_err(|e| CodegenError::Internal(format!("nub call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("nub: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `sort`  call RTS bhc_list_sort.
    fn lower_builtin_sort(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("sort: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000170)).ok_or_else(|| {
            CodegenError::Internal("bhc_list_sort not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[list_ptr.into()], "sort")
            .map_err(|e| CodegenError::Internal(format!("sort call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("sort: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `sortBy`  call RTS bhc_list_sort_by.
    fn lower_builtin_sort_by(&mut self, cmp_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let cmp_val = self.lower_expr(cmp_expr)?
            .ok_or_else(|| CodegenError::Internal("sortBy: no cmp".to_string()))?;
        let cmp_ptr = self.value_to_ptr(cmp_val)?;
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("sortBy: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000171)).ok_or_else(|| {
            CodegenError::Internal("bhc_list_sort_by not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[cmp_ptr.into(), list_ptr.into()], "sort_by")
            .map_err(|e| CodegenError::Internal(format!("sort_by call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("sort_by: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `group`  call RTS bhc_list_group.
    fn lower_builtin_group(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("group: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000173)).ok_or_else(|| {
            CodegenError::Internal("bhc_list_group not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[list_ptr.into()], "group")
            .map_err(|e| CodegenError::Internal(format!("group call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("group: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `delete`  remove first occurrence of value from list.
    /// delete x [] = []
    /// delete x (y:ys) = if x == y then ys else y : delete x ys
    fn lower_builtin_delete(&mut self, val_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(val_expr)?.ok_or_else(|| CodegenError::Internal("delete: no value".to_string()))?;
        let val_int = self.coerce_to_int(val)?;
        let list_val = self.lower_expr(list_expr)?.ok_or_else(|| CodegenError::Internal("delete: no list".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("delete expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self.builder().get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        // Phase 1: scan for element, collecting prefix in reverse
        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "del_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "del_body");
        let del_found = self.llvm_ctx.append_basic_block(current_fn, "del_found");
        let del_notfound = self.llvm_ctx.append_basic_block(current_fn, "del_notfound");
        let del_merge = self.llvm_ctx.append_basic_block(current_fn, "del_merge");

        let nil = self.build_nil()?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let prefix_phi = self.builder().build_phi(ptr_type, "del_prefix")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self.builder().build_phi(ptr_type, "del_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        // Empty list  element not in list, go to merge with nil suffix
        self.builder().build_conditional_branch(is_empty, del_merge, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Body: compare element
        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        let head_int = self.builder()
            .build_ptr_to_int(head_ptr, tm.i64_type(), "head_int")
            .map_err(|e| CodegenError::Internal(format!("ptr_to_int: {:?}", e)))?;
        let is_match = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, head_int, val_int, "is_match",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder().build_conditional_branch(is_match, del_found, del_notfound)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Found: result = reverse(prefix) ++ tail (skip matched element)
        self.builder().position_at_end(del_found);
        self.builder().build_unconditional_branch(del_merge)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Not found in this element: cons head onto prefix, continue with tail
        self.builder().position_at_end(del_notfound);
        let new_cons = self.build_cons(head_ptr.into(), prefix_phi.as_basic_value())?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        prefix_phi.add_incoming(&[(&nil, entry_block), (&new_cons, del_notfound)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, del_notfound)]);

        // Merge: reverse prefix onto suffix
        // Reached from: loop_header (empty, suffix=nil) or del_found (suffix=tail)
        self.builder().position_at_end(del_merge);
        let suffix_phi = self.builder().build_phi(ptr_type, "del_suffix")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        suffix_phi.add_incoming(&[
            (&nil, loop_header),        // empty list: no suffix
            (&tail_ptr, del_found),     // found: skip matched, suffix = tail
        ]);

        let prefix_at_merge = self.builder().build_phi(ptr_type, "del_prefix_merge")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        prefix_at_merge.add_incoming(&[
            (&prefix_phi.as_basic_value(), loop_header),
            (&prefix_phi.as_basic_value(), del_found),
        ]);

        // Reverse prefix onto suffix
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "del_rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "del_rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "del_rev_exit");
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self.builder().build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_list = self.builder().build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, rev_tag, tm.i64_type().const_zero(), "rev_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(rev_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let r_head = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let r_tail = self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let r_cons = self.build_cons(r_head.into(), rev_acc.as_basic_value())?;
        self.builder().build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Note: initial acc is the suffix (we reverse-prepend prefix onto it)
        rev_acc.add_incoming(&[(&suffix_phi.as_basic_value(), del_merge), (&r_cons, rev_body)]);
        rev_list.add_incoming(&[(&prefix_at_merge.as_basic_value(), del_merge), (&r_tail, rev_body)]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `union` (stub: append).
    fn lower_builtin_union(&mut self, list1_expr: &Expr, list2_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_append(list1_expr, list2_expr)
    }

    /// Lower `intersect` (stub).
    fn lower_builtin_intersect(&mut self, list1_expr: &Expr, list2_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(list2_expr)?;
        self.lower_expr(list1_expr)
    }

    /// Lower `scanl :: (b -> a -> b) -> b -> [a] -> [b]`.
    /// Produces a list starting with init, then applying f to accumulator and each element.
    /// Output always starts with init even if input is empty.
    /// Builds result in reverse, then reverses at end.
    fn lower_builtin_scanl(&mut self, func_expr: &Expr, init_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Lower the function closure
        let func_val = self
            .lower_expr(func_expr)?
            .ok_or_else(|| CodegenError::Internal("scanl: function has no value".to_string()))?;
        let func_ptr = match func_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::TypeError(
                    "scanl: function must be a closure".to_string(),
                ))
            }
        };

        // Lower the initial value
        let init_val = self
            .lower_expr(init_expr)?
            .ok_or_else(|| CodegenError::Internal("scanl: init has no value".to_string()))?;
        let init_ptr = self.value_to_ptr(init_val)?;

        // Lower the list
        let list_val = self
            .lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("scanl: list has no value".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("scanl expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "scanl_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "scanl_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "scanl_exit");

        // Build the initial reversed result: cons init onto nil
        // (scanl always starts with init, even for empty input)
        let nil = self.build_nil()?;
        let init_cons = self.build_cons(init_ptr.into(), nil.into())?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop header: phi for acc, list, and reversed result
        self.builder().position_at_end(loop_header);
        let acc_phi = self
            .builder()
            .build_phi(ptr_type, "scanl_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self
            .builder()
            .build_phi(ptr_type, "scanl_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let result_phi = self
            .builder()
            .build_phi(ptr_type, "scanl_result")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        // Check if list is empty
        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                tag,
                tm.i64_type().const_zero(),
                "is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: new_acc = f(acc, head); cons new_acc onto result
        self.builder().position_at_end(loop_body);
        let head_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr =
            self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // Call f(func_ptr, acc, head) - 2-arg closure call
        let fn_ptr = self.extract_closure_fn_ptr(func_ptr)?;
        let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);
        let new_acc = self
            .builder()
            .build_indirect_call(
                fn_type,
                fn_ptr,
                &[
                    func_ptr.into(),
                    acc_phi.as_basic_value().into(),
                    head_ptr.into(),
                ],
                "scanl_new_acc",
            )
            .map_err(|e| CodegenError::Internal(format!("call function: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("scanl: function returned void".to_string()))?;

        let new_acc_ptr = self.value_to_ptr(new_acc)?;

        // Cons new_acc onto the reversed result
        let new_cons = self.build_cons(new_acc_ptr.into(), result_phi.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Add phi incoming values
        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc_ptr, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);
        result_phi.add_incoming(&[(&init_cons, entry_block), (&new_cons, loop_body)]);

        // Exit: reverse the accumulated result
        self.builder().position_at_end(loop_exit);

        // Inline reverse
        let rev_header = self.llvm_ctx.append_basic_block(current_fn, "rev_header");
        let rev_body = self.llvm_ctx.append_basic_block(current_fn, "rev_body");
        let rev_exit = self.llvm_ctx.append_basic_block(current_fn, "rev_exit");

        let nil2 = self.build_nil()?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_header);
        let rev_acc = self
            .builder()
            .build_phi(ptr_type, "rev_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev_list = self
            .builder()
            .build_phi(ptr_type, "rev_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let rev_tag = self.extract_adt_tag(rev_list.as_basic_value().into_pointer_value())?;
        let rev_is_empty = self
            .builder()
            .build_int_compare(
                inkwell::IntPredicate::EQ,
                rev_tag,
                tm.i64_type().const_zero(),
                "rev_is_empty",
            )
            .map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;

        self.builder()
            .build_conditional_branch(rev_is_empty, rev_exit, rev_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev_body);
        let rev_head =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let rev_tail =
            self.extract_adt_field(rev_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let rev_new_cons = self.build_cons(rev_head.into(), rev_acc.as_basic_value())?;

        self.builder()
            .build_unconditional_branch(rev_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev_acc.add_incoming(&[(&nil2, loop_exit), (&rev_new_cons, rev_body)]);
        rev_list.add_incoming(&[(&result_phi.as_basic_value(), loop_exit), (&rev_tail, rev_body)]);

        self.builder().position_at_end(rev_exit);
        Ok(Some(rev_acc.as_basic_value()))
    }

    /// Lower `scanr` (stub).
    fn lower_builtin_scanr(&mut self, func_expr: &Expr, init_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        self.lower_builtin_scanl(func_expr, init_expr, list_expr)
    }

    /// Lower `scanr1` (stub).
    fn lower_builtin_scanr1(&mut self, func_expr: &Expr, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(func_expr)?;
        self.lower_expr(list_expr)
    }

    /// Lower `unfoldr` (stub).
    fn lower_builtin_unfoldr(&mut self, func_expr: &Expr, seed_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(func_expr)?;
        let _ = self.lower_expr(seed_expr)?;
        let nil = self.alloc_adt(0, 0)?;
        Ok(Some(nil.into()))
    }

    /// Lower `lines`  call RTS bhc_string_lines.
    fn lower_builtin_lines(&mut self, str_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let str_val = self.lower_expr(str_expr)?
            .ok_or_else(|| CodegenError::Internal("lines: no string".to_string()))?;
        // Convert [Char] input to C-string for RTS
        let str_ptr = self.value_to_ptr(str_val)?;
        let str_cstr = self.char_list_to_cstring(str_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000176)).ok_or_else(|| {
            CodegenError::Internal("bhc_string_lines not declared".to_string())
        })?;
        let cstr_list = self.builder()
            .build_call(*rts_fn, &[str_cstr.into()], "lines")
            .map_err(|e| CodegenError::Internal(format!("lines call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("lines: returned void".to_string()))?;
        // Convert list of C-strings to list of [Char] lists
        let result = self.cstring_list_to_char_list_list(cstr_list.into_pointer_value())?;
        Ok(Some(result.into()))
    }

    /// Lower `unlines`  call RTS bhc_string_unlines.
    fn lower_builtin_unlines(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("unlines: no list".to_string()))?;
        // Convert list of [Char] lists to list of C-strings for RTS
        let list_ptr = self.value_to_ptr(list_val)?;
        let cstr_list = self.char_list_list_to_cstring_list(list_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000177)).ok_or_else(|| {
            CodegenError::Internal("bhc_string_unlines not declared".to_string())
        })?;
        let cstr_result = self.builder()
            .build_call(*rts_fn, &[cstr_list.into()], "unlines")
            .map_err(|e| CodegenError::Internal(format!("unlines call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("unlines: returned void".to_string()))?;
        // Convert C-string result to [Char] linked list
        let char_list = self.cstring_to_char_list(cstr_result.into_pointer_value())?;
        Ok(Some(char_list.into()))
    }

    /// Lower `words`  call RTS bhc_string_words.
    fn lower_builtin_words(&mut self, str_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let str_val = self.lower_expr(str_expr)?
            .ok_or_else(|| CodegenError::Internal("words: no string".to_string()))?;
        // Convert [Char] input to C-string for RTS
        let str_ptr = self.value_to_ptr(str_val)?;
        let str_cstr = self.char_list_to_cstring(str_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000178)).ok_or_else(|| {
            CodegenError::Internal("bhc_string_words not declared".to_string())
        })?;
        let cstr_list = self.builder()
            .build_call(*rts_fn, &[str_cstr.into()], "words")
            .map_err(|e| CodegenError::Internal(format!("words call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("words: returned void".to_string()))?;
        // Convert list of C-strings to list of [Char] lists
        let result = self.cstring_list_to_char_list_list(cstr_list.into_pointer_value())?;
        Ok(Some(result.into()))
    }

    /// Lower `unwords`  call RTS bhc_string_unwords.
    fn lower_builtin_unwords(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("unwords: no list".to_string()))?;
        // Convert list of [Char] lists to list of C-strings for RTS
        let list_ptr = self.value_to_ptr(list_val)?;
        let cstr_list = self.char_list_list_to_cstring_list(list_ptr)?;
        let rts_fn = self.functions.get(&VarId::new(1000179)).ok_or_else(|| {
            CodegenError::Internal("bhc_string_unwords not declared".to_string())
        })?;
        let cstr_result = self.builder()
            .build_call(*rts_fn, &[cstr_list.into()], "unwords")
            .map_err(|e| CodegenError::Internal(format!("unwords call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("unwords: returned void".to_string()))?;
        // Convert C-string result to [Char] linked list
        let char_list = self.cstring_to_char_list(cstr_result.into_pointer_value())?;
        Ok(Some(char_list.into()))
    }

    /// Lower `zip3` (stub).
    fn lower_builtin_zip3(&mut self, list1: &Expr, list2: &Expr, list3: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(list3)?;
        self.lower_builtin_zip(list1, list2)
    }

    /// Lower `zipWith3` (stub).
    fn lower_builtin_zipwith3(&mut self, func: &Expr, list1: &Expr, list2: &Expr, list3: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let _ = self.lower_expr(list3)?;
        self.lower_builtin_zipwith(func, list1, list2)
    }

    /// Lower `unzip`  split list of pairs into pair of lists.
    /// unzip [(a1,b1), (a2,b2), ...] = ([a1,a2,...], [b1,b2,...])
    fn lower_builtin_unzip(&mut self, list_expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?.ok_or_else(|| CodegenError::Internal("unzip: no list".to_string()))?;
        let list_ptr = match list_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => return Err(CodegenError::TypeError("unzip expects a list".to_string())),
        };

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block().and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;
        let entry_block = self.builder().get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;

        let loop_header = self.llvm_ctx.append_basic_block(current_fn, "unzip_header");
        let loop_body = self.llvm_ctx.append_basic_block(current_fn, "unzip_body");
        let loop_exit = self.llvm_ctx.append_basic_block(current_fn, "unzip_exit");

        let nil = self.build_nil()?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let fsts_phi = self.builder().build_phi(ptr_type, "unzip_fsts")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let snds_phi = self.builder().build_phi(ptr_type, "unzip_snds")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let list_phi = self.builder().build_phi(ptr_type, "unzip_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;

        let tag = self.extract_adt_tag(list_phi.as_basic_value().into_pointer_value())?;
        let is_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(is_empty, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        // Loop body: extract pair from head, split into fst and snd
        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 0)?;
        let tail_ptr = self.extract_adt_field(list_phi.as_basic_value().into_pointer_value(), 2, 1)?;

        // head is a pair ADT (tag=0, arity=2)
        let fst_val = self.extract_adt_field(head_ptr, 2, 0)?;
        let snd_val = self.extract_adt_field(head_ptr, 2, 1)?;

        let fst_cons = self.build_cons(fst_val.into(), fsts_phi.as_basic_value())?;
        let snd_cons = self.build_cons(snd_val.into(), snds_phi.as_basic_value())?;

        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        fsts_phi.add_incoming(&[(&nil, entry_block), (&fst_cons, loop_body)]);
        snds_phi.add_incoming(&[(&nil, entry_block), (&snd_cons, loop_body)]);
        list_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        // Exit: reverse both lists, then build pair
        self.builder().position_at_end(loop_exit);

        // Reverse fsts
        let rev1_header = self.llvm_ctx.append_basic_block(current_fn, "rev1_header");
        let rev1_body = self.llvm_ctx.append_basic_block(current_fn, "rev1_body");
        let rev1_exit = self.llvm_ctx.append_basic_block(current_fn, "rev1_exit");
        let nil2 = self.build_nil()?;
        self.builder().build_unconditional_branch(rev1_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev1_header);
        let rev1_acc = self.builder().build_phi(ptr_type, "rev1_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev1_list = self.builder().build_phi(ptr_type, "rev1_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev1_tag = self.extract_adt_tag(rev1_list.as_basic_value().into_pointer_value())?;
        let rev1_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, rev1_tag, tm.i64_type().const_zero(), "rev1_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(rev1_empty, rev1_exit, rev1_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev1_body);
        let r1_head = self.extract_adt_field(rev1_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let r1_tail = self.extract_adt_field(rev1_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let r1_cons = self.build_cons(r1_head.into(), rev1_acc.as_basic_value())?;
        self.builder().build_unconditional_branch(rev1_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev1_acc.add_incoming(&[(&nil2, loop_exit), (&r1_cons, rev1_body)]);
        rev1_list.add_incoming(&[(&fsts_phi.as_basic_value(), loop_exit), (&r1_tail, rev1_body)]);

        // Reverse snds
        self.builder().position_at_end(rev1_exit);
        let rev2_header = self.llvm_ctx.append_basic_block(current_fn, "rev2_header");
        let rev2_body = self.llvm_ctx.append_basic_block(current_fn, "rev2_body");
        let rev2_exit = self.llvm_ctx.append_basic_block(current_fn, "rev2_exit");
        let nil3 = self.build_nil()?;
        self.builder().build_unconditional_branch(rev2_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev2_header);
        let rev2_acc = self.builder().build_phi(ptr_type, "rev2_acc")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev2_list = self.builder().build_phi(ptr_type, "rev2_list")
            .map_err(|e| CodegenError::Internal(format!("phi: {:?}", e)))?;
        let rev2_tag = self.extract_adt_tag(rev2_list.as_basic_value().into_pointer_value())?;
        let rev2_empty = self.builder().build_int_compare(
            inkwell::IntPredicate::EQ, rev2_tag, tm.i64_type().const_zero(), "rev2_empty",
        ).map_err(|e| CodegenError::Internal(format!("cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(rev2_empty, rev2_exit, rev2_body)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        self.builder().position_at_end(rev2_body);
        let r2_head = self.extract_adt_field(rev2_list.as_basic_value().into_pointer_value(), 2, 0)?;
        let r2_tail = self.extract_adt_field(rev2_list.as_basic_value().into_pointer_value(), 2, 1)?;
        let r2_cons = self.build_cons(r2_head.into(), rev2_acc.as_basic_value())?;
        self.builder().build_unconditional_branch(rev2_header)
            .map_err(|e| CodegenError::Internal(format!("branch: {:?}", e)))?;

        rev2_acc.add_incoming(&[(&nil3, rev1_exit), (&r2_cons, rev2_body)]);
        rev2_list.add_incoming(&[(&snds_phi.as_basic_value(), rev1_exit), (&r2_tail, rev2_body)]);

        // Build result pair
        self.builder().position_at_end(rev2_exit);
        let pair = self.alloc_adt(0, 2)?;
        self.store_adt_field(pair, 2, 0, rev1_acc.as_basic_value())?;
        self.store_adt_field(pair, 2, 1, rev2_acc.as_basic_value())?;

        Ok(Some(pair.into()))
    }

    // ========================================================================
    // Phase 3: Container Operation Handlers (Data.Map, Data.Set, Data.IntMap, Data.IntSet)
    // ========================================================================

    // --- Data.Map handlers ---

    /// Lower `Data.Map.empty` - create empty map.
    fn lower_builtin_map_empty(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[], "map_empty")
            .map_err(|e| CodegenError::Internal(format!("map_empty call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_empty: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.singleton` - create singleton map.
    fn lower_builtin_map_singleton(
        &mut self,
        key_expr: &Expr,
        val_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let key = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_singleton: no key".to_string()))?;
        let val = self.lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("map_singleton: no value".to_string()))?;
        let key_int = self.coerce_to_int(key)?;
        let val_ptr = self.value_to_ptr(val)?;
        let rts_fn = self.functions.get(&VarId::new(1000101)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_singleton not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[key_int.into(), val_ptr.into()], "map_singleton")
            .map_err(|e| CodegenError::Internal(format!("map_singleton call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_singleton: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.null` - check if map is empty.
    fn lower_builtin_map_null(
        &mut self,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_null: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000102)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_null not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[map_ptr.into()], "map_null")
            .map_err(|e| CodegenError::Internal(format!("map_null call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_null: returned void".to_string()))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Map.size` - get map size.
    fn lower_builtin_map_size(
        &mut self,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_size: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000103)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_size not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[map_ptr.into()], "map_size")
            .map_err(|e| CodegenError::Internal(format!("map_size call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_size: returned void".to_string()))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Map.member` - check membership.
    fn lower_builtin_map_member(
        &mut self,
        key_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let key = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_member: no key".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_member: no map".to_string()))?;
        let key_int = self.coerce_to_int(key)?;
        let map_ptr = self.value_to_ptr(map_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000104)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_member not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[key_int.into(), map_ptr.into()], "map_member")
            .map_err(|e| CodegenError::Internal(format!("map_member call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_member: returned void".to_string()))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Map.lookup` - lookup key, returns Maybe.
    fn lower_builtin_map_lookup(
        &mut self,
        key_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let key = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_lookup: no key".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_lookup: no map".to_string()))?;
        let key_int = self.coerce_to_int(key)?;
        let map_ptr = self.value_to_ptr(map_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000105)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_lookup not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[key_int.into(), map_ptr.into()], "map_lookup")
            .map_err(|e| CodegenError::Internal(format!("map_lookup call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_lookup: returned void".to_string()))?;
        // Result is a pointer: null = Nothing, non-null = the value
        // Wrap in Maybe: check for null, construct Just/Nothing ADT
        let result_ptr = result.into_pointer_value();
        let is_null = self.builder()
            .build_is_null(result_ptr, "is_null")
            .map_err(|e| CodegenError::Internal(format!("map_lookup is_null: {:?}", e)))?;
        let nothing = self.alloc_adt(0, 0)?; // Nothing = tag 0, 0 fields
        let just = self.alloc_adt(1, 1)?;    // Just = tag 1, 1 field
        self.store_adt_field(just, 1, 0, result_ptr.into())?;
        let maybe = self.builder()
            .build_select(is_null, nothing, just, "maybe")
            .map_err(|e| CodegenError::Internal(format!("map_lookup select: {:?}", e)))?;
        Ok(Some(maybe))
    }

    /// Lower `Data.Map.findWithDefault` - lookup with default.
    fn lower_builtin_map_find_with_default(
        &mut self,
        default_expr: &Expr,
        key_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let default = self.lower_expr(default_expr)?
            .ok_or_else(|| CodegenError::Internal("map_fwd: no default".to_string()))?;
        let key = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_fwd: no key".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_fwd: no map".to_string()))?;
        let default_ptr = self.value_to_ptr(default)?;
        let key_int = self.coerce_to_int(key)?;
        let map_ptr = self.value_to_ptr(map_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000106)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_find_with_default not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[default_ptr.into(), key_int.into(), map_ptr.into()], "map_fwd")
            .map_err(|e| CodegenError::Internal(format!("map_fwd call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_fwd: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.insert` - insert key-value pair.
    fn lower_builtin_map_insert(
        &mut self,
        key_expr: &Expr,
        val_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let key = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_insert: no key".to_string()))?;
        let val = self.lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("map_insert: no value".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_insert: no map".to_string()))?;
        let key_int = self.coerce_to_int(key)?;
        let val_ptr = self.value_to_ptr(val)?;
        let map_ptr = self.value_to_ptr(map_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[key_int.into(), val_ptr.into(), map_ptr.into()], "map_insert")
            .map_err(|e| CodegenError::Internal(format!("map_insert call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_insert: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.delete` - delete key from map.
    fn lower_builtin_map_delete(
        &mut self,
        key_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let key = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_delete: no key".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_delete: no map".to_string()))?;
        let key_int = self.coerce_to_int(key)?;
        let map_ptr = self.value_to_ptr(map_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000108)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_delete not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[key_int.into(), map_ptr.into()], "map_delete")
            .map_err(|e| CodegenError::Internal(format!("map_delete call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_delete: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.union` - union of two maps.
    fn lower_builtin_map_union(
        &mut self,
        map1_expr: &Expr,
        map2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1 = self.lower_expr(map1_expr)?
            .ok_or_else(|| CodegenError::Internal("map_union: no map1".to_string()))?;
        let m2 = self.lower_expr(map2_expr)?
            .ok_or_else(|| CodegenError::Internal("map_union: no map2".to_string()))?;
        let m1_ptr = self.value_to_ptr(m1)?;
        let m2_ptr = self.value_to_ptr(m2)?;
        let rts_fn = self.functions.get(&VarId::new(1000109)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_union not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[m1_ptr.into(), m2_ptr.into()], "map_union")
            .map_err(|e| CodegenError::Internal(format!("map_union call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_union: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.intersection` - intersection of two maps.
    fn lower_builtin_map_intersection(
        &mut self,
        map1_expr: &Expr,
        map2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1 = self.lower_expr(map1_expr)?
            .ok_or_else(|| CodegenError::Internal("map_intersection: no map1".to_string()))?;
        let m2 = self.lower_expr(map2_expr)?
            .ok_or_else(|| CodegenError::Internal("map_intersection: no map2".to_string()))?;
        let m1_ptr = self.value_to_ptr(m1)?;
        let m2_ptr = self.value_to_ptr(m2)?;
        let rts_fn = self.functions.get(&VarId::new(1000110)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_intersection not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[m1_ptr.into(), m2_ptr.into()], "map_intersection")
            .map_err(|e| CodegenError::Internal(format!("map_intersection call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_intersection: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.difference` - difference of two maps.
    fn lower_builtin_map_difference(
        &mut self,
        map1_expr: &Expr,
        map2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1 = self.lower_expr(map1_expr)?
            .ok_or_else(|| CodegenError::Internal("map_difference: no map1".to_string()))?;
        let m2 = self.lower_expr(map2_expr)?
            .ok_or_else(|| CodegenError::Internal("map_difference: no map2".to_string()))?;
        let m1_ptr = self.value_to_ptr(m1)?;
        let m2_ptr = self.value_to_ptr(m2)?;
        let rts_fn = self.functions.get(&VarId::new(1000111)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_difference not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[m1_ptr.into(), m2_ptr.into()], "map_difference")
            .map_err(|e| CodegenError::Internal(format!("map_difference call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_difference: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Map.isSubmapOf` - check submap.
    fn lower_builtin_map_is_submap_of(
        &mut self,
        map1_expr: &Expr,
        map2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let m1 = self.lower_expr(map1_expr)?
            .ok_or_else(|| CodegenError::Internal("map_isSubmapOf: no map1".to_string()))?;
        let m2 = self.lower_expr(map2_expr)?
            .ok_or_else(|| CodegenError::Internal("map_isSubmapOf: no map2".to_string()))?;
        let m1_ptr = self.value_to_ptr(m1)?;
        let m2_ptr = self.value_to_ptr(m2)?;
        let rts_fn = self.functions.get(&VarId::new(1000112)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_is_submap_of not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[m1_ptr.into(), m2_ptr.into()], "map_is_submap_of")
            .map_err(|e| CodegenError::Internal(format!("map_is_submap_of call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_isSubmapOf: returned void".to_string()))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }


    // ========================================================================
    // Container Higher-Order Operations
    // ========================================================================
    //
    // These iterate over container elements using RTS indexed access,
    // calling closures via indirect LLVM calls.

    /// Lower `Data.Map.map`  applies closure to each value, building new map.
    fn lower_builtin_map_map(
        &mut self,
        fn_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_map: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_map: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Get element count
        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;

        // Start with empty map
        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Extract function pointer from closure
        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mm_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mm_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mm_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: get key and value, apply fn to value, insert (key, new_val)
        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Call closure: fn_ptr(closure, val)
        let mapped_val = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), val.into()], "mapped")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let mapped_ptr = self.value_to_ptr(mapped_val)?;
        let acc_ptr = acc_phi.as_basic_value().into_pointer_value();
        let new_map = self.builder()
            .build_call(insert_fn, &[key_i64.into(), mapped_ptr.into(), acc_ptr.into()], "new_map")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_map, entry_block), (&new_map, loop_body)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.filter`  applies predicate to each value, keeping matches.
    fn lower_builtin_map_filter(
        &mut self,
        fn_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_filter: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_filter: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;

        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mf_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mf_body");
        let loop_insert = self.llvm_context().append_basic_block(current_fn, "mf_insert");
        let loop_skip = self.llvm_context().append_basic_block(current_fn, "mf_skip");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mf_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Call predicate: fn_ptr(closure, val) -> Bool (tag 0=False, 1=True)
        let pred_result = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), val.into()], "pred")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        // Check if predicate returned True (non-zero tag)
        let pred_ptr = self.value_to_ptr(pred_result)?;
        let pred_tag = self.extract_adt_tag(pred_ptr)?;
        let is_true = self.builder()
            .build_int_compare(inkwell::IntPredicate::NE, pred_tag, tm.i64_type().const_zero(), "is_true")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_true, loop_insert, loop_skip)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Insert branch: add (key, val) to accumulator map
        self.builder().position_at_end(loop_insert);
        let val_ptr = self.value_to_ptr(val)?;
        let acc_ptr_ins = acc_phi.as_basic_value().into_pointer_value();
        let inserted = self.builder()
            .build_call(insert_fn, &[key_i64.into(), val_ptr.into(), acc_ptr_ins.into()], "inserted")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(loop_skip)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Skip/merge block
        self.builder().position_at_end(loop_skip);
        let merge_phi = self.builder().build_phi(ptr_type, "merge_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        merge_phi.add_incoming(&[(&inserted, loop_insert), (&acc_phi.as_basic_value(), loop_body)]);

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_map, entry_block), (&merge_phi.as_basic_value(), loop_skip)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_skip)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.foldr`  right fold over map values.
    fn lower_builtin_map_foldr(
        &mut self,
        fn_expr: &Expr,
        init_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldr: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let init_val = self.lower_expr(init_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldr: no init".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldr: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        // foldr fn takes 2 args: value, accumulator
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);

        // Iterate backwards for right fold
        let loop_header = self.llvm_context().append_basic_block(current_fn, "mfr_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mfr_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mfr_exit");

        let start_idx = self.builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "start_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;

        let init_ptr = self.value_to_ptr(init_val)?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SLT, idx, tm.i64_type().const_zero(), "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Call closure: fn_ptr(closure, val, acc)
        let acc_val = acc_phi.as_basic_value();
        let new_acc = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), val.into(), acc_val.into()], "new_acc")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let new_idx = self.builder()
            .build_int_sub(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&start_idx, entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.foldl'`  strict left fold over map values.
    fn lower_builtin_map_foldl(
        &mut self,
        fn_expr: &Expr,
        init_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldl: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let init_val = self.lower_expr(init_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldl: no init".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldl: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        // foldl fn takes 2 args: accumulator, value
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mfl_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mfl_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mfl_exit");

        let init_ptr = self.value_to_ptr(init_val)?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Call closure: fn_ptr(closure, acc, val)
        let acc_val = acc_phi.as_basic_value();
        let new_acc = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), acc_val.into(), val.into()], "new_acc")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Set.map`  applies closure to each element, building new set.
    fn lower_builtin_set_map(
        &mut self,
        fn_expr: &Expr,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("set_map: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_map: no set".to_string()))?;
        let set_ptr = self.value_to_ptr(set_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000163)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[set_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let elem_at_fn = *self.functions.get(&VarId::new(1000164)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000125)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_insert not declared".to_string())
        })?;

        let empty_fn = self.functions.get(&VarId::new(1000120)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_empty not declared".to_string())
        })?;
        let empty_set = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "sm_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "sm_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "sm_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let elem_i64 = self.builder()
            .build_call(elem_at_fn, &[set_ptr.into(), idx.into()], "elem")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let elem_ptr = self.int_to_ptr(elem_i64)?;

        // Call closure: fn_ptr(closure, elem)
        let mapped_val = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), elem_ptr.into()], "mapped")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let mapped_int = self.coerce_to_int(mapped_val)?;
        let acc_ptr = acc_phi.as_basic_value().into_pointer_value();
        let new_set = self.builder()
            .build_call(insert_fn, &[mapped_int.into(), acc_ptr.into()], "new_set")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_set, entry_block), (&new_set, loop_body)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Set.filter`  applies predicate, keeping matching elements.
    fn lower_builtin_set_filter(
        &mut self,
        fn_expr: &Expr,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("set_filter: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_filter: no set".to_string()))?;
        let set_ptr = self.value_to_ptr(set_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000163)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[set_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let elem_at_fn = *self.functions.get(&VarId::new(1000164)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000125)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_insert not declared".to_string())
        })?;

        let empty_fn = self.functions.get(&VarId::new(1000120)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_empty not declared".to_string())
        })?;
        let empty_set = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "sf_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "sf_body");
        let loop_insert = self.llvm_context().append_basic_block(current_fn, "sf_insert");
        let loop_skip = self.llvm_context().append_basic_block(current_fn, "sf_skip");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "sf_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let elem_i64 = self.builder()
            .build_call(elem_at_fn, &[set_ptr.into(), idx.into()], "elem")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let elem_ptr = self.int_to_ptr(elem_i64)?;

        // Call predicate: fn_ptr(closure, elem)
        let pred_result = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), elem_ptr.into()], "pred")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let pred_ptr = self.value_to_ptr(pred_result)?;
        let pred_tag = self.extract_adt_tag(pred_ptr)?;
        let is_true = self.builder()
            .build_int_compare(inkwell::IntPredicate::NE, pred_tag, tm.i64_type().const_zero(), "is_true")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_true, loop_insert, loop_skip)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_insert);
        let acc_ptr_ins = acc_phi.as_basic_value().into_pointer_value();
        let inserted = self.builder()
            .build_call(insert_fn, &[elem_i64.into(), acc_ptr_ins.into()], "inserted")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(loop_skip)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_skip);
        let merge_phi = self.builder().build_phi(ptr_type, "merge_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        merge_phi.add_incoming(&[(&inserted, loop_insert), (&acc_phi.as_basic_value(), loop_body)]);

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_set, entry_block), (&merge_phi.as_basic_value(), loop_skip)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_skip)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Set.foldr`  right fold over set elements.
    fn lower_builtin_set_foldr(
        &mut self,
        fn_expr: &Expr,
        init_expr: &Expr,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("set_foldr: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let init_val = self.lower_expr(init_expr)?
            .ok_or_else(|| CodegenError::Internal("set_foldr: no init".to_string()))?;
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_foldr: no set".to_string()))?;
        let set_ptr = self.value_to_ptr(set_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000163)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[set_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let elem_at_fn = *self.functions.get(&VarId::new(1000164)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_at not declared".to_string())
        })?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "sfr_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "sfr_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "sfr_exit");

        let start_idx = self.builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "start_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;

        let init_ptr = self.value_to_ptr(init_val)?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SLT, idx, tm.i64_type().const_zero(), "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let elem_i64 = self.builder()
            .build_call(elem_at_fn, &[set_ptr.into(), idx.into()], "elem")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let elem_ptr = self.int_to_ptr(elem_i64)?;

        let acc_val = acc_phi.as_basic_value();
        let new_acc = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), elem_ptr.into(), acc_val.into()], "new_acc")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let new_idx = self.builder()
            .build_int_sub(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&start_idx, entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Set.foldl'`  strict left fold over set elements.
    fn lower_builtin_set_foldl(
        &mut self,
        fn_expr: &Expr,
        init_expr: &Expr,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("set_foldl: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let init_val = self.lower_expr(init_expr)?
            .ok_or_else(|| CodegenError::Internal("set_foldl: no init".to_string()))?;
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_foldl: no set".to_string()))?;
        let set_ptr = self.value_to_ptr(set_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000163)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[set_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let elem_at_fn = *self.functions.get(&VarId::new(1000164)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_at not declared".to_string())
        })?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "sfl_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "sfl_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "sfl_exit");

        let init_ptr = self.value_to_ptr(init_val)?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let elem_i64 = self.builder()
            .build_call(elem_at_fn, &[set_ptr.into(), idx.into()], "elem")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let elem_ptr = self.int_to_ptr(elem_i64)?;

        let acc_val = acc_phi.as_basic_value();
        let new_acc = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), acc_val.into(), elem_ptr.into()], "new_acc")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }


    /// Lower `Data.Map.mapWithKey` -- applies closure(key, val) to each entry, building new map.
    /// mapWithKey :: (k -> v -> v') -> Map k v -> Map k v'
    fn lower_builtin_map_map_with_key(
        &mut self,
        fn_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_mapWithKey: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_mapWithKey: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Get element count
        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;

        // Start with empty map
        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Extract function pointer from closure; 2 args: key, val
        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mmwk_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mmwk_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mmwk_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: get key and value, apply fn to (key, value), insert (key, new_val)
        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Convert key i64 to ptr for closure call
        let key_ptr = self.int_to_ptr(key_i64)?;

        // Call closure: fn_ptr(closure, key_ptr, val)
        let mapped_val = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), key_ptr.into(), val.into()], "mapped")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let mapped_ptr = self.value_to_ptr(mapped_val)?;
        let acc_ptr = acc_phi.as_basic_value().into_pointer_value();
        let new_map = self.builder()
            .build_call(insert_fn, &[key_i64.into(), mapped_ptr.into(), acc_ptr.into()], "new_map")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_map, entry_block), (&new_map, loop_body)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.filterWithKey` -- applies predicate(key, val), keeping matches.
    /// filterWithKey :: (k -> v -> Bool) -> Map k v -> Map k v
    fn lower_builtin_map_filter_with_key(
        &mut self,
        fn_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_filterWithKey: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_filterWithKey: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;

        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // 2-arg closure: (key, val)
        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mfwk_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mfwk_body");
        let loop_insert = self.llvm_context().append_basic_block(current_fn, "mfwk_insert");
        let loop_skip = self.llvm_context().append_basic_block(current_fn, "mfwk_skip");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mfwk_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let key_ptr = self.int_to_ptr(key_i64)?;

        // Call predicate: fn_ptr(closure, key_ptr, val) -> Bool (tag 0=False, 1=True)
        let pred_result = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), key_ptr.into(), val.into()], "pred")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        // Check if predicate returned True (non-zero tag)
        let pred_ptr = self.value_to_ptr(pred_result)?;
        let pred_tag = self.extract_adt_tag(pred_ptr)?;
        let is_true = self.builder()
            .build_int_compare(inkwell::IntPredicate::NE, pred_tag, tm.i64_type().const_zero(), "is_true")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_true, loop_insert, loop_skip)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Insert branch: add (key, val) to accumulator map
        self.builder().position_at_end(loop_insert);
        let val_ptr = self.value_to_ptr(val)?;
        let acc_ptr_ins = acc_phi.as_basic_value().into_pointer_value();
        let inserted = self.builder()
            .build_call(insert_fn, &[key_i64.into(), val_ptr.into(), acc_ptr_ins.into()], "inserted")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(loop_skip)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Skip/merge block
        self.builder().position_at_end(loop_skip);
        let merge_phi = self.builder().build_phi(ptr_type, "merge_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        merge_phi.add_incoming(&[(&inserted, loop_insert), (&acc_phi.as_basic_value(), loop_body)]);

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_map, entry_block), (&merge_phi.as_basic_value(), loop_skip)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_skip)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.foldlWithKey'` -- strict left fold with key.
    /// foldlWithKey' :: (a -> k -> v -> a) -> a -> Map k v -> a
    fn lower_builtin_map_foldl_with_key(
        &mut self,
        fn_expr: &Expr,
        init_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldlWithKey: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let init_val = self.lower_expr(init_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldlWithKey: no init".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldlWithKey: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        // foldlWithKey takes 3 args: acc, key, val
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mflwk_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mflwk_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mflwk_exit");

        let init_ptr = self.value_to_ptr(init_val)?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let key_ptr = self.int_to_ptr(key_i64)?;

        // Call closure: fn_ptr(closure, acc, key_ptr, val)
        let acc_val = acc_phi.as_basic_value();
        let new_acc = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), acc_val.into(), key_ptr.into(), val.into()], "new_acc")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.foldrWithKey` -- right fold with key.
    /// foldrWithKey :: (k -> v -> a -> a) -> a -> Map k v -> a
    fn lower_builtin_map_foldr_with_key(
        &mut self,
        fn_expr: &Expr,
        init_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldrWithKey: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let init_val = self.lower_expr(init_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldrWithKey: no init".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_foldrWithKey: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        // foldrWithKey takes 3 args: key, val, acc
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        // Iterate backwards for right fold
        let loop_header = self.llvm_context().append_basic_block(current_fn, "mfrwk_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mfrwk_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mfrwk_exit");

        let start_idx = self.builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "start_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;

        let init_ptr = self.value_to_ptr(init_val)?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SLT, idx, tm.i64_type().const_zero(), "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let key_ptr = self.int_to_ptr(key_i64)?;

        // Call closure: fn_ptr(closure, key_ptr, val, acc)
        let acc_val = acc_phi.as_basic_value();
        let new_acc = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), key_ptr.into(), val.into(), acc_val.into()], "new_acc")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        let new_idx = self.builder()
            .build_int_sub(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&init_ptr, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&start_idx, entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.unionWith` -- union of two maps with combining function.
    /// unionWith :: (v -> v -> v) -> Map k v -> Map k v -> Map k v
    fn lower_builtin_map_union_with(
        &mut self,
        fn_expr: &Expr,
        map1_expr: &Expr,
        map2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_unionWith: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map1_val = self.lower_expr(map1_expr)?
            .ok_or_else(|| CodegenError::Internal("map_unionWith: no map1".to_string()))?;
        let map1_ptr = self.value_to_ptr(map1_val)?;
        let map2_val = self.lower_expr(map2_expr)?
            .ok_or_else(|| CodegenError::Internal("map_unionWith: no map2".to_string()))?;
        let map2_ptr = self.value_to_ptr(map2_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = *self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;
        let lookup_fn = *self.functions.get(&VarId::new(1000105)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_lookup not declared".to_string())
        })?;

        // Start with result = map1 (copy all of map1 first by iterating it)
        // Actually, we can start by copying map1 entries into a fresh map,
        // then iterate map2. But simpler: just start with map1 as the accumulator
        // and iterate map2, since insert overwrites.
        // However, unionWith prefers left values, so we need to check.

        // Get count of map2
        let count2 = self.builder()
            .build_call(count_fn, &[map2_ptr.into()], "count2")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        // 2-arg closure: (v1, v2)
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        let loop_header = self.llvm_context().append_basic_block(current_fn, "muw_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "muw_body");
        let found_block = self.llvm_context().append_basic_block(current_fn, "muw_found");
        let not_found_block = self.llvm_context().append_basic_block(current_fn, "muw_notfound");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "muw_merge");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "muw_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop header: iterate over map2
        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count2, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: get key/val from map2, lookup in result (which starts as map1)
        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map2_ptr.into(), idx.into()], "key2")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val2 = self.builder()
            .build_call(val_at_fn, &[map2_ptr.into(), idx.into()], "val2")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Lookup key in accumulator (result map, initially map1)
        let acc_ptr = acc_phi.as_basic_value().into_pointer_value();
        let found_val = self.builder()
            .build_call(lookup_fn, &[key_i64.into(), acc_ptr.into()], "lookup")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_pointer_value();

        let is_null = self.builder()
            .build_is_null(found_val, "is_null")
            .map_err(|e| CodegenError::Internal(format!("is_null failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_null, not_found_block, found_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Found: call closure(found_val, val2), insert result
        self.builder().position_at_end(found_block);
        let val2_ptr = self.value_to_ptr(val2)?;
        let combined = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), found_val.into(), val2_ptr.into()], "combined")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;
        let combined_ptr = self.value_to_ptr(combined)?;
        let new_map_found = self.builder()
            .build_call(insert_fn, &[key_i64.into(), combined_ptr.into(), acc_ptr.into()], "ins_found")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Not found: just insert (key, val2)
        self.builder().position_at_end(not_found_block);
        let val2_ptr_nf = self.value_to_ptr(val2)?;
        let new_map_nf = self.builder()
            .build_call(insert_fn, &[key_i64.into(), val2_ptr_nf.into(), acc_ptr.into()], "ins_nf")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Merge block
        self.builder().position_at_end(merge_block);
        let merge_phi = self.builder().build_phi(ptr_type, "merge_map")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        merge_phi.add_incoming(&[(&new_map_found, found_block), (&new_map_nf, not_found_block)]);

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&map1_ptr, entry_block), (&merge_phi.as_basic_value(), merge_block)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, merge_block)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.intersectionWith` -- intersection with combining function.
    /// intersectionWith :: (a -> b -> c) -> Map k a -> Map k b -> Map k c
    fn lower_builtin_map_intersection_with(
        &mut self,
        fn_expr: &Expr,
        map1_expr: &Expr,
        map2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_intersectionWith: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map1_val = self.lower_expr(map1_expr)?
            .ok_or_else(|| CodegenError::Internal("map_intersectionWith: no map1".to_string()))?;
        let map1_ptr = self.value_to_ptr(map1_val)?;
        let map2_val = self.lower_expr(map2_expr)?
            .ok_or_else(|| CodegenError::Internal("map_intersectionWith: no map2".to_string()))?;
        let map2_ptr = self.value_to_ptr(map2_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = *self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;
        let lookup_fn = *self.functions.get(&VarId::new(1000105)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_lookup not declared".to_string())
        })?;
        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;

        // Start with empty result
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Get count of map1
        let count1 = self.builder()
            .build_call(count_fn, &[map1_ptr.into()], "count1")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        let loop_header = self.llvm_context().append_basic_block(current_fn, "miw_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "miw_body");
        let found_block = self.llvm_context().append_basic_block(current_fn, "miw_found");
        let skip_block = self.llvm_context().append_basic_block(current_fn, "miw_skip");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "miw_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop header: iterate over map1
        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count1, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: get key/val from map1, lookup in map2
        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map1_ptr.into(), idx.into()], "key1")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val1 = self.builder()
            .build_call(val_at_fn, &[map1_ptr.into(), idx.into()], "val1")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Lookup key in map2
        let found_val = self.builder()
            .build_call(lookup_fn, &[key_i64.into(), map2_ptr.into()], "lookup2")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_pointer_value();

        let is_null = self.builder()
            .build_is_null(found_val, "is_null")
            .map_err(|e| CodegenError::Internal(format!("is_null failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_null, skip_block, found_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Found: call closure(val1, found_val), insert into result
        self.builder().position_at_end(found_block);
        let val1_ptr = self.value_to_ptr(val1)?;
        let combined = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), val1_ptr.into(), found_val.into()], "combined")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;
        let combined_ptr = self.value_to_ptr(combined)?;
        let acc_ptr_found = acc_phi.as_basic_value().into_pointer_value();
        let new_map_found = self.builder()
            .build_call(insert_fn, &[key_i64.into(), combined_ptr.into(), acc_ptr_found.into()], "ins_found")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(skip_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Skip/merge block
        self.builder().position_at_end(skip_block);
        let merge_phi = self.builder().build_phi(ptr_type, "merge_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        merge_phi.add_incoming(&[(&new_map_found, found_block), (&acc_phi.as_basic_value(), loop_body)]);

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_map, entry_block), (&merge_phi.as_basic_value(), skip_block)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, skip_block)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.differenceWith` -- difference with combining function.
    /// differenceWith :: (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
    fn lower_builtin_map_difference_with(
        &mut self,
        fn_expr: &Expr,
        map1_expr: &Expr,
        map2_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_differenceWith: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map1_val = self.lower_expr(map1_expr)?
            .ok_or_else(|| CodegenError::Internal("map_differenceWith: no map1".to_string()))?;
        let map1_ptr = self.value_to_ptr(map1_val)?;
        let map2_val = self.lower_expr(map2_expr)?
            .ok_or_else(|| CodegenError::Internal("map_differenceWith: no map2".to_string()))?;
        let map2_ptr = self.value_to_ptr(map2_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = *self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;
        let lookup_fn = *self.functions.get(&VarId::new(1000105)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_lookup not declared".to_string())
        })?;
        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;

        // Start with empty result
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Get count of map1
        let count1 = self.builder()
            .build_call(count_fn, &[map1_ptr.into()], "count1")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mdw_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mdw_body");
        let found_block = self.llvm_context().append_basic_block(current_fn, "mdw_found");
        let just_block = self.llvm_context().append_basic_block(current_fn, "mdw_just");
        let not_found_block = self.llvm_context().append_basic_block(current_fn, "mdw_notfound");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "mdw_merge");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mdw_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop header: iterate over map1
        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count1, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: get key/val from map1, lookup in map2
        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map1_ptr.into(), idx.into()], "key1")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val1 = self.builder()
            .build_call(val_at_fn, &[map1_ptr.into(), idx.into()], "val1")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Lookup key in map2
        let found_val = self.builder()
            .build_call(lookup_fn, &[key_i64.into(), map2_ptr.into()], "lookup2")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_pointer_value();

        let is_null = self.builder()
            .build_is_null(found_val, "is_null")
            .map_err(|e| CodegenError::Internal(format!("is_null failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_null, not_found_block, found_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Found in map2: call closure(val1, val2) -> Maybe a
        self.builder().position_at_end(found_block);
        let val1_ptr = self.value_to_ptr(val1)?;
        let maybe_result = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), val1_ptr.into(), found_val.into()], "maybe_result")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        // Check Maybe tag: 0 = Nothing, 1 = Just
        let maybe_ptr = self.value_to_ptr(maybe_result)?;
        let maybe_tag = self.extract_adt_tag(maybe_ptr)?;
        let is_just = self.builder()
            .build_int_compare(inkwell::IntPredicate::NE, maybe_tag, tm.i64_type().const_zero(), "is_just")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_just, just_block, merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Just: extract value from Just, insert into result
        self.builder().position_at_end(just_block);
        let just_val = self.extract_adt_field(maybe_ptr, 1, 0)?;
        let acc_ptr_just = acc_phi.as_basic_value().into_pointer_value();
        let new_map_just = self.builder()
            .build_call(insert_fn, &[key_i64.into(), just_val.into(), acc_ptr_just.into()], "ins_just")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Not found in map2: insert (key, val1) directly
        self.builder().position_at_end(not_found_block);
        let val1_ptr_nf = self.value_to_ptr(val1)?;
        let acc_ptr_nf = acc_phi.as_basic_value().into_pointer_value();
        let new_map_nf = self.builder()
            .build_call(insert_fn, &[key_i64.into(), val1_ptr_nf.into(), acc_ptr_nf.into()], "ins_nf")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Merge block: phi for the three incoming edges (just, nothing/found, not_found)
        self.builder().position_at_end(merge_block);
        let merge_phi = self.builder().build_phi(ptr_type, "merge_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        merge_phi.add_incoming(&[
            (&new_map_just, just_block),
            (&acc_phi.as_basic_value(), found_block),  // Nothing case: no change
            (&new_map_nf, not_found_block),
        ]);

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_map, entry_block), (&merge_phi.as_basic_value(), merge_block)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, merge_block)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.insertWith` -- insert with combining function.
    /// insertWith :: (v -> v -> v) -> k -> v -> Map k v -> Map k v
    fn lower_builtin_map_insert_with(
        &mut self,
        fn_expr: &Expr,
        key_expr: &Expr,
        val_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_insertWith: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let key_val = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_insertWith: no key".to_string()))?;
        let new_val = self.lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("map_insertWith: no value".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_insertWith: no map".to_string()))?;

        let key_int = self.coerce_to_int(key_val)?;
        let new_ptr = self.value_to_ptr(new_val)?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;
        let lookup_fn = *self.functions.get(&VarId::new(1000105)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_lookup not declared".to_string())
        })?;

        // Lookup key in map
        let found_val = self.builder()
            .build_call(lookup_fn, &[key_int.into(), map_ptr.into()], "lookup")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_pointer_value();

        let is_null = self.builder()
            .build_is_null(found_val, "is_null")
            .map_err(|e| CodegenError::Internal(format!("is_null failed: {:?}", e)))?;

        let found_block = self.llvm_context().append_basic_block(current_fn, "iw_found");
        let not_found_block = self.llvm_context().append_basic_block(current_fn, "iw_notfound");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "iw_merge");

        self.builder().build_conditional_branch(is_null, not_found_block, found_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Found: call closure(new_val, old_val), insert result
        self.builder().position_at_end(found_block);
        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );
        let combined = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), new_ptr.into(), found_val.into()], "combined")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;
        let combined_ptr = self.value_to_ptr(combined)?;
        let new_map_found = self.builder()
            .build_call(insert_fn, &[key_int.into(), combined_ptr.into(), map_ptr.into()], "ins_found")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Not found: insert (key, new_val) directly
        self.builder().position_at_end(not_found_block);
        let new_map_nf = self.builder()
            .build_call(insert_fn, &[key_int.into(), new_ptr.into(), map_ptr.into()], "ins_nf")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Merge
        self.builder().position_at_end(merge_block);
        let result_phi = self.builder().build_phi(ptr_type, "result")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        result_phi.add_incoming(&[(&new_map_found, found_block), (&new_map_nf, not_found_block)]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `Data.Map.adjust` -- adjust value at key with function.
    /// adjust :: (v -> v) -> k -> Map k v -> Map k v
    fn lower_builtin_map_adjust(
        &mut self,
        fn_expr: &Expr,
        key_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_adjust: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let key_val = self.lower_expr(key_expr)?
            .ok_or_else(|| CodegenError::Internal("map_adjust: no key".to_string()))?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_adjust: no map".to_string()))?;

        let key_int = self.coerce_to_int(key_val)?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;
        let delete_fn = *self.functions.get(&VarId::new(1000108)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_delete not declared".to_string())
        })?;
        let lookup_fn = *self.functions.get(&VarId::new(1000105)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_lookup not declared".to_string())
        })?;

        // Lookup key in map
        let found_val = self.builder()
            .build_call(lookup_fn, &[key_int.into(), map_ptr.into()], "lookup")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_pointer_value();

        let is_null = self.builder()
            .build_is_null(found_val, "is_null")
            .map_err(|e| CodegenError::Internal(format!("is_null failed: {:?}", e)))?;

        let found_block = self.llvm_context().append_basic_block(current_fn, "adj_found");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "adj_merge");

        self.builder().build_conditional_branch(is_null, merge_block, found_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();

        // Found: call closure(old_val), delete key, insert (key, result)
        self.builder().position_at_end(found_block);
        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into()],
            false,
        );
        let adjusted = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), found_val.into()], "adjusted")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;
        let adjusted_ptr = self.value_to_ptr(adjusted)?;

        // Delete old key, then insert with new value
        let deleted_map = self.builder()
            .build_call(delete_fn, &[key_int.into(), map_ptr.into()], "deleted")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        let deleted_ptr = self.value_to_ptr(deleted_map)?;
        let new_map = self.builder()
            .build_call(insert_fn, &[key_int.into(), adjusted_ptr.into(), deleted_ptr.into()], "ins_adj")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Merge: if not found, return original map; if found, return adjusted map
        self.builder().position_at_end(merge_block);
        let result_phi = self.builder().build_phi(ptr_type, "result")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        result_phi.add_incoming(&[(&map_ptr, entry_block), (&new_map, found_block)]);

        Ok(Some(result_phi.as_basic_value()))
    }

    /// Lower `Data.Map.mapKeys` -- apply function to all keys, building new map.
    /// mapKeys :: (k -> k') -> Map k v -> Map k' v
    fn lower_builtin_map_map_keys(
        &mut self,
        fn_expr: &Expr,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_mapKeys: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_mapKeys: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;
        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;

        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // 1-arg closure: (key) -> new_key
        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mmk_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mmk_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mmk_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, idx, count, "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        // Convert key i64 to ptr, call closure(key_ptr) -> new_key_ptr
        let key_ptr = self.int_to_ptr(key_i64)?;
        let new_key = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), key_ptr.into()], "new_key")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;

        // Convert new key back to i64 for map insert
        let new_key_int = self.coerce_to_int(new_key)?;
        let val_ptr = self.value_to_ptr(val)?;
        let acc_ptr = acc_phi.as_basic_value().into_pointer_value();
        let new_map = self.builder()
            .build_call(insert_fn, &[new_key_int.into(), val_ptr.into(), acc_ptr.into()], "new_map")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let new_idx = self.builder()
            .build_int_add(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("add failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&empty_map, entry_block), (&new_map, loop_body)]);
        idx_phi.add_incoming(&[(&tm.i64_type().const_zero(), entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.fromListWith` -- build map from list with combining function.
    /// fromListWith :: (v -> v -> v) -> [(k,v)] -> Map k v
    fn lower_builtin_map_from_list_with(
        &mut self,
        fn_expr: &Expr,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let fn_val = self.lower_expr(fn_expr)?
            .ok_or_else(|| CodegenError::Internal("map_fromListWith: no function".to_string()))?;
        let fn_ptr = self.value_to_ptr(fn_val)?;
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("map_fromListWith: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Start with empty map
        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty_map")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;
        let lookup_fn = *self.functions.get(&VarId::new(1000105)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_lookup not declared".to_string())
        })?;

        let closure_fn_ptr = self.extract_closure_fn_ptr(fn_ptr)?;
        let call_fn_type = ptr_type.fn_type(
            &[ptr_type.into(), ptr_type.into(), ptr_type.into()],
            false,
        );

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mflw_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mflw_body");
        let found_block = self.llvm_context().append_basic_block(current_fn, "mflw_found");
        let not_found_block = self.llvm_context().append_basic_block(current_fn, "mflw_notfound");
        let merge_block = self.llvm_context().append_basic_block(current_fn, "mflw_merge");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mflw_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop header: traverse the list
        self.builder().position_at_end(loop_header);
        let map_phi = self.builder().build_phi(ptr_type, "map_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let cur_phi = self.builder().build_phi(ptr_type, "cur_list")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        // Check if current list is nil (tag == 0)
        let cur_ptr = cur_phi.as_basic_value().into_pointer_value();
        let tag = self.builder()
            .build_load(tm.i64_type(), cur_ptr, "tag")
            .map_err(|e| CodegenError::Internal(format!("load tag failed: {:?}", e)))?
            .into_int_value();
        let is_nil = self.builder()
            .build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_nil")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_nil, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: extract (key, value) pair from head
        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(cur_ptr, 2, 0)?;
        let tail_ptr = self.extract_adt_field(cur_ptr, 2, 1)?;

        // Pair is an ADT with (key, value)
        let key_ptr = self.extract_adt_field(head_ptr, 2, 0)?;
        let val_ptr = self.extract_adt_field(head_ptr, 2, 1)?;
        let key_int = self.coerce_to_int(key_ptr.into())?;

        // Lookup key in current map
        let map_acc_ptr = map_phi.as_basic_value().into_pointer_value();
        let found_val = self.builder()
            .build_call(lookup_fn, &[key_int.into(), map_acc_ptr.into()], "lookup")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_pointer_value();

        let is_null = self.builder()
            .build_is_null(found_val, "is_null")
            .map_err(|e| CodegenError::Internal(format!("is_null failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_null, not_found_block, found_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Found: call closure(new_val, old_val), insert combined
        self.builder().position_at_end(found_block);
        let combined = self.builder()
            .build_indirect_call(call_fn_type, closure_fn_ptr, &[fn_ptr.into(), val_ptr.into(), found_val.into()], "combined")
            .map_err(|e| CodegenError::Internal(format!("indirect call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("closure returned void".to_string()))?;
        let combined_ptr = self.value_to_ptr(combined)?;
        let new_map_found = self.builder()
            .build_call(insert_fn, &[key_int.into(), combined_ptr.into(), map_acc_ptr.into()], "ins_found")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Not found: insert (key, val) directly
        self.builder().position_at_end(not_found_block);
        let new_map_nf = self.builder()
            .build_call(insert_fn, &[key_int.into(), val_ptr.into(), map_acc_ptr.into()], "ins_nf")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;
        self.builder().build_unconditional_branch(merge_block)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Merge
        self.builder().position_at_end(merge_block);
        let merge_phi = self.builder().build_phi(ptr_type, "merge_map")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        merge_phi.add_incoming(&[(&new_map_found, found_block), (&new_map_nf, not_found_block)]);

        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        map_phi.add_incoming(&[(&empty_map, entry_block), (&merge_phi.as_basic_value(), merge_block)]);
        cur_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, merge_block)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(map_phi.as_basic_value()))
    }

    /// Lower container operations that need higher-order functions (stub).
    /// Covers: update, alter, unions (remaining unimplemented operations).
    fn lower_builtin_container_ho_stub(
        &mut self,
        args: &[&Expr],
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Evaluate all arguments (for side effects / forcing)
        for arg in args {
            let _ = self.lower_expr(arg)?;
        }
        // For operations that return containers, return the last container arg
        // For operations that return values, return null
        if let Some(last) = args.last() {
            self.lower_expr(last)
        } else {
            Ok(Some(self.type_mapper().ptr_type().const_null().into()))
        }
    }

    /// Lower `Data.Map.toList` / `toAscList` / `toDescList` / `assocs` / `keys` / `elems`.
    /// Builds a list from the container using iteration RTS functions.
    fn lower_builtin_map_to_list(
        &mut self,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_toList: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Get element count
        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "map_count")
            .map_err(|e| CodegenError::Internal(format!("map_count call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("map_count: returned void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;
        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;

        // Build list backwards: iterate from (count-1) down to 0, consing (key,value) tuples
        let loop_header = self.llvm_context().append_basic_block(current_fn, "mtl_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mtl_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mtl_exit");

        let nil = self.build_nil()?;
        let start_idx = self.builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "start_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop header with PHI nodes
        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SLT, idx, tm.i64_type().const_zero(), "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: get key and value at index, build (key, value) tuple, cons onto acc
        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("key_at call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("key_at: void".to_string()))?
            .into_int_value();
        let val_ptr = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("val_at call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("val_at: void".to_string()))?;

        // Build a (key, value) pair as a 2-tuple ADT (tag=0, arity=2)
        let key_ptr = self.int_to_ptr(key_i64)?;
        let pair = self.alloc_adt(0, 2)?;
        self.store_adt_field(pair, 2, 0, key_ptr.into())?;
        self.store_adt_field(pair, 2, 1, val_ptr)?;

        // Cons pair onto accumulator
        let new_acc = self.build_cons(pair.into(), acc_phi.as_basic_value())?;
        let new_idx = self.builder()
            .build_int_sub(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&start_idx, entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.fromList`  iterates the list, inserting each (k,v) pair.
    fn lower_builtin_map_from_list(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("map_fromList: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;

        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Start with empty map
        let empty_fn = self.functions.get(&VarId::new(1000100)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_empty not declared".to_string())
        })?;
        let empty_map = self.builder()
            .build_call(*empty_fn, &[], "empty_map")
            .map_err(|e| CodegenError::Internal(format!("empty call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("empty: void".to_string()))?;

        let insert_fn = *self.functions.get(&VarId::new(1000107)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_insert not declared".to_string())
        })?;

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mfl_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mfl_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mfl_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop header
        self.builder().position_at_end(loop_header);
        let map_phi = self.builder().build_phi(tm.ptr_type(), "map_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let cur_phi = self.builder().build_phi(tm.ptr_type(), "cur_list")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        // Check if current list is nil (tag == 0)
        let cur_ptr = cur_phi.as_basic_value().into_pointer_value();
        let tag = self.builder()
            .build_load(tm.i64_type(), cur_ptr, "tag")
            .map_err(|e| CodegenError::Internal(format!("load tag failed: {:?}", e)))?
            .into_int_value();
        let is_nil = self.builder()
            .build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_nil")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_nil, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: extract (key, value) pair from head, insert into map
        self.builder().position_at_end(loop_body);
        // head = field 0 of cons cell (a pair)
        let head_ptr = self.extract_adt_field(cur_ptr, 2, 0)?;
        // tail = field 1 of cons cell
        let tail_ptr = self.extract_adt_field(cur_ptr, 2, 1)?;

        // pair is an ADT with (key, value)  extract key (field 0) and value (field 1)
        let key_ptr = self.extract_adt_field(head_ptr, 2, 0)?;
        let val_ptr = self.extract_adt_field(head_ptr, 2, 1)?;

        let key_int = self.coerce_to_int(key_ptr.into())?;
        let map_ptr = map_phi.as_basic_value().into_pointer_value();

        let new_map = self.builder()
            .build_call(insert_fn, &[key_int.into(), val_ptr.into(), map_ptr.into()], "new_map")
            .map_err(|e| CodegenError::Internal(format!("insert call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("insert: void".to_string()))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        map_phi.add_incoming(&[(&empty_map, entry_block), (&new_map, loop_body)]);
        cur_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(map_phi.as_basic_value()))
    }

    /// Lower `Data.Map.keys`  returns list of keys only.
    fn lower_builtin_map_keys(
        &mut self,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_keys: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "map_count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let key_at_fn = *self.functions.get(&VarId::new(1000161)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_key_at not declared".to_string())
        })?;

        let loop_header = self.llvm_context().append_basic_block(current_fn, "mk_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "mk_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "mk_exit");

        let nil = self.build_nil()?;
        let start_idx = self.builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "start_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SLT, idx, tm.i64_type().const_zero(), "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let key_i64 = self.builder()
            .build_call(key_at_fn, &[map_ptr.into(), idx.into()], "key")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();
        let key_ptr = self.int_to_ptr(key_i64)?;

        let new_acc = self.build_cons(key_ptr.into(), acc_phi.as_basic_value())?;
        let new_idx = self.builder()
            .build_int_sub(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&start_idx, entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Map.elems`  returns list of values only.
    fn lower_builtin_map_elems(
        &mut self,
        map_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let map_val = self.lower_expr(map_expr)?
            .ok_or_else(|| CodegenError::Internal("map_elems: no map".to_string()))?;
        let map_ptr = self.value_to_ptr(map_val)?;

        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        let count_fn = self.functions.get(&VarId::new(1000160)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_keys_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[map_ptr.into()], "map_count")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?
            .into_int_value();

        let val_at_fn = *self.functions.get(&VarId::new(1000162)).ok_or_else(|| {
            CodegenError::Internal("bhc_map_value_at not declared".to_string())
        })?;

        let loop_header = self.llvm_context().append_basic_block(current_fn, "me_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "me_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "me_exit");

        let nil = self.build_nil()?;
        let start_idx = self.builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "start_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SLT, idx, tm.i64_type().const_zero(), "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_body);
        let val = self.builder()
            .build_call(val_at_fn, &[map_ptr.into(), idx.into()], "val")
            .map_err(|e| CodegenError::Internal(format!("call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("void".to_string()))?;

        let new_acc = self.build_cons(val, acc_phi.as_basic_value())?;
        let new_idx = self.builder()
            .build_int_sub(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&start_idx, entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    // --- Data.Set handlers ---

    /// Lower `Data.Set.empty`.
    fn lower_builtin_set_empty(&mut self) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(1000120)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_empty not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[], "set_empty")
            .map_err(|e| CodegenError::Internal(format!("set_empty call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_empty: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Set.singleton`.
    fn lower_builtin_set_singleton(
        &mut self,
        val_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("set_singleton: no value".to_string()))?;
        let val_int = self.coerce_to_int(val)?;
        let rts_fn = self.functions.get(&VarId::new(1000121)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_singleton not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[val_int.into()], "set_singleton")
            .map_err(|e| CodegenError::Internal(format!("set_singleton call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_singleton: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Set.null`.
    fn lower_builtin_set_null(
        &mut self,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_null: no set".to_string()))?;
        let set_ptr = self.value_to_ptr(set_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000122)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_null not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[set_ptr.into()], "set_null")
            .map_err(|e| CodegenError::Internal(format!("set_null call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_null: returned void".to_string()))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Set.size`.
    fn lower_builtin_set_size(
        &mut self,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_size: no set".to_string()))?;
        let set_ptr = self.value_to_ptr(set_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000123)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_size not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[set_ptr.into()], "set_size")
            .map_err(|e| CodegenError::Internal(format!("set_size call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_size: returned void".to_string()))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Set.member`.
    fn lower_builtin_set_member(
        &mut self,
        val_expr: &Expr,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("set_member: no value".to_string()))?;
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_member: no set".to_string()))?;
        let val_int = self.coerce_to_int(val)?;
        let set_ptr = self.value_to_ptr(set_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000124)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_member not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[val_int.into(), set_ptr.into()], "set_member")
            .map_err(|e| CodegenError::Internal(format!("set_member call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_member: returned void".to_string()))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Set.insert`.
    fn lower_builtin_set_insert(
        &mut self,
        val_expr: &Expr,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("set_insert: no value".to_string()))?;
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_insert: no set".to_string()))?;
        let val_int = self.coerce_to_int(val)?;
        let set_ptr = self.value_to_ptr(set_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000125)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_insert not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[val_int.into(), set_ptr.into()], "set_insert")
            .map_err(|e| CodegenError::Internal(format!("set_insert call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_insert: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower `Data.Set.delete`.
    fn lower_builtin_set_delete(
        &mut self,
        val_expr: &Expr,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(val_expr)?
            .ok_or_else(|| CodegenError::Internal("set_delete: no value".to_string()))?;
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_delete: no set".to_string()))?;
        let val_int = self.coerce_to_int(val)?;
        let set_ptr = self.value_to_ptr(set_val)?;
        let rts_fn = self.functions.get(&VarId::new(1000126)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_delete not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[val_int.into(), set_ptr.into()], "set_delete")
            .map_err(|e| CodegenError::Internal(format!("set_delete call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_delete: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Lower Data.Set binary operations (union, intersection, difference).
    fn lower_builtin_set_binary(
        &mut self,
        set1_expr: &Expr,
        set2_expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let s1 = self.lower_expr(set1_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no set1", name)))?;
        let s2 = self.lower_expr(set2_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no set2", name)))?;
        let s1_ptr = self.value_to_ptr(s1)?;
        let s2_ptr = self.value_to_ptr(s2)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{} RTS function not declared", name))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[s1_ptr.into(), s2_ptr.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(result))
    }

    /// Lower Data.Set predicate operations (isSubsetOf, isProperSubsetOf).
    fn lower_builtin_set_predicate(
        &mut self,
        set1_expr: &Expr,
        set2_expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let s1 = self.lower_expr(set1_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no set1", name)))?;
        let s2 = self.lower_expr(set2_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no set2", name)))?;
        let s1_ptr = self.value_to_ptr(s1)?;
        let s2_ptr = self.value_to_ptr(s2)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{} RTS function not declared", name))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[s1_ptr.into(), s2_ptr.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Set.findMin` / `findMax`.
    fn lower_builtin_set_find_extremum(
        &mut self,
        set_expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no set", name)))?;
        let set_ptr = self.value_to_ptr(set_val)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{} RTS function not declared", name))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[set_ptr.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Lower `Data.Set.deleteMin` / `deleteMax`.
    fn lower_builtin_set_delete_extremum(
        &mut self,
        set_expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no set", name)))?;
        let set_ptr = self.value_to_ptr(set_val)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{} RTS function not declared", name))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[set_ptr.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        Ok(Some(result))
    }

    /// Lower `Data.Set.toList` / `toAscList` / `toDescList` / `elems` (stub).
    fn lower_builtin_set_to_list(
        &mut self,
        set_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal("set_toList: no set".to_string()))?;
        let set_ptr = self.value_to_ptr(set_val)?;

        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Get element count
        let count_fn = self.functions.get(&VarId::new(1000163)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_count not declared".to_string())
        })?;
        let count = self.builder()
            .build_call(*count_fn, &[set_ptr.into()], "set_count")
            .map_err(|e| CodegenError::Internal(format!("set_count call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("set_count: void".to_string()))?
            .into_int_value();

        let elem_at_fn = *self.functions.get(&VarId::new(1000164)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_elem_at not declared".to_string())
        })?;

        // Build list backwards: iterate from (count-1) down to 0
        let loop_header = self.llvm_context().append_basic_block(current_fn, "stl_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "stl_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "stl_exit");

        let nil = self.build_nil()?;
        let start_idx = self.builder()
            .build_int_sub(count, tm.i64_type().const_int(1, false), "start_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let acc_phi = self.builder().build_phi(tm.ptr_type(), "acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let idx_phi = self.builder().build_phi(tm.i64_type(), "idx")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        let idx = idx_phi.as_basic_value().into_int_value();
        let done = self.builder()
            .build_int_compare(inkwell::IntPredicate::SLT, idx, tm.i64_type().const_zero(), "done")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(done, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: get element at index, cons onto accumulator
        self.builder().position_at_end(loop_body);
        let elem_i64 = self.builder()
            .build_call(elem_at_fn, &[set_ptr.into(), idx.into()], "elem")
            .map_err(|e| CodegenError::Internal(format!("elem_at call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("elem_at: void".to_string()))?
            .into_int_value();
        let elem_ptr = self.int_to_ptr(elem_i64)?;

        let new_acc = self.build_cons(elem_ptr.into(), acc_phi.as_basic_value())?;
        let new_idx = self.builder()
            .build_int_sub(idx, tm.i64_type().const_int(1, false), "new_idx")
            .map_err(|e| CodegenError::Internal(format!("sub failed: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        acc_phi.add_incoming(&[(&nil, entry_block), (&new_acc, loop_body)]);
        idx_phi.add_incoming(&[(&start_idx, entry_block), (&new_idx, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(acc_phi.as_basic_value()))
    }

    /// Lower `Data.Set.fromList`  iterates list, inserting each element.
    fn lower_builtin_set_from_list(
        &mut self,
        list_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let list_val = self.lower_expr(list_expr)?
            .ok_or_else(|| CodegenError::Internal("set_fromList: no list".to_string()))?;
        let list_ptr = self.value_to_ptr(list_val)?;

        let tm = self.type_mapper();
        let current_fn = self.builder().get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Start with empty set
        let empty_fn = self.functions.get(&VarId::new(1000120)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_empty not declared".to_string())
        })?;
        let empty_set = self.builder()
            .build_call(*empty_fn, &[], "empty_set")
            .map_err(|e| CodegenError::Internal(format!("empty call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("empty: void".to_string()))?;

        let insert_fn = *self.functions.get(&VarId::new(1000125)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_insert not declared".to_string())
        })?;

        let loop_header = self.llvm_context().append_basic_block(current_fn, "sfl_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "sfl_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "sfl_exit");

        let entry_block = self.builder().get_insert_block().unwrap();
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        self.builder().position_at_end(loop_header);
        let set_phi = self.builder().build_phi(tm.ptr_type(), "set_acc")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;
        let cur_phi = self.builder().build_phi(tm.ptr_type(), "cur_list")
            .map_err(|e| CodegenError::Internal(format!("phi failed: {:?}", e)))?;

        // Check if current list is nil (tag == 0)
        let cur_ptr = cur_phi.as_basic_value().into_pointer_value();
        let tag = self.builder()
            .build_load(tm.i64_type(), cur_ptr, "tag")
            .map_err(|e| CodegenError::Internal(format!("load tag failed: {:?}", e)))?
            .into_int_value();
        let is_nil = self.builder()
            .build_int_compare(inkwell::IntPredicate::EQ, tag, tm.i64_type().const_zero(), "is_nil")
            .map_err(|e| CodegenError::Internal(format!("cmp failed: {:?}", e)))?;
        self.builder().build_conditional_branch(is_nil, loop_exit, loop_body)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        // Loop body: extract head element, insert into set
        self.builder().position_at_end(loop_body);
        let head_ptr = self.extract_adt_field(cur_ptr, 2, 0)?;
        let tail_ptr = self.extract_adt_field(cur_ptr, 2, 1)?;

        let elem_int = self.coerce_to_int(head_ptr.into())?;
        let set_ptr = set_phi.as_basic_value().into_pointer_value();

        let new_set = self.builder()
            .build_call(insert_fn, &[elem_int.into(), set_ptr.into()], "new_set")
            .map_err(|e| CodegenError::Internal(format!("insert call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("insert: void".to_string()))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("branch failed: {:?}", e)))?;

        set_phi.add_incoming(&[(&empty_set, entry_block), (&new_set, loop_body)]);
        cur_phi.add_incoming(&[(&list_ptr, entry_block), (&tail_ptr, loop_body)]);

        self.builder().position_at_end(loop_exit);
        Ok(Some(set_phi.as_basic_value()))
    }

    /// Lower `Data.Set.lookupMin` / `lookupMax` - returns Maybe.
    fn lower_builtin_set_lookup_extremum(
        &mut self,
        set_expr: &Expr,
        rts_id: usize,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let set_val = self.lower_expr(set_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no set", name)))?;
        let set_ptr = self.value_to_ptr(set_val)?;
        // Check if set is empty
        let null_fn = self.functions.get(&VarId::new(1000122)).ok_or_else(|| {
            CodegenError::Internal("bhc_set_null not declared".to_string())
        })?;
        let is_empty = self.builder()
            .build_call(*null_fn, &[set_ptr.into()], "set_is_empty")
            .map_err(|e| CodegenError::Internal(format!("{}: null check failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: null returned void", name)))?;
        let is_empty_bool = self.builder()
            .build_int_compare(
                inkwell::IntPredicate::NE,
                is_empty.into_int_value(),
                self.type_mapper().i64_type().const_zero(),
                "is_empty_bool",
            )
            .map_err(|e| CodegenError::Internal(format!("{}: compare failed: {:?}", name, e)))?;
        let nothing = self.alloc_adt(0, 0)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{} RTS function not declared", name))
        })?;
        let val = self.builder()
            .build_call(*rts_fn, &[set_ptr.into()], name)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", name, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", name)))?;
        let val_ptr = self.int_to_ptr(val.into_int_value())?;
        let just = self.alloc_adt(1, 1)?;
        self.store_adt_field(just, 1, 0, val_ptr.into())?;
        let result = self.builder()
            .build_select(is_empty_bool, nothing, just, "maybe_extremum")
            .map_err(|e| CodegenError::Internal(format!("{}: select failed: {:?}", name, e)))?;
        Ok(Some(result))
    }

    // ========================================================================
    // Text / ByteArray handler methods
    // ========================================================================

    /// Text nullary: () -> ptr (e.g. text_empty)
    fn lower_builtin_text_nullary(
        &mut self,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(result))
    }

    /// Text unary: (ptr) -> ptr (e.g. text_tail, text_reverse)
    fn lower_builtin_text_unary_ptr_to_ptr(
        &mut self,
        expr: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no value", label)))?;
        let ptr = self.value_to_ptr(val)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[ptr.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(result))
    }

    /// Text unary: (ptr) -> i64 (e.g. text_null, text_length, text_head)
    fn lower_builtin_text_unary_ptr_to_int(
        &mut self,
        expr: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no value", label)))?;
        let ptr = self.value_to_ptr(val)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[ptr.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Text unary: (i64) -> ptr (e.g. text_singleton)
    fn lower_builtin_text_unary_int_to_ptr(
        &mut self,
        expr: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let val = self.lower_expr(expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no value", label)))?;
        let int_val = self.coerce_to_int(val)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[int_val.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(result))
    }

    /// Text binary: (ptr, ptr) -> ptr (e.g. text_append)
    fn lower_builtin_text_binary_ptr_to_ptr(
        &mut self,
        expr_a: &Expr,
        expr_b: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let a = self.lower_expr(expr_a)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no a", label)))?;
        let b = self.lower_expr(expr_b)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no b", label)))?;
        let a_ptr = self.value_to_ptr(a)?;
        let b_ptr = self.value_to_ptr(b)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[a_ptr.into(), b_ptr.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(result))
    }

    /// Text binary: (ptr, ptr) -> i64 (e.g. text_eq, text_compare)
    fn lower_builtin_text_binary_ptr_to_int(
        &mut self,
        expr_a: &Expr,
        expr_b: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let a = self.lower_expr(expr_a)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no a", label)))?;
        let b = self.lower_expr(expr_b)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no b", label)))?;
        let a_ptr = self.value_to_ptr(a)?;
        let b_ptr = self.value_to_ptr(b)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[a_ptr.into(), b_ptr.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// Text: (i64, ptr) -> ptr (e.g. text_take, text_drop)
    fn lower_builtin_text_int_ptr_to_ptr(
        &mut self,
        int_expr: &Expr,
        ptr_expr: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let n = self.lower_expr(int_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no int", label)))?;
        let t = self.lower_expr(ptr_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no ptr", label)))?;
        let n_int = self.coerce_to_int(n)?;
        let t_ptr = self.value_to_ptr(t)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[n_int.into(), t_ptr.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(result))
    }

    /// ByteArray: (ptr, i64) -> i64 (e.g. ba_index)
    fn lower_builtin_text_ptr_int_to_int(
        &mut self,
        ptr_expr: &Expr,
        int_expr: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let p = self.lower_expr(ptr_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no ptr", label)))?;
        let n = self.lower_expr(int_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no int", label)))?;
        let p_ptr = self.value_to_ptr(p)?;
        let n_int = self.coerce_to_int(n)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[p_ptr.into(), n_int.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(self.int_to_ptr(result.into_int_value())?.into()))
    }

    /// ByteArray: (ptr, i64) -> ptr (e.g. ba_ptr_plus)
    fn lower_builtin_text_ptr_int_to_ptr(
        &mut self,
        ptr_expr: &Expr,
        int_expr: &Expr,
        rts_id: usize,
        label: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let p = self.lower_expr(ptr_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no ptr", label)))?;
        let n = self.lower_expr(int_expr)?
            .ok_or_else(|| CodegenError::Internal(format!("{}: no int", label)))?;
        let p_ptr = self.value_to_ptr(p)?;
        let n_int = self.coerce_to_int(n)?;
        let rts_fn = self.functions.get(&VarId::new(rts_id)).ok_or_else(|| {
            CodegenError::Internal(format!("{}: RTS function {} not declared", label, rts_id))
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[p_ptr.into(), n_int.into()], label)
            .map_err(|e| CodegenError::Internal(format!("{} call failed: {:?}", label, e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal(format!("{}: returned void", label)))?;
        Ok(Some(result))
    }

    /// ByteArray copy: (ptr, ptr, i64, i64) -> void
    fn lower_builtin_ba_copy(
        &mut self,
        dst_expr: &Expr,
        src_expr: &Expr,
        offset_expr: &Expr,
        len_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let dst = self.lower_expr(dst_expr)?
            .ok_or_else(|| CodegenError::Internal("ba_copy: no dst".to_string()))?;
        let src = self.lower_expr(src_expr)?
            .ok_or_else(|| CodegenError::Internal("ba_copy: no src".to_string()))?;
        let off = self.lower_expr(offset_expr)?
            .ok_or_else(|| CodegenError::Internal("ba_copy: no offset".to_string()))?;
        let len = self.lower_expr(len_expr)?
            .ok_or_else(|| CodegenError::Internal("ba_copy: no len".to_string()))?;
        let dst_ptr = self.value_to_ptr(dst)?;
        let src_ptr = self.value_to_ptr(src)?;
        let off_int = self.coerce_to_int(off)?;
        let len_int = self.coerce_to_int(len)?;
        let rts_fn = self.functions.get(&VarId::new(1000253)).ok_or_else(|| {
            CodegenError::Internal("bhc_bytearray_copy not declared".to_string())
        })?;
        self.builder()
            .build_call(*rts_fn, &[dst_ptr.into(), src_ptr.into(), off_int.into(), len_int.into()], "ba_copy")
            .map_err(|e| CodegenError::Internal(format!("ba_copy call failed: {:?}", e)))?;
        // void return  return unit (null ptr)
        let unit = self.type_mapper().ptr_type().const_null();
        Ok(Some(unit.into()))
    }

    /// ByteArray poke: (ptr, i64, i64) -> void
    fn lower_builtin_ba_poke(
        &mut self,
        ptr_expr: &Expr,
        offset_expr: &Expr,
        value_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let p = self.lower_expr(ptr_expr)?
            .ok_or_else(|| CodegenError::Internal("ba_poke: no ptr".to_string()))?;
        let off = self.lower_expr(offset_expr)?
            .ok_or_else(|| CodegenError::Internal("ba_poke: no offset".to_string()))?;
        let val = self.lower_expr(value_expr)?
            .ok_or_else(|| CodegenError::Internal("ba_poke: no value".to_string()))?;
        let p_ptr = self.value_to_ptr(p)?;
        let off_int = self.coerce_to_int(off)?;
        let val_int = self.coerce_to_int(val)?;
        let rts_fn = self.functions.get(&VarId::new(1000255)).ok_or_else(|| {
            CodegenError::Internal("bhc_poke_byte not declared".to_string())
        })?;
        self.builder()
            .build_call(*rts_fn, &[p_ptr.into(), off_int.into(), val_int.into()], "ba_poke")
            .map_err(|e| CodegenError::Internal(format!("ba_poke call failed: {:?}", e)))?;
        let unit = self.type_mapper().ptr_type().const_null();
        Ok(Some(unit.into()))
    }

    /// Text unpack: builds a BHC cons-list from a Text using char_count + char_at iteration.
    ///
    /// This uses the same pattern as `map_keys` codegen:
    /// 1. Call bhc_text_char_count to get N
    /// 2. Loop from N-1 down to 0, calling bhc_text_char_at(text, i)
    /// 3. Build cons-list in reverse (so we end up with correct order)
    fn lower_builtin_text_unpack(
        &mut self,
        text_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let text_val = self.lower_expr(text_expr)?
            .ok_or_else(|| CodegenError::Internal("text_unpack: no text".to_string()))?;
        let text_ptr = self.value_to_ptr(text_val)?;

        // Get char count
        let count_fn = self.functions.get(&VarId::new(1000224)).ok_or_else(|| {
            CodegenError::Internal("bhc_text_char_count not declared".to_string())
        })?;
        let count_val = self.builder()
            .build_call(*count_fn, &[text_ptr.into()], "char_count")
            .map_err(|e| CodegenError::Internal(format!("char_count call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("char_count: returned void".to_string()))?
            .into_int_value();

        let char_at_fn = self.functions.get(&VarId::new(1000225)).ok_or_else(|| {
            CodegenError::Internal("bhc_text_char_at not declared".to_string())
        })?;

        let tm = self.type_mapper();
        let i64_type = tm.i64_type();
        let ptr_type = tm.ptr_type();

        // Build Nil (empty list) as starting accumulator
        let nil = self.alloc_adt(0, 0)?;

        // Create loop blocks
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("text_unpack: no current function".to_string()))?;
        let loop_header = self.llvm_context().append_basic_block(current_fn, "unpack_header");
        let loop_body = self.llvm_context().append_basic_block(current_fn, "unpack_body");
        let loop_exit = self.llvm_context().append_basic_block(current_fn, "unpack_exit");

        // Initial: i = count - 1, acc = nil
        let one = i64_type.const_int(1, false);
        let init_i = self.builder()
            .build_int_sub(count_val, one, "init_i")
            .map_err(|e| CodegenError::Internal(format!("text_unpack sub: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("text_unpack br: {:?}", e)))?;

        // Loop header: phi for i and acc
        self.builder().position_at_end(loop_header);
        let phi_i = self.builder()
            .build_phi(i64_type, "i")
            .map_err(|e| CodegenError::Internal(format!("text_unpack phi_i: {:?}", e)))?;
        let phi_acc = self.builder()
            .build_phi(ptr_type, "acc")
            .map_err(|e| CodegenError::Internal(format!("text_unpack phi_acc: {:?}", e)))?;

        let zero = i64_type.const_int(0, false);
        let cond = self.builder()
            .build_int_compare(inkwell::IntPredicate::SGE, phi_i.as_basic_value().into_int_value(), zero, "cond")
            .map_err(|e| CodegenError::Internal(format!("text_unpack cmp: {:?}", e)))?;
        self.builder().build_conditional_branch(cond, loop_body, loop_exit)
            .map_err(|e| CodegenError::Internal(format!("text_unpack cbr: {:?}", e)))?;

        // Loop body: char = char_at(text, i); cons = Cons(char, acc); i = i - 1
        self.builder().position_at_end(loop_body);
        let i_val = phi_i.as_basic_value().into_int_value();
        let char_val = self.builder()
            .build_call(*char_at_fn, &[text_ptr.into(), i_val.into()], "char_at")
            .map_err(|e| CodegenError::Internal(format!("char_at call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("char_at: returned void".to_string()))?;

        // Alloc Cons node: tag=1, arity=2
        let cons = self.alloc_adt(1, 2)?;
        let char_ptr = self.int_to_ptr(char_val.into_int_value())?;
        self.store_adt_field(cons, 2, 0, char_ptr.into())?;
        let acc_val = phi_acc.as_basic_value().into_pointer_value();
        self.store_adt_field(cons, 2, 1, acc_val.into())?;

        let next_i = self.builder()
            .build_int_sub(i_val, one, "next_i")
            .map_err(|e| CodegenError::Internal(format!("text_unpack dec: {:?}", e)))?;
        self.builder().build_unconditional_branch(loop_header)
            .map_err(|e| CodegenError::Internal(format!("text_unpack loop_br: {:?}", e)))?;

        // Wire phi nodes
        let pre_header = loop_header.get_previous_basic_block()
            .ok_or_else(|| CodegenError::Internal("text_unpack: no pre-header block".to_string()))?;
        phi_i.add_incoming(&[(&init_i, pre_header), (&next_i, loop_body)]);
        phi_acc.add_incoming(&[(&nil, pre_header), (&cons, loop_body)]);

        // Exit: return accumulated list
        self.builder().position_at_end(loop_exit);
        Ok(Some(phi_acc.as_basic_value()))
    }

    /// Text map: (Char -> Char) -> Text -> Text
    ///
    /// The closure is dispatched via the RTS `bhc_text_map(fn_ptr, env_ptr, text_ptr)`.
    /// The Haskell closure is represented as an ADT with fn_ptr at field 0 and env at field 1.
    fn lower_builtin_text_map(
        &mut self,
        func_expr: &Expr,
        text_expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let func = self.lower_expr(func_expr)?
            .ok_or_else(|| CodegenError::Internal("text_map: no func".to_string()))?;
        let text = self.lower_expr(text_expr)?
            .ok_or_else(|| CodegenError::Internal("text_map: no text".to_string()))?;
        let func_ptr = self.value_to_ptr(func)?;
        let text_ptr = self.value_to_ptr(text)?;

        // For closure dispatch, pass the closure pointer as both fn_ptr and env_ptr.
        // The RTS function will interpret the closure accordingly.
        let rts_fn = self.functions.get(&VarId::new(1000226)).ok_or_else(|| {
            CodegenError::Internal("bhc_text_map not declared".to_string())
        })?;
        let result = self.builder()
            .build_call(*rts_fn, &[func_ptr.into(), func_ptr.into(), text_ptr.into()], "text_map")
            .map_err(|e| CodegenError::Internal(format!("text_map call failed: {:?}", e)))?
            .try_as_basic_value().basic()
            .ok_or_else(|| CodegenError::Internal("text_map: returned void".to_string()))?;
        Ok(Some(result))
    }

    /// Check if an expression is structurally a list (Cons applications or Nil).
    /// This is used when type information isn't available.
    fn is_list_expr(expr: &Expr) -> bool {
        match expr {
            // Empty list []
            Expr::Var(v, _) if v.name.as_str() == "[]" => true,
            // Cons application: (:) head tail
            Expr::App(func, _, _) => {
                // Check if this is a (:) application
                let mut current = func.as_ref();
                // Unwrap one more App for curried (:) x y
                if let Expr::App(inner_func, _, _) = current {
                    current = inner_func.as_ref();
                }
                // Check if the head is the (:) constructor
                if let Expr::Var(v, _) = current {
                    v.name.as_str() == ":"
                } else {
                    false
                }
            }
            _ => false,
        }
    }

    /// Check if a name is a data constructor and return (tag, arity).
    ///
    /// This function checks:
    /// 1. Builtin types (Bool, Maybe, Either, List, Tuple, Ordering)
    /// 2. User-defined types registered via `register_constructor`
    fn constructor_info(&self, name: &str) -> Option<(u32, u32)> {
        // First check builtin constructors
        match name {
            // Bool constructors
            "False" => return Some((0, 0)), // tag=0, arity=0
            "True" => return Some((1, 0)),  // tag=1, arity=0

            // Maybe constructors
            "Nothing" => return Some((0, 0)), // tag=0, arity=0
            "Just" => return Some((1, 1)),    // tag=1, arity=1

            // Either constructors
            "Left" => return Some((0, 1)),  // tag=0, arity=1
            "Right" => return Some((1, 1)), // tag=1, arity=1

            // List constructors
            "[]" => return Some((0, 0)), // tag=0, arity=0 (Nil)
            ":" => return Some((1, 2)),  // tag=1, arity=2 (Cons head tail)

            // Unit constructor
            "()" => return Some((0, 0)), // tag=0, arity=0

            // Ordering constructors
            "LT" => return Some((0, 0)), // tag=0, arity=0
            "EQ" => return Some((1, 0)), // tag=1, arity=0
            "GT" => return Some((2, 0)), // tag=2, arity=0

            // IOMode constructors
            "ReadMode" => return Some((0, 0)),      // tag=0, arity=0
            "WriteMode" => return Some((1, 0)),     // tag=1, arity=0
            "AppendMode" => return Some((2, 0)),    // tag=2, arity=0
            "ReadWriteMode" => return Some((3, 0)), // tag=3, arity=0

            // Tuple constructors - used for type class dictionaries
            "(,)" => return Some((0, 2)),       // 2-tuple
            "(,,)" => return Some((0, 3)),      // 3-tuple
            "(,,,)" => return Some((0, 4)),     // 4-tuple
            "(,,,,)" => return Some((0, 5)),    // 5-tuple
            "(,,,,,)" => return Some((0, 6)),   // 6-tuple
            "(,,,,,,)" => return Some((0, 7)),  // 7-tuple
            "(,,,,,,,)" => return Some((0, 8)), // 8-tuple

            _ => {}
        }

        // Check user-defined constructors registered from case alternatives
        if let Some(meta) = self.constructor_metadata.get(name) {
            return Some((meta.tag, meta.arity));
        }

        // If it looks like a constructor (starts with uppercase), return None
        // to indicate we don't have metadata yet (might be registered later)
        if name
            .chars()
            .next()
            .map(|c| c.is_uppercase())
            .unwrap_or(false)
        {
            None
        } else {
            None
        }
    }

    // ========================================================================
    // Closure Support
    // ========================================================================
    //
    // Closures are represented as heap-allocated structs:
    //
    //   struct Closure {
    //       ptr fn_ptr;        // Pointer to the lifted function
    //       i64 env_size;      // Number of captured variables
    //       ptr env[];         // Array of captured variable pointers
    //   }
    //
    // When a lambda captures free variables, we:
    // 1. Compute the free variables
    // 2. Create a lifted function that takes (env_ptr, params...) as arguments
    // 3. Allocate a closure struct with the function pointer and captured values
    //
    // When calling a closure:
    // 1. Load the function pointer from the closure
    // 2. Call with the closure (as env) and the arguments
    // ========================================================================

    /// Compute the free variables of an expression.
    ///
    /// Returns the set of variable IDs that are referenced but not bound
    /// within the expression.
    fn free_vars(&self, expr: &Expr) -> FxHashSet<VarId> {
        let mut free = FxHashSet::default();
        let mut bound = FxHashSet::default();
        self.collect_free_vars(expr, &mut free, &mut bound);
        free
    }

    /// Helper to collect free variables, tracking bound variables.
    fn collect_free_vars(
        &self,
        expr: &Expr,
        free: &mut FxHashSet<VarId>,
        bound: &mut FxHashSet<VarId>,
    ) {
        match expr {
            Expr::Lit(_, _, _) => {}

            Expr::Var(var, _) => {
                // A variable is free if it's not bound and not a top-level function/constructor
                if !bound.contains(&var.id)
                    && !self.functions.contains_key(&var.id)
                    && self.constructor_info(var.name.as_str()).is_none()
                    && self.primitive_op_info(var.name.as_str()).is_none()
                    && self.rts_function_id(var.name.as_str()).is_none()
                {
                    free.insert(var.id);
                }
            }

            Expr::App(func, arg, _) => {
                self.collect_free_vars(func, free, bound);
                self.collect_free_vars(arg, free, bound);
            }

            Expr::Lam(param, body, _) => {
                bound.insert(param.id);
                self.collect_free_vars(body, free, bound);
                bound.remove(&param.id);
            }

            Expr::Let(bind, body, _) => {
                match &**bind {
                    Bind::NonRec(var, rhs) => {
                        self.collect_free_vars(rhs, free, bound);
                        bound.insert(var.id);
                        self.collect_free_vars(body, free, bound);
                        bound.remove(&var.id);
                    }
                    Bind::Rec(bindings) => {
                        // For recursive bindings, all vars are bound in both RHS and body
                        for (var, _) in bindings {
                            bound.insert(var.id);
                        }
                        for (_, rhs) in bindings {
                            self.collect_free_vars(rhs, free, bound);
                        }
                        self.collect_free_vars(body, free, bound);
                        for (var, _) in bindings {
                            bound.remove(&var.id);
                        }
                    }
                }
            }

            Expr::Case(scrut, alts, _, _) => {
                self.collect_free_vars(scrut, free, bound);
                for alt in alts {
                    for binder in &alt.binders {
                        bound.insert(binder.id);
                    }
                    self.collect_free_vars(&alt.rhs, free, bound);
                    for binder in &alt.binders {
                        bound.remove(&binder.id);
                    }
                }
            }

            Expr::TyApp(inner, _, _) => {
                self.collect_free_vars(inner, free, bound);
            }

            Expr::TyLam(_, body, _) => {
                self.collect_free_vars(body, free, bound);
            }

            Expr::Lazy(inner, _) => {
                self.collect_free_vars(inner, free, bound);
            }

            Expr::Cast(inner, _, _) => {
                self.collect_free_vars(inner, free, bound);
            }

            Expr::Tick(_, inner, _) => {
                self.collect_free_vars(inner, free, bound);
            }

            Expr::Type(_, _) | Expr::Coercion(_, _) => {}
        }
    }

    /// Get the LLVM struct type for a closure with the given environment size.
    ///
    /// Closure layout: { ptr fn_ptr, i64 env_size, [env_size x ptr] env }
    fn closure_type(&self, env_size: u32) -> inkwell::types::StructType<'ctx> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let i64_type = tm.i64_type();

        // Create array type for environment
        let env_type = ptr_type.array_type(env_size);

        // Struct: { ptr fn_ptr, i64 env_size, [env_size x ptr] env }
        self.llvm_ctx
            .struct_type(&[ptr_type.into(), i64_type.into(), env_type.into()], false)
    }

    /// Allocate a closure with the given function pointer and captured variables.
    fn alloc_closure(
        &self,
        fn_ptr: PointerValue<'ctx>,
        captured_vars: &[(VarId, BasicValueEnum<'ctx>)],
    ) -> CodegenResult<PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let env_size = captured_vars.len() as u32;
        let closure_ty = self.closure_type(env_size);

        // Calculate size: sizeof(ptr) + sizeof(i64) + env_size * sizeof(ptr)
        let size = 8 + 8 + (env_size as u64) * 8;

        // Call bhc_alloc
        let alloc_fn = self
            .functions
            .get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;

        let size_val = tm.i64_type().const_int(size, false);
        let raw_ptr = self
            .builder()
            .build_call(*alloc_fn, &[size_val.into()], "closure_alloc")
            .map_err(|e| CodegenError::Internal(format!("failed to call bhc_alloc: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("bhc_alloc returned void".to_string()))?;

        let closure_ptr = raw_ptr.into_pointer_value();

        // Store function pointer at offset 0
        let fn_ptr_slot = self
            .builder()
            .build_struct_gep(closure_ty, closure_ptr, 0, "fn_ptr_slot")
            .map_err(|e| CodegenError::Internal(format!("failed to get fn_ptr slot: {:?}", e)))?;

        self.builder()
            .build_store(fn_ptr_slot, fn_ptr)
            .map_err(|e| CodegenError::Internal(format!("failed to store fn_ptr: {:?}", e)))?;

        // Store env_size at offset 1
        let env_size_slot = self
            .builder()
            .build_struct_gep(closure_ty, closure_ptr, 1, "env_size_slot")
            .map_err(|e| CodegenError::Internal(format!("failed to get env_size slot: {:?}", e)))?;

        let env_size_val = tm.i64_type().const_int(env_size as u64, false);
        self.builder()
            .build_store(env_size_slot, env_size_val)
            .map_err(|e| CodegenError::Internal(format!("failed to store env_size: {:?}", e)))?;

        // Store captured variables in environment array
        if env_size > 0 {
            let env_slot = self
                .builder()
                .build_struct_gep(closure_ty, closure_ptr, 2, "env_slot")
                .map_err(|e| CodegenError::Internal(format!("failed to get env slot: {:?}", e)))?;

            for (i, (_var_id, val)) in captured_vars.iter().enumerate() {
                let elem_ptr = unsafe {
                    self.builder()
                        .build_in_bounds_gep(
                            tm.ptr_type().array_type(env_size),
                            env_slot,
                            &[
                                tm.i64_type().const_zero(),
                                tm.i64_type().const_int(i as u64, false),
                            ],
                            &format!("env_{}", i),
                        )
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to get env elem: {:?}", e))
                        })?
                };

                // Convert value to pointer if needed
                let ptr_val = self.value_to_ptr(*val)?;
                self.builder().build_store(elem_ptr, ptr_val).map_err(|e| {
                    CodegenError::Internal(format!("failed to store env elem: {:?}", e))
                })?;
            }
        }

        Ok(closure_ptr)
    }

    /// Extract the function pointer from a closure.
    fn extract_closure_fn_ptr(
        &self,
        closure_ptr: PointerValue<'ctx>,
    ) -> CodegenResult<PointerValue<'ctx>> {
        let closure_ty = self.closure_type(0); // Use 0-size for reading fn_ptr (same offset)

        let fn_ptr_slot = self
            .builder()
            .build_struct_gep(closure_ty, closure_ptr, 0, "fn_ptr_slot")
            .map_err(|e| CodegenError::Internal(format!("failed to get fn_ptr slot: {:?}", e)))?;

        let fn_ptr = self
            .builder()
            .build_load(self.type_mapper().ptr_type(), fn_ptr_slot, "fn_ptr")
            .map_err(|e| CodegenError::Internal(format!("failed to load fn_ptr: {:?}", e)))?;

        Ok(fn_ptr.into_pointer_value())
    }

    /// Extract an element from a closure's environment.
    fn extract_closure_env_elem(
        &self,
        closure_ptr: PointerValue<'ctx>,
        env_size: u32,
        index: u32,
    ) -> CodegenResult<PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let closure_ty = self.closure_type(env_size);

        let env_slot = self
            .builder()
            .build_struct_gep(closure_ty, closure_ptr, 2, "env_slot")
            .map_err(|e| CodegenError::Internal(format!("failed to get env slot: {:?}", e)))?;

        let elem_ptr = unsafe {
            self.builder()
                .build_in_bounds_gep(
                    tm.ptr_type().array_type(env_size),
                    env_slot,
                    &[
                        tm.i64_type().const_zero(),
                        tm.i64_type().const_int(index as u64, false),
                    ],
                    &format!("env_elem_ptr_{}", index),
                )
                .map_err(|e| {
                    CodegenError::Internal(format!("failed to get env elem ptr: {:?}", e))
                })?
        };

        let elem_val = self
            .builder()
            .build_load(tm.ptr_type(), elem_ptr, &format!("env_elem_{}", index))
            .map_err(|e| CodegenError::Internal(format!("failed to load env elem: {:?}", e)))?;

        Ok(elem_val.into_pointer_value())
    }

    // ========================================================================
    // Thunk Support
    // ========================================================================
    //
    // Thunks are suspended computations for lazy evaluation.
    //
    // Memory Layout:
    //   struct Thunk {
    //       i64   tag;       // -1 = unevaluated, -2 = blackhole, >= 0 = evaluated
    //       ptr   eval_fn;   // Function to evaluate (when unevaluated)
    //       i64   env_size;  // Number of captured variables
    //       ptr[] env;       // Captured environment
    //   }
    //
    // The eval_fn has signature: extern "C" fn(env: *mut u8) -> *mut u8
    // It takes the environment pointer and returns the evaluated value.
    // ========================================================================

    /// Tag constant for unevaluated thunks.
    const THUNK_TAG: i64 = -1;

    /// Get the LLVM struct type for a thunk with the given environment size.
    ///
    /// Thunk layout: { i64 tag, ptr eval_fn, i64 env_size, [env_size x ptr] env }
    fn thunk_type(&self, env_size: u32) -> inkwell::types::StructType<'ctx> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let i64_type = tm.i64_type();

        // Create array type for environment
        let env_type = ptr_type.array_type(env_size);

        // Struct: { i64 tag, ptr eval_fn, i64 env_size, [env_size x ptr] env }
        self.llvm_ctx.struct_type(
            &[
                i64_type.into(),
                ptr_type.into(),
                i64_type.into(),
                env_type.into(),
            ],
            false,
        )
    }

    /// Allocate a thunk with the given evaluation function and captured variables.
    fn alloc_thunk(
        &self,
        eval_fn: PointerValue<'ctx>,
        captured_vars: &[(VarId, BasicValueEnum<'ctx>)],
    ) -> CodegenResult<PointerValue<'ctx>> {
        let tm = self.type_mapper();
        let env_size = captured_vars.len() as u32;
        let thunk_ty = self.thunk_type(env_size);

        // Calculate size: sizeof(i64) + sizeof(ptr) + sizeof(i64) + env_size * sizeof(ptr)
        let size = 8 + 8 + 8 + (env_size as u64) * 8;

        // Call bhc_alloc
        let alloc_fn = self
            .functions
            .get(&VarId::new(1000005))
            .ok_or_else(|| CodegenError::Internal("bhc_alloc not declared".to_string()))?;

        let size_val = tm.i64_type().const_int(size, false);
        let raw_ptr = self
            .builder()
            .build_call(*alloc_fn, &[size_val.into()], "thunk_alloc")
            .map_err(|e| CodegenError::Internal(format!("failed to call bhc_alloc: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("bhc_alloc returned void".to_string()))?;

        let thunk_ptr = raw_ptr.into_pointer_value();

        // Store tag = -1 (THUNK_TAG) at offset 0
        let tag_slot = self
            .builder()
            .build_struct_gep(thunk_ty, thunk_ptr, 0, "thunk_tag_slot")
            .map_err(|e| CodegenError::Internal(format!("failed to get tag slot: {:?}", e)))?;

        let tag_val = tm.i64_type().const_int(Self::THUNK_TAG as u64, true);
        self.builder()
            .build_store(tag_slot, tag_val)
            .map_err(|e| CodegenError::Internal(format!("failed to store thunk tag: {:?}", e)))?;

        // Store eval function pointer at offset 1
        let eval_fn_slot = self
            .builder()
            .build_struct_gep(thunk_ty, thunk_ptr, 1, "thunk_eval_fn_slot")
            .map_err(|e| CodegenError::Internal(format!("failed to get eval_fn slot: {:?}", e)))?;

        self.builder()
            .build_store(eval_fn_slot, eval_fn)
            .map_err(|e| CodegenError::Internal(format!("failed to store eval_fn: {:?}", e)))?;

        // Store env_size at offset 2
        let env_size_slot = self
            .builder()
            .build_struct_gep(thunk_ty, thunk_ptr, 2, "thunk_env_size_slot")
            .map_err(|e| CodegenError::Internal(format!("failed to get env_size slot: {:?}", e)))?;

        let env_size_val = tm.i64_type().const_int(env_size as u64, false);
        self.builder()
            .build_store(env_size_slot, env_size_val)
            .map_err(|e| CodegenError::Internal(format!("failed to store env_size: {:?}", e)))?;

        // Store captured variables in environment array
        if env_size > 0 {
            let env_slot = self
                .builder()
                .build_struct_gep(thunk_ty, thunk_ptr, 3, "thunk_env_slot")
                .map_err(|e| CodegenError::Internal(format!("failed to get env slot: {:?}", e)))?;

            for (i, (_var_id, val)) in captured_vars.iter().enumerate() {
                let elem_ptr = unsafe {
                    self.builder()
                        .build_in_bounds_gep(
                            tm.ptr_type().array_type(env_size),
                            env_slot,
                            &[
                                tm.i64_type().const_zero(),
                                tm.i64_type().const_int(i as u64, false),
                            ],
                            &format!("thunk_env_{}", i),
                        )
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to get env elem: {:?}", e))
                        })?
                };

                // Convert value to pointer if needed
                let ptr_val = self.value_to_ptr(*val)?;
                self.builder().build_store(elem_ptr, ptr_val).map_err(|e| {
                    CodegenError::Internal(format!("failed to store thunk env elem: {:?}", e))
                })?;
            }
        }

        Ok(thunk_ptr)
    }

    /// Generate a call to bhc_force to evaluate a thunk to WHNF.
    fn build_force(&self, val: BasicValueEnum<'ctx>) -> CodegenResult<BasicValueEnum<'ctx>> {
        let ptr = match val {
            BasicValueEnum::PointerValue(p) => p,
            // Non-pointers don't need forcing (primitives)
            _ => return Ok(val),
        };

        let force_fn = self
            .functions
            .get(&VarId::new(1000011))
            .ok_or_else(|| CodegenError::Internal("bhc_force not declared".to_string()))?;

        let result = self
            .builder()
            .build_call(*force_fn, &[ptr.into()], "forced")
            .map_err(|e| CodegenError::Internal(format!("failed to call bhc_force: {:?}", e)))?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| CodegenError::Internal("bhc_force returned void".to_string()))?;

        Ok(result)
    }

    /// Generate a unique name for a thunk evaluation function.
    fn next_thunk_name(&mut self) -> String {
        let name = format!("__thunk_eval_{}", self.closure_counter);
        self.closure_counter += 1;
        name
    }

    /// Generate a unique name for a closure function.
    fn next_closure_name(&mut self) -> String {
        let name = format!("__closure_{}", self.closure_counter);
        self.closure_counter += 1;
        name
    }

    /// Check if an expression is a saturated constructor application.
    ///
    /// Returns Some((tag, collected_args)) if the expression is a fully-applied constructor.
    fn is_saturated_constructor<'a>(&self, expr: &'a Expr) -> Option<(u32, u32, Vec<&'a Expr>)> {
        // Collect arguments while unwrapping applications
        let mut args = Vec::new();
        let mut current = expr;

        while let Expr::App(func, arg, _) = current {
            args.push(arg.as_ref());
            current = func.as_ref();
        }

        // Check if the head is a constructor
        if let Expr::Var(var, _) = current {
            if let Some((tag, arity)) = self.constructor_info(var.name.as_str()) {
                args.reverse();
                if args.len() == arity as usize {
                    return Some((tag, arity, args));
                }
            }
        }

        None
    }

    /// Lower a Core module to LLVM IR.
    pub fn lower_module(&mut self, core_module: &CoreModule) -> CodegenResult<()> {
        // Pre-pass: collect all constructor metadata from case alternatives
        // This ensures constructors are known before we try to lower applications
        for bind in &core_module.bindings {
            self.collect_constructors_from_binding(bind);
        }

        // Pre-pass: detect which functions use StateT/ReaderT operations.
        // This must happen before lowering so that callers of these functions
        // can detect the correct monad context.
        self.detect_monad_functions(&core_module.bindings);

        // First pass: declare all top-level functions
        for bind in &core_module.bindings {
            self.declare_binding(bind)?;
        }

        // Second pass: define all functions
        for bind in &core_module.bindings {
            self.lower_binding(bind)?;
        }

        Ok(())
    }

    /// Pre-pass: scan all bindings to detect which functions use StateT/ReaderT/ExceptT/WriterT.
    /// This populates the function sets so that `detect_monad_from_expr` can recognize
    /// calls to user-defined monadic functions.
    fn detect_monad_functions(&mut self, bindings: &[Bind]) {
        // First pass: detect direct users of get/put/ask/throwE/tell/etc.
        for bind in bindings {
            match bind {
                Bind::NonRec(var, expr) => {
                    if let Some(ctx) = self.detect_monad_context_for_body(expr) {
                        let name = var.name.as_str().to_string();
                        match ctx {
                            MonadContext::StateT => { self.state_t_functions.insert(name); }
                            MonadContext::ReaderT => { self.reader_t_functions.insert(name); }
                            MonadContext::ExceptT => { self.except_t_functions.insert(name); }
                            MonadContext::WriterT => { self.writer_t_functions.insert(name); }
                            _ => {}
                        }
                    }
                }
                Bind::Rec(pairs) => {
                    for (var, expr) in pairs {
                        if let Some(ctx) = self.detect_monad_context_for_body(expr) {
                            let name = var.name.as_str().to_string();
                            match ctx {
                                MonadContext::StateT => { self.state_t_functions.insert(name); }
                                MonadContext::ReaderT => { self.reader_t_functions.insert(name); }
                                MonadContext::ExceptT => { self.except_t_functions.insert(name); }
                                MonadContext::WriterT => { self.writer_t_functions.insert(name); }
                                _ => {}
                            }
                        }
                    }
                }
            }
        }
        // Second pass: propagate  functions that call transformer functions
        // are themselves transformer functions.
        let mut changed = true;
        while changed {
            changed = false;
            for bind in bindings {
                match bind {
                    Bind::NonRec(var, expr) => {
                        let name = var.name.as_str().to_string();
                        if !self.state_t_functions.contains(&name)
                            && !self.reader_t_functions.contains(&name)
                            && !self.except_t_functions.contains(&name)
                            && !self.writer_t_functions.contains(&name)
                        {
                            if let Some(ctx) = self.detect_monad_context_for_calls(expr) {
                                match ctx {
                                    MonadContext::StateT => {
                                        self.state_t_functions.insert(name);
                                        changed = true;
                                    }
                                    MonadContext::ReaderT => {
                                        self.reader_t_functions.insert(name);
                                        changed = true;
                                    }
                                    MonadContext::ExceptT => {
                                        self.except_t_functions.insert(name);
                                        changed = true;
                                    }
                                    MonadContext::WriterT => {
                                        self.writer_t_functions.insert(name);
                                        changed = true;
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    Bind::Rec(pairs) => {
                        for (var, expr) in pairs {
                            let name = var.name.as_str().to_string();
                            if !self.state_t_functions.contains(&name)
                                && !self.reader_t_functions.contains(&name)
                                && !self.except_t_functions.contains(&name)
                                && !self.writer_t_functions.contains(&name)
                            {
                                if let Some(ctx) = self.detect_monad_context_for_calls(expr) {
                                    match ctx {
                                        MonadContext::StateT => {
                                            self.state_t_functions.insert(name);
                                            changed = true;
                                        }
                                        MonadContext::ReaderT => {
                                            self.reader_t_functions.insert(name);
                                            changed = true;
                                        }
                                        MonadContext::ExceptT => {
                                            self.except_t_functions.insert(name);
                                            changed = true;
                                        }
                                        MonadContext::WriterT => {
                                            self.writer_t_functions.insert(name);
                                            changed = true;
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /// Detect if an expression calls any known transformer function.
    fn detect_monad_context_for_calls(&self, expr: &Expr) -> Option<MonadContext> {
        match expr {
            Expr::Var(v, _) => {
                let name = v.name.as_str();
                if self.state_t_functions.contains(name) {
                    Some(MonadContext::StateT)
                } else if self.reader_t_functions.contains(name) {
                    Some(MonadContext::ReaderT)
                } else if self.except_t_functions.contains(name) {
                    Some(MonadContext::ExceptT)
                } else if self.writer_t_functions.contains(name) {
                    Some(MonadContext::WriterT)
                } else {
                    None
                }
            }
            Expr::App(func, arg, _) => {
                self.detect_monad_context_for_calls(func)
                    .or_else(|| self.detect_monad_context_for_calls(arg))
            }
            Expr::Lam(_, body, _) => self.detect_monad_context_for_calls(body),
            Expr::Let(bind, body, _) => {
                let in_bind = match bind.as_ref() {
                    Bind::NonRec(_, e) => self.detect_monad_context_for_calls(e),
                    Bind::Rec(bindings) => bindings
                        .iter()
                        .find_map(|(_, e)| self.detect_monad_context_for_calls(e)),
                };
                in_bind.or_else(|| self.detect_monad_context_for_calls(body))
            }
            Expr::Case(scrut, alts, _, _) => {
                self.detect_monad_context_for_calls(scrut).or_else(|| {
                    alts.iter()
                        .find_map(|alt| self.detect_monad_context_for_calls(&alt.rhs))
                })
            }
            Expr::TyApp(e, _, _) => self.detect_monad_context_for_calls(e),
            _ => None,
        }
    }

    /// Collect constructor metadata from a binding's expression.
    fn collect_constructors_from_binding(&mut self, bind: &Bind) {
        match bind {
            Bind::NonRec(_, expr) => {
                self.collect_constructors_from_expr(expr);
            }
            Bind::Rec(bindings) => {
                for (_, expr) in bindings {
                    self.collect_constructors_from_expr(expr);
                }
            }
        }
    }

    /// Recursively collect constructor metadata from an expression.
    fn collect_constructors_from_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::Case(scrut, alts, _, _) => {
                self.collect_constructors_from_expr(scrut);
                for alt in alts {
                    if let AltCon::DataCon(con) = &alt.con {
                        self.register_constructor(con.name.as_str(), con.tag, con.arity);
                    }
                    self.collect_constructors_from_expr(&alt.rhs);
                }
            }
            Expr::App(func, arg, _) => {
                self.collect_constructors_from_expr(func);
                self.collect_constructors_from_expr(arg);
            }
            Expr::TyApp(func, _, _) => {
                self.collect_constructors_from_expr(func);
            }
            Expr::Lam(_, body, _) => {
                self.collect_constructors_from_expr(body);
            }
            Expr::TyLam(_, body, _) => {
                self.collect_constructors_from_expr(body);
            }
            Expr::Let(bind, body, _) => {
                self.collect_constructors_from_binding(bind);
                self.collect_constructors_from_expr(body);
            }
            Expr::Lazy(inner, _) => {
                self.collect_constructors_from_expr(inner);
            }
            Expr::Cast(inner, _, _) => {
                self.collect_constructors_from_expr(inner);
            }
            Expr::Tick(_, inner, _) => {
                self.collect_constructors_from_expr(inner);
            }
            // Leaf nodes that don't contain constructors
            Expr::Var(_, _) | Expr::Lit(_, _, _) | Expr::Type(_, _) | Expr::Coercion(_, _) => {}
        }
    }

    /// Declare a binding (creates function signature without body).
    fn declare_binding(&mut self, bind: &Bind) -> CodegenResult<()> {
        match bind {
            Bind::NonRec(var, expr) => {
                let fn_val = self.declare_function_from_expr(var, expr)?;
                self.functions.insert(var.id, fn_val);
            }
            Bind::Rec(bindings) => {
                for (var, expr) in bindings {
                    let fn_val = self.declare_function_from_expr(var, expr)?;
                    self.functions.insert(var.id, fn_val);
                }
            }
        }
        Ok(())
    }

    /// Count the number of lambda parameters in an expression.
    fn count_lambda_params(&self, expr: &Expr) -> usize {
        let mut count = 0;
        let mut current = expr;
        while let Expr::Lam(_, body, _) = current {
            count += 1;
            current = body.as_ref();
        }
        count
    }

    /// Check if a type contains unresolved type variables or errors.
    fn type_needs_inference(&self, ty: &Ty) -> bool {
        match ty {
            Ty::Error => true,
            Ty::Var(_) => true,
            Ty::Fun(arg, ret) => self.type_needs_inference(arg) || self.type_needs_inference(ret),
            Ty::Forall(_, body) => self.type_needs_inference(body),
            Ty::App(f, arg) => self.type_needs_inference(f) || self.type_needs_inference(arg),
            _ => false,
        }
    }

    /// Declare a function from a Core variable and expression.
    /// Uses the expression to infer the function type when var.ty contains unresolved types.
    fn declare_function_from_expr(
        &self,
        var: &Var,
        expr: &Expr,
    ) -> CodegenResult<FunctionValue<'ctx>> {
        let param_count = self.count_lambda_params(expr);

        // Only use fallback typing for functions with parameters and Error types
        // For type variables, lower_function_type handles them correctly (as pointers)
        let fn_type = if param_count > 0 && matches!(&var.ty, Ty::Error) {
            // Fallback for Error types only - use pointers for uniform calling convention
            let tm = self.type_mapper();

            // Use pointer type for all parameters (handles closures, polymorphic values)
            let param_types: Vec<_> = (0..param_count).map(|_| tm.ptr_type().into()).collect();

            // Default return type is pointer
            tm.ptr_type().fn_type(&param_types, false)
        } else {
            self.lower_function_type(&var.ty)?
        };
        let name = self.mangle_name(var.name.as_str());
        Ok(self.module.add_function(&name, fn_type))
    }

    /// Declare a function from a Core variable.
    fn declare_function(&self, var: &Var) -> CodegenResult<FunctionValue<'ctx>> {
        let fn_type = self.lower_function_type(&var.ty)?;
        let name = self.mangle_name(var.name.as_str());
        Ok(self.module.add_function(&name, fn_type))
    }

    /// Lower a binding to LLVM IR.
    fn lower_binding(&mut self, bind: &Bind) -> CodegenResult<()> {
        match bind {
            Bind::NonRec(var, expr) => {
                self.lower_function_def(var, expr)?;
            }
            Bind::Rec(bindings) => {
                for (var, expr) in bindings {
                    self.lower_function_def(var, expr)?;
                }
            }
        }
        Ok(())
    }

    /// Lower a function definition.
    fn lower_function_def(&mut self, var: &Var, expr: &Expr) -> CodegenResult<()> {
        let fn_val = self.functions.get(&var.id).copied().ok_or_else(|| {
            CodegenError::Internal(format!("function not declared: {}", var.name.as_str()))
        })?;

        // Create entry block
        let entry = self.llvm_context().append_basic_block(fn_val, "entry");
        self.builder().position_at_end(entry);

        // Detect if this function body uses StateT/ReaderT operations.
        // If so, push the appropriate monad context so that >>= and >>
        // dispatch correctly for user-defined helper functions, and record
        // this function as a StateT/ReaderT function so callers can detect it.
        let monad_ctx = self.detect_monad_context_for_body(expr);
        if let Some(ctx) = monad_ctx {
            let fn_name = var.name.as_str().to_string();
            match ctx {
                MonadContext::StateT => { self.state_t_functions.insert(fn_name); }
                MonadContext::ReaderT => { self.reader_t_functions.insert(fn_name); }
                _ => {}
            }
            self.push_monad_context(ctx);
        }

        // Lower the function body, handling lambda parameters
        let result = self.lower_function_body(fn_val, expr)?;

        if monad_ctx.is_some() {
            self.pop_monad_context();
        }

        // Check if the current block already has a terminator (e.g., from `error` or `unreachable`)
        // If so, don't add another terminator
        let current_block = self.builder().get_insert_block();
        let has_terminator = current_block
            .map(|bb| bb.get_terminator().is_some())
            .unwrap_or(false);

        if !has_terminator {
            // Build return based on function's declared return type, not the computed result
            // This handles cases like IO () which produces a value but should return void
            let ret_type = fn_val.get_type().get_return_type();
            if ret_type.is_none() {
                // Void return type - don't return a value
                self.builder().build_return(None).map_err(|e| {
                    CodegenError::Internal(format!("failed to build return: {:?}", e))
                })?;
            } else if let Some(val) = result {
                // Convert to pointer if return type is pointer (uniform calling convention)
                let ret_val: BasicValueEnum<'ctx> =
                    if ret_type == Some(self.type_mapper().ptr_type().into()) {
                        self.value_to_ptr(val)?.into()
                    } else {
                        val
                    };
                self.builder().build_return(Some(&ret_val)).map_err(|e| {
                    CodegenError::Internal(format!("failed to build return: {:?}", e))
                })?;
            } else {
                // Function expects a return value but body produced none
                // This shouldn't happen with correct type checking
                self.builder().build_return(None).map_err(|e| {
                    CodegenError::Internal(format!("failed to build return: {:?}", e))
                })?;
            }
        }

        Ok(())
    }

    /// Lower a Core expression to LLVM IR.
    fn lower_expr(&mut self, expr: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        match expr {
            Expr::Lit(lit, _ty, _span) => self.lower_literal(lit).map(Some),

            Expr::Var(var, _span) => {
                let name = var.name.as_str();

                // First, check if this is a nullary constructor (like [], True, False, Nothing)
                if let Some((tag, arity)) = self.constructor_info(name) {
                    if arity == 0 {
                        // Nullary constructor - allocate ADT value with just a tag
                        return self.lower_constructor_application(tag, 0, &[]);
                    }
                    // Non-nullary constructor referenced without args - return as closure/function
                    // This case is handled below when the constructor is used in an application
                }

                // Look up the variable in the environment
                if let Some(val) = self.env.get(&var.id) {
                    Ok(Some(*val))
                } else if let Some(fn_val) = self.functions.get(&var.id) {
                    // It's a function reference
                    // Check if it's a CAF (only env pointer, no real arguments)
                    // All functions have at least 1 param (env pointer) due to uniform calling convention
                    let fn_type = fn_val.get_type();
                    if fn_type.count_param_types() <= 1 {
                        // CAF - call the function with null env to get its value
                        let null_env = self.type_mapper().ptr_type().const_null();
                        let call_result = self
                            .builder()
                            .build_call(*fn_val, &[null_env.into()], "caf_result")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to call CAF: {:?}", e))
                            })?;
                        // Get the return value
                        if let Some(ret_val) = call_result.try_as_basic_value().basic() {
                            Ok(Some(ret_val))
                        } else {
                            // Void function - shouldn't happen for CAFs
                            Ok(None)
                        }
                    } else {
                        // Function with parameters - wrap in closure for uniform calling convention
                        let fn_ptr = fn_val.as_global_value().as_pointer_value();
                        let closure_ptr = self.alloc_closure(fn_ptr, &[])?;
                        Ok(Some(closure_ptr.into()))
                    }
                } else if let Some((primop, arity)) = self.primitive_op_info(name) {
                    // Primop used as a value - create a wrapper closure
                    self.create_primop_closure(primop, arity, name)
                } else if let Some(arity) = self.builtin_info(name) {
                    // Builtin used as a value - create a wrapper closure
                    self.create_builtin_closure(name, arity)
                } else if let Some(&fn_val) = self.external_functions.get(&var.name) {
                    // Cross-module imported function
                    let fn_ptr = fn_val.as_global_value().as_pointer_value();
                    Ok(Some(fn_ptr.into()))
                } else {
                    Err(CodegenError::Internal(format!(
                        "unbound variable: {}",
                        name
                    )))
                }
            }

            Expr::App(func, arg, _span) => self.lower_application(func, arg),

            Expr::Lam(param, body, _span) => {
                // Create a closure for this lambda
                self.lower_lambda(param, body)
            }

            Expr::Let(bind, body, _span) => self.lower_let(bind, body),

            Expr::Case(scrut, alts, _ty, _span) => self.lower_case(scrut, alts),

            Expr::TyApp(expr, _ty, _span) => {
                // Type applications are erased at runtime
                self.lower_expr(expr)
            }

            Expr::TyLam(_tyvar, body, _span) => {
                // Type lambdas are erased at runtime
                self.lower_expr(body)
            }

            Expr::Lazy(inner, _span) => {
                // Create a thunk for lazy evaluation
                self.lower_lazy(inner)
            }

            Expr::Cast(inner, _coercion, _span) => {
                // Coercions are erased at runtime
                self.lower_expr(inner)
            }

            Expr::Tick(_tick, inner, _span) => {
                // Ticks are for profiling, skip for now
                self.lower_expr(inner)
            }

            Expr::Type(_ty, _span) => {
                // Type expressions have no runtime value
                Ok(None)
            }

            Expr::Coercion(_coercion, _span) => {
                // Coercion values have no runtime representation
                Ok(None)
            }
        }
    }

    /// Lower a literal to LLVM IR.
    fn lower_literal(&self, lit: &Literal) -> CodegenResult<BasicValueEnum<'ctx>> {
        let tm = self.type_mapper();
        match lit {
            Literal::Int(n) => Ok(tm.i64_type().const_int(*n as u64, true).into()),

            Literal::Integer(n) => {
                // For large integers, we'd need arbitrary precision
                // For now, truncate to i64
                Ok(tm.i64_type().const_int(*n as u64, true).into())
            }

            Literal::Float(f) => Ok(tm.f32_type().const_float(*f as f64).into()),

            Literal::Double(d) => Ok(tm.f64_type().const_float(*d).into()),

            Literal::Char(c) => Ok(tm.i64_type().const_int(*c as u64, false).into()),

            Literal::String(sym) => {
                // Build a linked list of characters (proper Haskell [Char] representation).
                // This allows pattern matching on strings as character lists.
                let s = sym.as_str();
                let chars: Vec<char> = s.chars().collect();
                let mut current = self.build_nil()?;
                // Build list in reverse so that head of list = first char
                for &ch in chars.iter().rev() {
                    let char_val = tm.i64_type().const_int(ch as u64, false);
                    current = self.build_cons(char_val.into(), current.into())?;
                }
                Ok(current.into())
            }
        }
    }

    /// Lower a lambda expression to a closure.
    ///
    /// Creates a lifted function and allocates a closure struct containing
    /// the function pointer and captured variables.
    fn lower_lambda(
        &mut self,
        param: &Var,
        body: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Collect all parameters (for multi-argument lambdas)
        let mut params = vec![param.clone()];
        let mut current_body = body;

        while let Expr::Lam(next_param, next_body, _) = current_body {
            params.push(next_param.clone());
            current_body = next_body;
        }

        // Compute free variables in the lambda body
        let full_lambda = Expr::Lam(param.clone(), Box::new(body.clone()), body.span());
        let free = self.free_vars(&full_lambda);

        // Collect the values of free variables from current environment
        let mut captured: Vec<(VarId, BasicValueEnum<'ctx>)> = Vec::new();
        for var_id in &free {
            if let Some(val) = self.env.get(var_id) {
                captured.push((*var_id, *val));
            }
        }

        // Save current insertion point
        let current_block = self.builder().get_insert_block();

        // Generate unique name for the lifted function
        let fn_name = self.next_closure_name();

        // Build the function type:
        // - First param is the closure/env pointer
        // - Remaining params are the lambda parameters
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();

        let mut param_types: Vec<inkwell::types::BasicMetadataTypeEnum<'ctx>> = Vec::new();
        param_types.push(ptr_type.into()); // env/closure pointer

        for _ in &params {
            // For now, use ptr for all params (polymorphic)
            param_types.push(ptr_type.into());
        }

        // Return type - use ptr for now (polymorphic)
        let fn_type = ptr_type.fn_type(&param_types, false);

        // Create the lifted function
        let lifted_fn = self.module.add_function(&fn_name, fn_type);

        // Create entry block for the lifted function
        let entry = self.llvm_context().append_basic_block(lifted_fn, "entry");
        self.builder().position_at_end(entry);

        // Save old environment and create new scope
        let old_env = std::mem::take(&mut self.env);

        // Bind captured variables from environment
        // The closure pointer is the first argument
        if !captured.is_empty() {
            let closure_ptr = lifted_fn
                .get_first_param()
                .ok_or_else(|| CodegenError::Internal("missing closure param".to_string()))?
                .into_pointer_value();

            for (i, (var_id, _)) in captured.iter().enumerate() {
                let elem_ptr =
                    self.extract_closure_env_elem(closure_ptr, captured.len() as u32, i as u32)?;
                // Store as pointer - will be unboxed when used
                self.env.insert(*var_id, elem_ptr.into());
            }
        }

        // Bind lambda parameters to function arguments
        // Skip first arg (closure pointer)
        for (i, lam_param) in params.iter().enumerate() {
            if let Some(arg) = lifted_fn.get_nth_param((i + 1) as u32) {
                self.env.insert(lam_param.id, arg);
            }
        }

        // Lower the body in tail position (enables tail call optimization)
        let was_tail = self.in_tail_position;
        self.in_tail_position = true;
        let result = self.lower_expr(current_body)?;
        self.in_tail_position = was_tail;

        // Build return
        if let Some(val) = result {
            // Convert to pointer for return
            let ret_ptr = self.value_to_ptr(val)?;
            self.builder()
                .build_return(Some(&ret_ptr))
                .map_err(|e| CodegenError::Internal(format!("failed to build return: {:?}", e)))?;
        } else {
            // Return null pointer for unit/void
            let null = ptr_type.const_null();
            self.builder()
                .build_return(Some(&null))
                .map_err(|e| CodegenError::Internal(format!("failed to build return: {:?}", e)))?;
        }

        // Restore old environment
        self.env = old_env;

        // Restore insertion point
        if let Some(block) = current_block {
            self.builder().position_at_end(block);
        }

        // Allocate closure with function pointer and captured values
        let fn_ptr = lifted_fn.as_global_value().as_pointer_value();
        let closure_ptr = self.alloc_closure(fn_ptr, &captured)?;

        Ok(Some(closure_ptr.into()))
    }

    /// Lower a lazy expression to a thunk.
    ///
    /// Creates a thunk that suspends the evaluation of the inner expression.
    /// The thunk is evaluated when forced (via bhc_force).
    fn lower_lazy(&mut self, inner: &Expr) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Compute free variables in the lazy expression
        let free = self.free_vars(inner);

        // Collect the values of free variables from current environment
        let mut captured: Vec<(VarId, BasicValueEnum<'ctx>)> = Vec::new();
        for var_id in &free {
            if let Some(val) = self.env.get(var_id) {
                captured.push((*var_id, *val));
            }
        }

        // Save current insertion point
        let current_block = self.builder().get_insert_block();

        // Generate unique name for the thunk evaluation function
        let fn_name = self.next_thunk_name();

        // Build the function type for the eval function:
        // fn(env: *mut u8) -> *mut u8
        // The env pointer points to the captured variables array
        // Extract types early to avoid borrow conflicts with self.env
        let ptr_type = self.type_mapper().ptr_type();
        let i64_type = self.type_mapper().i64_type();
        let env_array_type = ptr_type.array_type(captured.len() as u32);

        let fn_type = ptr_type.fn_type(&[ptr_type.into()], false);

        // Create the thunk evaluation function
        let eval_fn = self.module.add_function(&fn_name, fn_type);

        // Create entry block for the eval function
        let entry = self.llvm_context().append_basic_block(eval_fn, "entry");
        self.builder().position_at_end(entry);

        // Save old environment and create new scope
        let old_env = std::mem::take(&mut self.env);

        // Bind captured variables from environment parameter
        if !captured.is_empty() {
            let env_ptr = eval_fn
                .get_first_param()
                .ok_or_else(|| CodegenError::Internal("missing env param".to_string()))?
                .into_pointer_value();

            for (i, (var_id, _)) in captured.iter().enumerate() {
                // Load variable from env array
                let elem_ptr = unsafe {
                    self.builder()
                        .build_in_bounds_gep(
                            env_array_type,
                            env_ptr,
                            &[i64_type.const_zero(), i64_type.const_int(i as u64, false)],
                            &format!("thunk_env_load_{}", i),
                        )
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to get env elem ptr: {:?}", e))
                        })?
                };

                let elem_val = self
                    .builder()
                    .build_load(ptr_type, elem_ptr, &format!("thunk_env_val_{}", i))
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to load env elem: {:?}", e))
                    })?;

                self.env.insert(*var_id, elem_val);
            }
        }

        // Lower the inner expression (this produces the actual computation)
        let result = self.lower_expr(inner)?;

        // Build return
        if let Some(val) = result {
            let ret_ptr = self.value_to_ptr(val)?;
            self.builder()
                .build_return(Some(&ret_ptr))
                .map_err(|e| CodegenError::Internal(format!("failed to build return: {:?}", e)))?;
        } else {
            let null = ptr_type.const_null();
            self.builder()
                .build_return(Some(&null))
                .map_err(|e| CodegenError::Internal(format!("failed to build return: {:?}", e)))?;
        }

        // Restore old environment
        self.env = old_env;

        // Restore insertion point
        if let Some(block) = current_block {
            self.builder().position_at_end(block);
        }

        // Allocate thunk with eval function pointer and captured values
        let fn_ptr = eval_fn.as_global_value().as_pointer_value();
        let thunk_ptr = self.alloc_thunk(fn_ptr, &captured)?;

        Ok(Some(thunk_ptr.into()))
    }

    // ========================================================================
    // Primitive Operations
    // ========================================================================

    /// Check if a name is a primitive operation and return its arity.
    fn primitive_op_info(&self, name: &str) -> Option<(PrimOp, u32)> {
        match name {
            // Arithmetic (binary)
            "+" | "GHC.Num.+" => Some((PrimOp::Add, 2)),
            "-" | "GHC.Num.-" => Some((PrimOp::Sub, 2)),
            "*" | "GHC.Num.*" => Some((PrimOp::Mul, 2)),
            "/" | "GHC.Real./" => Some((PrimOp::Div, 2)),
            "div" | "GHC.Real.div" => Some((PrimOp::Div, 2)),
            "mod" | "GHC.Real.mod" => Some((PrimOp::Mod, 2)),
            "rem" | "GHC.Real.rem" => Some((PrimOp::Rem, 2)),
            "quot" | "GHC.Real.quot" => Some((PrimOp::Quot, 2)),

            // Comparison (binary)
            "==" | "GHC.Classes.==" => Some((PrimOp::Eq, 2)),
            "/=" | "GHC.Classes./=" => Some((PrimOp::Ne, 2)),
            "<" | "GHC.Classes.<" => Some((PrimOp::Lt, 2)),
            "<=" | "GHC.Classes.<=" => Some((PrimOp::Le, 2)),
            ">" | "GHC.Classes.>" => Some((PrimOp::Gt, 2)),
            ">=" | "GHC.Classes.>=" => Some((PrimOp::Ge, 2)),

            // Boolean (binary)
            "&&" | "GHC.Classes.&&" => Some((PrimOp::And, 2)),
            "||" | "GHC.Classes.||" => Some((PrimOp::Or, 2)),

            // Unary
            "negate" | "GHC.Num.negate" => Some((PrimOp::Negate, 1)),
            "abs" | "GHC.Num.abs" => Some((PrimOp::Abs, 1)),
            "signum" | "GHC.Num.signum" => Some((PrimOp::Signum, 1)),
            "not" | "GHC.Classes.not" => Some((PrimOp::Not, 1)),

            // Bitwise (binary)
            ".&." => Some((PrimOp::BitAnd, 2)),
            ".|." => Some((PrimOp::BitOr, 2)),
            "xor" => Some((PrimOp::BitXor, 2)),
            "shiftL" => Some((PrimOp::ShiftL, 2)),
            "shiftR" => Some((PrimOp::ShiftR, 2)),

            // Bitwise (unary)
            "complement" => Some((PrimOp::Complement, 1)),

            _ => None,
        }
    }

    /// Create a closure wrapping a primitive operation.
    /// This is used when a primop like (+) is used as a first-class value.
    fn create_primop_closure(
        &mut self,
        primop: PrimOp,
        arity: u32,
        name: &str,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let i64_type = tm.i64_type();

        // Create a unique name for the wrapper function
        let wrapper_name = format!(
            "primop_wrapper_{}",
            name.replace(|c: char| !c.is_alphanumeric(), "_")
        );

        // Check if wrapper already exists
        let wrapper_fn = if let Some(existing) =
            self.module.llvm_module().get_function(&wrapper_name)
        {
            existing
        } else {
            // Create wrapper function: (ptr env, ptr arg1, [ptr arg2]) -> ptr
            let mut param_types: Vec<inkwell::types::BasicMetadataTypeEnum<'ctx>> = Vec::new();
            param_types.push(ptr_type.into()); // env/closure pointer
            for _ in 0..arity {
                param_types.push(ptr_type.into());
            }

            let wrapper_fn_type = ptr_type.fn_type(&param_types, false);
            let wrapper_fn =
                self.module
                    .llvm_module()
                    .add_function(&wrapper_name, wrapper_fn_type, None);

            // Build the wrapper function body
            let entry_bb = self.llvm_ctx.append_basic_block(wrapper_fn, "entry");
            let current_bb = self.builder().get_insert_block();

            self.builder().position_at_end(entry_bb);

            // Load arguments (skip env at index 0)
            let args: Vec<BasicValueEnum<'ctx>> = (1..=arity)
                .map(|i| wrapper_fn.get_nth_param(i).unwrap())
                .collect();

            // Perform the primop
            let result = self.lower_primop_direct(primop, &args)?;

            // Box the result and return
            let result_ptr = self.value_to_ptr(result)?;
            self.builder()
                .build_return(Some(&result_ptr))
                .map_err(|e| CodegenError::Internal(format!("failed to build return: {:?}", e)))?;

            // Restore insertion point
            if let Some(bb) = current_bb {
                self.builder().position_at_end(bb);
            }

            wrapper_fn
        };

        // Create a closure wrapping the primop function
        let fn_ptr = wrapper_fn.as_global_value().as_pointer_value();
        let closure_ptr = self.alloc_closure(fn_ptr, &[])?;
        Ok(Some(closure_ptr.into()))
    }

    /// Create a closure wrapping a builtin operation.
    /// This is used when a builtin like (>>) is used as a first-class value.
    fn create_builtin_closure(
        &mut self,
        name: &str,
        arity: u32,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // For arity-0 builtins, directly evaluate without wrapping in another closure.
        // This is important for builtins like `ask` and `get` that return closures:
        // wrapping them would create a double-closure that breaks runReaderT/runStateT.
        if arity == 0 {
            return self.lower_builtin_direct(name, &[]);
        }

        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();

        // Create a unique name for the wrapper function
        let wrapper_name = format!(
            "builtin_wrapper_{}",
            name.replace(|c: char| !c.is_alphanumeric(), "_")
        );

        // Check if wrapper already exists
        let wrapper_fn = if let Some(existing) =
            self.module.llvm_module().get_function(&wrapper_name)
        {
            existing
        } else {
            // Create wrapper function: (ptr env, ptr arg1, ptr arg2, ...) -> ptr
            let mut param_types: Vec<inkwell::types::BasicMetadataTypeEnum<'ctx>> = Vec::new();
            param_types.push(ptr_type.into()); // env/closure pointer
            for _ in 0..arity {
                param_types.push(ptr_type.into());
            }

            let wrapper_fn_type = ptr_type.fn_type(&param_types, false);
            let wrapper_fn =
                self.module
                    .llvm_module()
                    .add_function(&wrapper_name, wrapper_fn_type, None);

            // Build the wrapper function body
            let entry_bb = self.llvm_ctx.append_basic_block(wrapper_fn, "entry");
            let current_bb = self.builder().get_insert_block();

            self.builder().position_at_end(entry_bb);

            // Load arguments (skip env at index 0)
            let args: Vec<BasicValueEnum<'ctx>> = (1..=arity)
                .map(|i| wrapper_fn.get_nth_param(i).unwrap())
                .collect();

            // Perform the builtin operation
            let result = self.lower_builtin_direct(name, &args)?;

            // Return the result
            let result_ptr = match result {
                Some(v) => v.into_pointer_value(),
                None => ptr_type.const_null(), // Unit/void result
            };
            self.builder()
                .build_return(Some(&result_ptr))
                .map_err(|e| CodegenError::Internal(format!("failed to build return: {:?}", e)))?;

            // Restore insertion point
            if let Some(bb) = current_bb {
                self.builder().position_at_end(bb);
            }

            wrapper_fn
        };

        // Create a closure wrapping the builtin function
        let fn_ptr = wrapper_fn.as_global_value().as_pointer_value();
        let closure_ptr = self.alloc_closure(fn_ptr, &[])?;
        Ok(Some(closure_ptr.into()))
    }

    /// Execute a builtin operation directly on LLVM values (already lowered).
    /// This is for when builtins are used as values and receive runtime arguments.
    fn lower_builtin_direct(
        &mut self,
        name: &str,
        args: &[BasicValueEnum<'ctx>],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let ptr_type = self.type_mapper().ptr_type();

        match name {
            ">>" => {
                // (>>) :: m a -> m b -> m b
                // Execute first action (arg1), ignore result, return second (arg2)
                // For our simple model, arg1 and arg2 are thunks/values
                // We just evaluate both and return the second
                // Since args are already evaluated values, we just return arg2
                // Note: If these were actual IO thunks, we'd need to force them
                Ok(Some(args[1]))
            }
            ">>=" => {
                // (>>=) :: m a -> (a -> m b) -> m b
                // Execute first action, pass result to function, return result of function
                let action_result = args[0]; // Result of first action
                let func = args[1].into_pointer_value(); // Function closure

                // Call the function with the action result
                let fn_ptr = self.extract_closure_fn_ptr(func)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let result = self
                    .builder()
                    .build_indirect_call(
                        fn_type,
                        fn_ptr,
                        &[func.into(), action_result.into()],
                        "bind_result",
                    )
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to call bind function: {:?}", e))
                    })?
                    .try_as_basic_value()
                    .basic()
                    .ok_or_else(|| {
                        CodegenError::Internal(">>=: function returned void".to_string())
                    })?;
                Ok(Some(result))
            }
            "=<<" => {
                // (=<<) :: (a -> m b) -> m a -> m b (flipped >>=)
                let func = args[0].into_pointer_value();
                let action_result = args[1];

                let fn_ptr = self.extract_closure_fn_ptr(func)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let result = self
                    .builder()
                    .build_indirect_call(
                        fn_type,
                        fn_ptr,
                        &[func.into(), action_result.into()],
                        "bind_result",
                    )
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to call bind function: {:?}", e))
                    })?
                    .try_as_basic_value()
                    .basic()
                    .ok_or_else(|| {
                        CodegenError::Internal("=<<: function returned void".to_string())
                    })?;
                Ok(Some(result))
            }
            "return" | "pure" => {
                // return :: a -> m a
                // For our simple IO model, just return the value
                Ok(Some(args[0]))
            }
            "fmap" | "<$>" => {
                // fmap :: (a -> b) -> f a -> f b
                // For IO: apply function to action result
                let func = args[0].into_pointer_value();
                let action_result = args[1];

                let fn_ptr = self.extract_closure_fn_ptr(func)?;
                let action_ptr = self.value_to_ptr(action_result)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let result = self
                    .builder()
                    .build_indirect_call(
                        fn_type,
                        fn_ptr,
                        &[func.into(), action_ptr.into()],
                        "fmap_result",
                    )
                    .map_err(|e| {
                        CodegenError::Internal(format!("fmap call failed: {:?}", e))
                    })?
                    .try_as_basic_value()
                    .basic()
                    .ok_or_else(|| {
                        CodegenError::Internal("fmap: returned void".to_string())
                    })?;
                Ok(Some(result))
            }
            "<*>" => {
                // (<*>) :: f (a -> b) -> f a -> f b
                // For IO: extract function from first action, apply to second
                let func_closure = args[0].into_pointer_value();
                let val = args[1];

                let fn_ptr = self.extract_closure_fn_ptr(func_closure)?;
                let val_ptr = self.value_to_ptr(val)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let result = self
                    .builder()
                    .build_indirect_call(
                        fn_type,
                        fn_ptr,
                        &[func_closure.into(), val_ptr.into()],
                        "ap_result",
                    )
                    .map_err(|e| {
                        CodegenError::Internal(format!("<*> call failed: {:?}", e))
                    })?
                    .try_as_basic_value()
                    .basic()
                    .ok_or_else(|| {
                        CodegenError::Internal("<*>: returned void".to_string())
                    })?;
                Ok(Some(result))
            }
            "putStrLn" => {
                // putStrLn :: String -> IO ()
                let str_ptr = args[0].into_pointer_value();
                let rts_fn = self.functions.get(&VarId::new(1000002)).ok_or_else(|| {
                    CodegenError::Internal("bhc_print_string_ln not declared".to_string())
                })?;
                self.builder()
                    .build_call(*rts_fn, &[str_ptr.into()], "")
                    .map_err(|e| CodegenError::Internal(format!("putStrLn call failed: {:?}", e)))?;
                Ok(Some(ptr_type.const_null().into()))
            }
            "putStr" => {
                let str_ptr = args[0].into_pointer_value();
                let rts_fn = self.functions.get(&VarId::new(1000004)).ok_or_else(|| {
                    CodegenError::Internal("bhc_print_string not declared".to_string())
                })?;
                self.builder()
                    .build_call(*rts_fn, &[str_ptr.into()], "")
                    .map_err(|e| CodegenError::Internal(format!("putStr call failed: {:?}", e)))?;
                Ok(Some(ptr_type.const_null().into()))
            }
            // Identity operations (newtype = pass through)
            "Identity" | "runIdentity" | "Identity.pure" => Ok(Some(args[0])),
            "Identity.fmap" | "Identity.>>=" | "Identity.<*>" => {
                // Apply function to value
                let func = args[0].into_pointer_value();
                let val = args[1];
                let fn_ptr = self.extract_closure_fn_ptr(func)?;
                let val_ptr = self.value_to_ptr(val)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let result = self.builder()
                    .build_indirect_call(fn_type, fn_ptr, &[func.into(), val_ptr.into()], "identity_call")
                    .map_err(|e| CodegenError::Internal(format!("Identity call failed: {:?}", e)))?
                    .try_as_basic_value().basic()
                    .ok_or_else(|| CodegenError::Internal("Identity: returned void".to_string()))?;
                Ok(Some(result))
            }
            "Identity.>>" => Ok(Some(args[1])),

            // ReaderT/StateT constructors (newtype = pass through)
            "ReaderT" | "StateT" => Ok(Some(args[0])),
            "runReaderT" | "runStateT" => {
                // Call the closure (arg0) with the environment/state (arg1)
                let closure = args[0].into_pointer_value();
                let env_val = args[1];
                let fn_ptr = self.extract_closure_fn_ptr(closure)?;
                let env_ptr = self.value_to_ptr(env_val)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let result = self.builder()
                    .build_indirect_call(fn_type, fn_ptr, &[closure.into(), env_ptr.into()], "run_t_result")
                    .map_err(|e| CodegenError::Internal(format!("runT call failed: {:?}", e)))?
                    .try_as_basic_value().basic()
                    .ok_or_else(|| CodegenError::Internal("runT: returned void".to_string()))?;
                Ok(Some(result))
            }

            // ReaderT operations (zero-arity: ask returns closure \r -> r)
            "ask" => self.lower_builtin_ask(),

            // ReaderT operations with pre-lowered args
            "asks" => {
                // asks f = closure \r -> f(r)
                let f_val = args[0];
                let fn_name = "bhc_reader_t_asks";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let r = func.get_nth_param(1).unwrap();
                    let f = self.extract_closure_env_elem(env, 1, 0)?;
                    let f_fn = self.extract_closure_fn_ptr(f)?;
                    let r_ptr = self.value_to_ptr(r)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let result = self.builder()
                        .build_indirect_call(fn_type, f_fn, &[f.into(), r_ptr.into()], "asks_result")
                        .map_err(|e| CodegenError::Internal(format!("asks call: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("asks: void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("asks return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let f_ptr = self.value_to_ptr(f_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), f_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }
            "local" => {
                // local f m = closure \r -> m(f(r))
                let f_val = args[0];
                let m_val = args[1];
                let fn_name = "bhc_reader_t_local";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let r = func.get_nth_param(1).unwrap();
                    let f = self.extract_closure_env_elem(env, 2, 0)?;
                    let m = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let f_fn = self.extract_closure_fn_ptr(f)?;
                    let r_ptr = self.value_to_ptr(r)?;
                    let r_prime = self.builder()
                        .build_indirect_call(fn_type, f_fn, &[f.into(), r_ptr.into()], "local_r")
                        .map_err(|e| CodegenError::Internal(format!("local f call: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("local f: void".to_string()))?;
                    let m_fn = self.extract_closure_fn_ptr(m)?;
                    let result = self.builder()
                        .build_indirect_call(fn_type, m_fn, &[m.into(), r_prime.into()], "local_result")
                        .map_err(|e| CodegenError::Internal(format!("local m call: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("local m: void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("local return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let f_ptr = self.value_to_ptr(f_val)?;
                let m_ptr = self.value_to_ptr(m_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), f_ptr.into()),
                    (VarId::new(900001), m_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }

            // ReaderT instance methods with pre-lowered args
            "ReaderT.pure" => {
                // \r -> x where x = args[0]
                let x_val = args[0];
                let fn_name = "bhc_reader_t_pure";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let x = self.extract_closure_env_elem(env, 1, 0)?;
                    self.builder().build_return(Some(&x))
                        .map_err(|e| CodegenError::Internal(format!("reader_t_pure return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let x_ptr = self.value_to_ptr(x_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), x_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }
            "ReaderT.>>=" => {
                // \r -> let a = m(r) in k(a)(r) where m = args[0], k = args[1]
                let m_val = args[0];
                let k_val = args[1];
                let fn_name = "bhc_reader_t_bind";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let r = func.get_nth_param(1).unwrap();
                    let m = self.extract_closure_env_elem(env, 2, 0)?;
                    let k = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let m_fn = self.extract_closure_fn_ptr(m)?;
                    let r_ptr = self.value_to_ptr(r)?;
                    let a = self.builder()
                        .build_indirect_call(fn_type, m_fn, &[m.into(), r_ptr.into()], "bind_a")
                        .map_err(|e| CodegenError::Internal(format!("reader bind m: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader bind m: void".to_string()))?;
                    let k_fn = self.extract_closure_fn_ptr(k)?;
                    let kr = self.builder()
                        .build_indirect_call(fn_type, k_fn, &[k.into(), a.into()], "bind_kr")
                        .map_err(|e| CodegenError::Internal(format!("reader bind k: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader bind k: void".to_string()))?;
                    let kr_ptr = kr.into_pointer_value();
                    let kr_fn = self.extract_closure_fn_ptr(kr_ptr)?;
                    let result = self.builder()
                        .build_indirect_call(fn_type, kr_fn, &[kr_ptr.into(), r_ptr.into()], "bind_result")
                        .map_err(|e| CodegenError::Internal(format!("reader bind kr: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader bind kr: void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("reader bind return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let m_ptr = self.value_to_ptr(m_val)?;
                let k_ptr = self.value_to_ptr(k_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), m_ptr.into()),
                    (VarId::new(900001), k_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "ReaderT.>>" => {
                // \r -> m1(r); m2(r) where m1 = args[0], m2 = args[1]
                let m1_val = args[0];
                let m2_val = args[1];
                let fn_name = "bhc_reader_t_then";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let r = func.get_nth_param(1).unwrap();
                    let m1 = self.extract_closure_env_elem(env, 2, 0)?;
                    let m2 = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let m1_fn = self.extract_closure_fn_ptr(m1)?;
                    let r_ptr = self.value_to_ptr(r)?;
                    self.builder()
                        .build_indirect_call(fn_type, m1_fn, &[m1.into(), r_ptr.into()], "then_discard")
                        .map_err(|e| CodegenError::Internal(format!("reader then m1: {:?}", e)))?;
                    let m2_fn = self.extract_closure_fn_ptr(m2)?;
                    let result = self.builder()
                        .build_indirect_call(fn_type, m2_fn, &[m2.into(), r_ptr.into()], "then_result")
                        .map_err(|e| CodegenError::Internal(format!("reader then m2: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader then m2: void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("reader then return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let m1_ptr = self.value_to_ptr(m1_val)?;
                let m2_ptr = self.value_to_ptr(m2_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), m1_ptr.into()),
                    (VarId::new(900001), m2_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "ReaderT.fmap" => {
                // \r -> f(m(r)) where f = args[0], m = args[1]
                let f_val = args[0];
                let m_val = args[1];
                let fn_name = "bhc_reader_t_fmap";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let r = func.get_nth_param(1).unwrap();
                    let f = self.extract_closure_env_elem(env, 2, 0)?;
                    let m = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let m_fn = self.extract_closure_fn_ptr(m)?;
                    let r_ptr = self.value_to_ptr(r)?;
                    let a = self.builder()
                        .build_indirect_call(fn_type, m_fn, &[m.into(), r_ptr.into()], "fmap_a")
                        .map_err(|e| CodegenError::Internal(format!("reader fmap m: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader fmap m: void".to_string()))?;
                    let f_fn = self.extract_closure_fn_ptr(f)?;
                    let result = self.builder()
                        .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "fmap_result")
                        .map_err(|e| CodegenError::Internal(format!("reader fmap f: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader fmap f: void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("reader fmap return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let f_ptr = self.value_to_ptr(f_val)?;
                let m_ptr = self.value_to_ptr(m_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), f_ptr.into()),
                    (VarId::new(900001), m_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "ReaderT.<*>" => {
                // \r -> (mf(r))(mx(r)) where mf = args[0], mx = args[1]
                let mf_val = args[0];
                let mx_val = args[1];
                let fn_name = "bhc_reader_t_ap";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let r = func.get_nth_param(1).unwrap();
                    let mf = self.extract_closure_env_elem(env, 2, 0)?;
                    let mx = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let mf_fn = self.extract_closure_fn_ptr(mf)?;
                    let r_ptr = self.value_to_ptr(r)?;
                    let f = self.builder()
                        .build_indirect_call(fn_type, mf_fn, &[mf.into(), r_ptr.into()], "ap_f")
                        .map_err(|e| CodegenError::Internal(format!("reader ap mf: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader ap mf: void".to_string()))?;
                    let mx_fn = self.extract_closure_fn_ptr(mx)?;
                    let x = self.builder()
                        .build_indirect_call(fn_type, mx_fn, &[mx.into(), r_ptr.into()], "ap_x")
                        .map_err(|e| CodegenError::Internal(format!("reader ap mx: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader ap mx: void".to_string()))?;
                    let f_ptr_val = f.into_pointer_value();
                    let f_fn = self.extract_closure_fn_ptr(f_ptr_val)?;
                    let result = self.builder()
                        .build_indirect_call(fn_type, f_fn, &[f_ptr_val.into(), x.into()], "ap_result")
                        .map_err(|e| CodegenError::Internal(format!("reader ap f(x): {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("reader ap f(x): void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("reader ap return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let mf_ptr = self.value_to_ptr(mf_val)?;
                let mx_ptr = self.value_to_ptr(mx_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), mf_ptr.into()),
                    (VarId::new(900001), mx_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "ReaderT.lift" | "ReaderT.liftIO" => {
                // \r -> action (const function) where action = args[0]
                let action_val = args[0];
                let fn_name = "bhc_reader_t_lift";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let _r = func.get_nth_param(1).unwrap();
                    let action = self.extract_closure_env_elem(env, 1, 0)?;
                    self.builder().build_return(Some(&action))
                        .map_err(|e| CodegenError::Internal(format!("reader lift return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let a_ptr = self.value_to_ptr(action_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), a_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }

            // StateT operations (zero-arity: get returns closure \s -> (s, s))
            "get" => self.lower_builtin_get(),

            // StateT operations with pre-lowered args
            "put" => {
                // put s' = closure \_ -> ((), s')
                let s_val = args[0];
                let fn_name = "bhc_state_t_put";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let _s = func.get_nth_param(1).unwrap();
                    let new_s = self.extract_closure_env_elem(env, 1, 0)?;
                    let unit_val = ptr_type.const_null();
                    let pair = self.alloc_pair(unit_val.into(), new_s.into())?;
                    self.builder().build_return(Some(&pair))
                        .map_err(|e| CodegenError::Internal(format!("put return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let s_ptr = self.value_to_ptr(s_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), s_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }
            "modify" => {
                // modify f = closure \s -> ((), f(s))
                let f_val = args[0];
                let fn_name = "bhc_state_t_modify";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let f = self.extract_closure_env_elem(env, 1, 0)?;
                    let f_fn = self.extract_closure_fn_ptr(f)?;
                    let s_ptr_val = self.value_to_ptr(s)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let new_s = self.builder()
                        .build_indirect_call(fn_type, f_fn, &[f.into(), s_ptr_val.into()], "modify_s")
                        .map_err(|e| CodegenError::Internal(format!("modify f call: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("modify f: void".to_string()))?;
                    let unit_val = ptr_type.const_null();
                    let pair = self.alloc_pair(unit_val.into(), new_s)?;
                    self.builder().build_return(Some(&pair))
                        .map_err(|e| CodegenError::Internal(format!("modify return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let f_ptr = self.value_to_ptr(f_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), f_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }
            "gets" => {
                // gets f = closure \s -> (f(s), s)
                let f_val = args[0];
                let fn_name = "bhc_state_t_gets";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let f = self.extract_closure_env_elem(env, 1, 0)?;
                    let f_fn = self.extract_closure_fn_ptr(f)?;
                    let s_ptr_val = self.value_to_ptr(s)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let result = self.builder()
                        .build_indirect_call(fn_type, f_fn, &[f.into(), s_ptr_val.into()], "gets_result")
                        .map_err(|e| CodegenError::Internal(format!("gets f call: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("gets f: void".to_string()))?;
                    let pair = self.alloc_pair(result, s)?;
                    self.builder().build_return(Some(&pair))
                        .map_err(|e| CodegenError::Internal(format!("gets return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let f_ptr = self.value_to_ptr(f_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), f_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }
            "evalStateT" => {
                // evalStateT m s = fst (runStateT m s)
                let m_val = args[0];
                let s_val = args[1];
                let closure = m_val.into_pointer_value();
                let fn_ptr_val = self.extract_closure_fn_ptr(closure)?;
                let s_ptr = self.value_to_ptr(s_val)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let pair_result = self.builder()
                    .build_indirect_call(fn_type, fn_ptr_val, &[closure.into(), s_ptr.into()], "eval_state")
                    .map_err(|e| CodegenError::Internal(format!("evalStateT call: {:?}", e)))?
                    .try_as_basic_value().basic()
                    .ok_or_else(|| CodegenError::Internal("evalStateT: void".to_string()))?;
                let result = self.extract_pair_fst(pair_result.into_pointer_value())?;
                Ok(Some(result.into()))
            }
            "execStateT" => {
                // execStateT m s = snd (runStateT m s)
                let m_val = args[0];
                let s_val = args[1];
                let closure = m_val.into_pointer_value();
                let fn_ptr_val = self.extract_closure_fn_ptr(closure)?;
                let s_ptr = self.value_to_ptr(s_val)?;
                let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                let pair_result = self.builder()
                    .build_indirect_call(fn_type, fn_ptr_val, &[closure.into(), s_ptr.into()], "exec_state")
                    .map_err(|e| CodegenError::Internal(format!("execStateT call: {:?}", e)))?
                    .try_as_basic_value().basic()
                    .ok_or_else(|| CodegenError::Internal("execStateT: void".to_string()))?;
                let result = self.extract_pair_snd(pair_result.into_pointer_value())?;
                Ok(Some(result.into()))
            }

            // StateT instance methods with pre-lowered args
            "StateT.pure" => {
                // \s -> (x, s) where x = args[0]
                let x_val = args[0];
                let fn_name = "bhc_state_t_pure";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let x = self.extract_closure_env_elem(env, 1, 0)?;
                    let pair = self.alloc_pair(x.into(), s)?;
                    self.builder().build_return(Some(&pair))
                        .map_err(|e| CodegenError::Internal(format!("state_t_pure return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let x_ptr = self.value_to_ptr(x_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), x_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }
            "StateT.>>=" => {
                // \s -> let (a, s') = m(s); k(a)(s') where m = args[0], k = args[1]
                let m_val = args[0];
                let k_val = args[1];
                let fn_name = "bhc_state_t_bind";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let m = self.extract_closure_env_elem(env, 2, 0)?;
                    let k = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let m_fn = self.extract_closure_fn_ptr(m)?;
                    let s_ptr_val = self.value_to_ptr(s)?;
                    let pair = self.builder()
                        .build_indirect_call(fn_type, m_fn, &[m.into(), s_ptr_val.into()], "sbind_pair")
                        .map_err(|e| CodegenError::Internal(format!("state bind m: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state bind m: void".to_string()))?;
                    let pair_ptr = pair.into_pointer_value();
                    let a = self.extract_pair_fst(pair_ptr)?;
                    let s_prime = self.extract_pair_snd(pair_ptr)?;
                    let k_fn = self.extract_closure_fn_ptr(k)?;
                    let kr = self.builder()
                        .build_indirect_call(fn_type, k_fn, &[k.into(), a.into()], "sbind_kr")
                        .map_err(|e| CodegenError::Internal(format!("state bind k: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state bind k: void".to_string()))?;
                    let kr_ptr = kr.into_pointer_value();
                    let kr_fn = self.extract_closure_fn_ptr(kr_ptr)?;
                    let result = self.builder()
                        .build_indirect_call(fn_type, kr_fn, &[kr_ptr.into(), s_prime.into()], "sbind_result")
                        .map_err(|e| CodegenError::Internal(format!("state bind kr: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state bind kr: void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("state bind return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let m_ptr = self.value_to_ptr(m_val)?;
                let k_ptr = self.value_to_ptr(k_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), m_ptr.into()),
                    (VarId::new(900001), k_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "StateT.>>" => {
                // \s -> let (_, s') = m1(s); m2(s') where m1 = args[0], m2 = args[1]
                let m1_val = args[0];
                let m2_val = args[1];
                let fn_name = "bhc_state_t_then";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let m1 = self.extract_closure_env_elem(env, 2, 0)?;
                    let m2 = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let m1_fn = self.extract_closure_fn_ptr(m1)?;
                    let s_ptr_val = self.value_to_ptr(s)?;
                    let pair = self.builder()
                        .build_indirect_call(fn_type, m1_fn, &[m1.into(), s_ptr_val.into()], "sthen_pair")
                        .map_err(|e| CodegenError::Internal(format!("state then m1: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state then m1: void".to_string()))?;
                    let s_prime = self.extract_pair_snd(pair.into_pointer_value())?;
                    let m2_fn = self.extract_closure_fn_ptr(m2)?;
                    let result = self.builder()
                        .build_indirect_call(fn_type, m2_fn, &[m2.into(), s_prime.into()], "sthen_result")
                        .map_err(|e| CodegenError::Internal(format!("state then m2: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state then m2: void".to_string()))?;
                    self.builder().build_return(Some(&result))
                        .map_err(|e| CodegenError::Internal(format!("state then return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let m1_ptr = self.value_to_ptr(m1_val)?;
                let m2_ptr = self.value_to_ptr(m2_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), m1_ptr.into()),
                    (VarId::new(900001), m2_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "StateT.fmap" => {
                // \s -> let (a, s') = m(s) in (f(a), s') where f = args[0], m = args[1]
                let f_val = args[0];
                let m_val = args[1];
                let fn_name = "bhc_state_t_fmap";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let f = self.extract_closure_env_elem(env, 2, 0)?;
                    let m = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let m_fn = self.extract_closure_fn_ptr(m)?;
                    let s_ptr_val = self.value_to_ptr(s)?;
                    let pair = self.builder()
                        .build_indirect_call(fn_type, m_fn, &[m.into(), s_ptr_val.into()], "sfmap_pair")
                        .map_err(|e| CodegenError::Internal(format!("state fmap m: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state fmap m: void".to_string()))?;
                    let pair_ptr = pair.into_pointer_value();
                    let a = self.extract_pair_fst(pair_ptr)?;
                    let s_prime = self.extract_pair_snd(pair_ptr)?;
                    let f_fn = self.extract_closure_fn_ptr(f)?;
                    let fa = self.builder()
                        .build_indirect_call(fn_type, f_fn, &[f.into(), a.into()], "sfmap_fa")
                        .map_err(|e| CodegenError::Internal(format!("state fmap f: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state fmap f: void".to_string()))?;
                    let result_pair = self.alloc_pair(fa, s_prime.into())?;
                    self.builder().build_return(Some(&result_pair))
                        .map_err(|e| CodegenError::Internal(format!("state fmap return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let f_ptr = self.value_to_ptr(f_val)?;
                let m_ptr = self.value_to_ptr(m_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), f_ptr.into()),
                    (VarId::new(900001), m_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "StateT.<*>" => {
                // \s -> let (f, s') = mf(s); (x, s'') = mx(s') in (f(x), s'')
                let mf_val = args[0];
                let mx_val = args[1];
                let fn_name = "bhc_state_t_ap";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let mf = self.extract_closure_env_elem(env, 2, 0)?;
                    let mx = self.extract_closure_env_elem(env, 2, 1)?;
                    let fn_type = ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false);
                    let mf_fn = self.extract_closure_fn_ptr(mf)?;
                    let s_ptr_val = self.value_to_ptr(s)?;
                    let pair1 = self.builder()
                        .build_indirect_call(fn_type, mf_fn, &[mf.into(), s_ptr_val.into()], "sap_p1")
                        .map_err(|e| CodegenError::Internal(format!("state ap mf: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state ap mf: void".to_string()))?;
                    let pair1_ptr = pair1.into_pointer_value();
                    let f = self.extract_pair_fst(pair1_ptr)?;
                    let s_prime = self.extract_pair_snd(pair1_ptr)?;
                    let mx_fn = self.extract_closure_fn_ptr(mx)?;
                    let pair2 = self.builder()
                        .build_indirect_call(fn_type, mx_fn, &[mx.into(), s_prime.into()], "sap_p2")
                        .map_err(|e| CodegenError::Internal(format!("state ap mx: {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state ap mx: void".to_string()))?;
                    let pair2_ptr = pair2.into_pointer_value();
                    let x = self.extract_pair_fst(pair2_ptr)?;
                    let s_double_prime = self.extract_pair_snd(pair2_ptr)?;
                    let f_fn_ptr = self.extract_closure_fn_ptr(f)?;
                    let fx = self.builder()
                        .build_indirect_call(fn_type, f_fn_ptr, &[f.into(), x.into()], "sap_fx")
                        .map_err(|e| CodegenError::Internal(format!("state ap f(x): {:?}", e)))?
                        .try_as_basic_value().basic()
                        .ok_or_else(|| CodegenError::Internal("state ap f(x): void".to_string()))?;
                    let result_pair = self.alloc_pair(fx, s_double_prime.into())?;
                    self.builder().build_return(Some(&result_pair))
                        .map_err(|e| CodegenError::Internal(format!("state ap return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let mf_ptr = self.value_to_ptr(mf_val)?;
                let mx_ptr = self.value_to_ptr(mx_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[
                    (VarId::new(900000), mf_ptr.into()),
                    (VarId::new(900001), mx_ptr.into()),
                ])?;
                Ok(Some(closure_ptr.into()))
            }
            "StateT.lift" | "StateT.liftIO" => {
                // \s -> (action, s) where action = args[0]
                let action_val = args[0];
                let fn_name = "bhc_state_t_lift";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let s = func.get_nth_param(1).unwrap();
                    let action = self.extract_closure_env_elem(env, 1, 0)?;
                    let pair = self.alloc_pair(action.into(), s)?;
                    self.builder().build_return(Some(&pair))
                        .map_err(|e| CodegenError::Internal(format!("state lift return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let a_ptr = self.value_to_ptr(action_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), a_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }

            // Generic lift/liftIO (delegate to ReaderT versions as default)
            "lift" => {
                let action_val = args[0];
                let fn_name = "bhc_reader_t_lift";
                let func = self.get_or_create_transformer_fn(fn_name);
                if func.count_basic_blocks() == 0 {
                    let entry = self.llvm_ctx.append_basic_block(func, "entry");
                    let saved_bb = self.builder().get_insert_block();
                    self.builder().position_at_end(entry);
                    let env = func.get_nth_param(0).unwrap().into_pointer_value();
                    let _r = func.get_nth_param(1).unwrap();
                    let action = self.extract_closure_env_elem(env, 1, 0)?;
                    self.builder().build_return(Some(&action))
                        .map_err(|e| CodegenError::Internal(format!("lift return: {:?}", e)))?;
                    if let Some(bb) = saved_bb { self.builder().position_at_end(bb); }
                }
                let fn_ptr = func.as_global_value().as_pointer_value();
                let a_ptr = self.value_to_ptr(action_val)?;
                let closure_ptr = self.alloc_closure(fn_ptr, &[(VarId::new(900000), a_ptr.into())])?;
                Ok(Some(closure_ptr.into()))
            }
            "liftIO" => {
                // For IO, liftIO = id
                Ok(Some(args[0]))
            }

            _ => Err(CodegenError::Internal(format!(
                "lower_builtin_direct: unhandled builtin '{}'",
                name
            ))),
        }
    }

    /// Execute a primitive operation directly on LLVM values.
    fn lower_primop_direct(
        &mut self,
        op: PrimOp,
        args: &[BasicValueEnum<'ctx>],
    ) -> CodegenResult<BasicValueEnum<'ctx>> {
        let tm = self.type_mapper();

        match op {
            // Binary arithmetic operations
            PrimOp::Add
            | PrimOp::Sub
            | PrimOp::Mul
            | PrimOp::Div
            | PrimOp::Mod
            | PrimOp::Rem
            | PrimOp::Quot => {
                // Unbox arguments
                let lhs = self.ptr_to_int(args[0].into_pointer_value())?;
                let rhs = self.ptr_to_int(args[1].into_pointer_value())?;

                let result = match op {
                    PrimOp::Add => self.builder().build_int_add(lhs, rhs, "add"),
                    PrimOp::Sub => self.builder().build_int_sub(lhs, rhs, "sub"),
                    PrimOp::Mul => self.builder().build_int_mul(lhs, rhs, "mul"),
                    PrimOp::Div | PrimOp::Quot => {
                        self.builder().build_int_signed_div(lhs, rhs, "div")
                    }
                    PrimOp::Mod | PrimOp::Rem => {
                        self.builder().build_int_signed_rem(lhs, rhs, "rem")
                    }
                    _ => unreachable!(),
                }
                .map_err(|e| {
                    CodegenError::Internal(format!("failed to build arithmetic: {:?}", e))
                })?;

                Ok(result.into())
            }

            // Comparison operations
            PrimOp::Eq | PrimOp::Ne | PrimOp::Lt | PrimOp::Le | PrimOp::Gt | PrimOp::Ge => {
                let lhs = self.ptr_to_int(args[0].into_pointer_value())?;
                let rhs = self.ptr_to_int(args[1].into_pointer_value())?;

                let predicate = match op {
                    PrimOp::Eq => inkwell::IntPredicate::EQ,
                    PrimOp::Ne => inkwell::IntPredicate::NE,
                    PrimOp::Lt => inkwell::IntPredicate::SLT,
                    PrimOp::Le => inkwell::IntPredicate::SLE,
                    PrimOp::Gt => inkwell::IntPredicate::SGT,
                    PrimOp::Ge => inkwell::IntPredicate::SGE,
                    _ => unreachable!(),
                };

                let cmp = self
                    .builder()
                    .build_int_compare(predicate, lhs, rhs, "cmp")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to build compare: {:?}", e))
                    })?;

                let result = self
                    .builder()
                    .build_int_z_extend(cmp, tm.i64_type(), "cmp_ext")
                    .map_err(|e| CodegenError::Internal(format!("failed to extend: {:?}", e)))?;

                Ok(result.into())
            }

            // Boolean operations
            PrimOp::And => {
                let lhs = self.ptr_to_int(args[0].into_pointer_value())?;
                let rhs = self.ptr_to_int(args[1].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_and(lhs, rhs, "and")
                    .map_err(|e| CodegenError::Internal(format!("failed to build and: {:?}", e)))?;
                Ok(result.into())
            }

            PrimOp::Or => {
                let lhs = self.ptr_to_int(args[0].into_pointer_value())?;
                let rhs = self.ptr_to_int(args[1].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_or(lhs, rhs, "or")
                    .map_err(|e| CodegenError::Internal(format!("failed to build or: {:?}", e)))?;
                Ok(result.into())
            }

            // Unary operations
            PrimOp::Negate => {
                let val = self.ptr_to_int(args[0].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_int_neg(val, "neg")
                    .map_err(|e| CodegenError::Internal(format!("failed to build neg: {:?}", e)))?;
                Ok(result.into())
            }

            PrimOp::Abs => {
                let val = self.ptr_to_int(args[0].into_pointer_value())?;
                let neg = self
                    .builder()
                    .build_int_neg(val, "neg")
                    .map_err(|e| CodegenError::Internal(format!("failed to build neg: {:?}", e)))?;
                let is_neg = self
                    .builder()
                    .build_int_compare(
                        inkwell::IntPredicate::SLT,
                        val,
                        tm.i64_type().const_zero(),
                        "is_neg",
                    )
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to build compare: {:?}", e))
                    })?;
                let result = self
                    .builder()
                    .build_select(is_neg, neg, val, "abs")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to build select: {:?}", e))
                    })?;
                Ok(result)
            }

            PrimOp::Signum => {
                let val = self.ptr_to_int(args[0].into_pointer_value())?;
                let zero = tm.i64_type().const_zero();
                let one = tm.i64_type().const_int(1, false);
                let neg_one = tm.i64_type().const_int(-1i64 as u64, true);

                let is_neg = self
                    .builder()
                    .build_int_compare(inkwell::IntPredicate::SLT, val, zero, "is_neg")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                let is_pos = self
                    .builder()
                    .build_int_compare(inkwell::IntPredicate::SGT, val, zero, "is_pos")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;

                let tmp = self
                    .builder()
                    .build_select(is_neg, neg_one, zero, "tmp")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                let result = self
                    .builder()
                    .build_select(is_pos, one, tmp.into_int_value(), "signum")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result)
            }

            PrimOp::Not => {
                let val = self.ptr_to_int(args[0].into_pointer_value())?;
                let is_zero = self
                    .builder()
                    .build_int_compare(
                        inkwell::IntPredicate::EQ,
                        val,
                        tm.i64_type().const_zero(),
                        "is_zero",
                    )
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                let result = self
                    .builder()
                    .build_int_z_extend(is_zero, tm.i64_type(), "not")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result.into())
            }

            // Bitwise operations
            PrimOp::BitAnd => {
                let lhs = self.ptr_to_int(args[0].into_pointer_value())?;
                let rhs = self.ptr_to_int(args[1].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_and(lhs, rhs, "bitand")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result.into())
            }

            PrimOp::BitOr => {
                let lhs = self.ptr_to_int(args[0].into_pointer_value())?;
                let rhs = self.ptr_to_int(args[1].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_or(lhs, rhs, "bitor")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result.into())
            }

            PrimOp::BitXor => {
                let lhs = self.ptr_to_int(args[0].into_pointer_value())?;
                let rhs = self.ptr_to_int(args[1].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_xor(lhs, rhs, "bitxor")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result.into())
            }

            PrimOp::ShiftL => {
                let val = self.ptr_to_int(args[0].into_pointer_value())?;
                let amt = self.ptr_to_int(args[1].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_left_shift(val, amt, "shl")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result.into())
            }

            PrimOp::ShiftR => {
                let val = self.ptr_to_int(args[0].into_pointer_value())?;
                let amt = self.ptr_to_int(args[1].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_right_shift(val, amt, true, "shr")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result.into())
            }

            PrimOp::Complement => {
                let val = self.ptr_to_int(args[0].into_pointer_value())?;
                let result = self
                    .builder()
                    .build_not(val, "complement")
                    .map_err(|e| CodegenError::Internal(format!("failed: {:?}", e)))?;
                Ok(result.into())
            }
        }
    }

    /// Coerce a value to an integer, unboxing if needed.
    fn coerce_to_int(&self, value: BasicValueEnum<'ctx>) -> CodegenResult<IntValue<'ctx>> {
        match value {
            BasicValueEnum::IntValue(i) => Ok(i),
            BasicValueEnum::PointerValue(p) => self.ptr_to_int(p),
            BasicValueEnum::FloatValue(f) => {
                // Cast float bits to int
                let bits = self
                    .builder()
                    .build_bit_cast(f, self.type_mapper().i64_type(), "float_to_int")
                    .map_err(|e| CodegenError::Internal(format!("float to int failed: {:?}", e)))?;
                Ok(bits.into_int_value())
            }
            _ => Err(CodegenError::TypeError("cannot coerce to int".to_string())),
        }
    }

    /// Coerce a value to f64, unboxing if needed.
    fn coerce_to_f64(&self, value: BasicValueEnum<'ctx>) -> CodegenResult<FloatValue<'ctx>> {
        match value {
            BasicValueEnum::FloatValue(f) => Ok(f),
            BasicValueEnum::IntValue(i) => {
                // Cast int bits to float (for boxed floats)
                let f = self
                    .builder()
                    .build_bit_cast(i, self.type_mapper().f64_type(), "int_to_float")
                    .map_err(|e| CodegenError::Internal(format!("int to float failed: {:?}", e)))?;
                Ok(f.into_float_value())
            }
            BasicValueEnum::PointerValue(p) => {
                // Unbox: ptr -> i64 -> f64 bits
                let int_val = self.ptr_to_int(p)?;
                let f = self
                    .builder()
                    .build_bit_cast(int_val, self.type_mapper().f64_type(), "ptr_to_float")
                    .map_err(|e| CodegenError::Internal(format!("ptr to float failed: {:?}", e)))?;
                Ok(f.into_float_value())
            }
            _ => Err(CodegenError::TypeError("cannot coerce to f64".to_string())),
        }
    }

    /// Convert an integer to a pointer (boxing).
    fn int_to_ptr(&self, int_val: IntValue<'ctx>) -> CodegenResult<PointerValue<'ctx>> {
        self.builder()
            .build_int_to_ptr(int_val, self.type_mapper().ptr_type(), "box_int")
            .map_err(|e| CodegenError::Internal(format!("failed to box int: {:?}", e)))
    }

    /// Convert a float to a pointer (boxing via bit cast).
    fn f64_to_ptr(&self, float_val: FloatValue<'ctx>) -> CodegenResult<PointerValue<'ctx>> {
        let bits = self
            .builder()
            .build_bit_cast(float_val, self.type_mapper().i64_type(), "float_bits")
            .map_err(|e| CodegenError::Internal(format!("failed to cast float: {:?}", e)))?
            .into_int_value();
        self.builder()
            .build_int_to_ptr(bits, self.type_mapper().ptr_type(), "box_float")
            .map_err(|e| CodegenError::Internal(format!("failed to box float: {:?}", e)))
    }

    /// Convert a pointer to an integer (unbox).
    fn ptr_to_int(&self, ptr: PointerValue<'ctx>) -> CodegenResult<IntValue<'ctx>> {
        self.builder()
            .build_ptr_to_int(ptr, self.type_mapper().i64_type(), "unbox")
            .map_err(|e| CodegenError::Internal(format!("failed to unbox: {:?}", e)))
    }

    /// Check if an expression is a saturated primitive operation.
    fn is_saturated_primop<'a>(&self, expr: &'a Expr) -> Option<(PrimOp, Vec<&'a Expr>)> {
        // Collect arguments while unwrapping applications
        let mut args = Vec::new();
        let mut current = expr;

        while let Expr::App(func, arg, _) = current {
            args.push(arg.as_ref());
            current = func.as_ref();
        }

        // Check if the head is a primitive operation
        if let Expr::Var(var, _) = current {
            if let Some((op, arity)) = self.primitive_op_info(var.name.as_str()) {
                args.reverse();
                if args.len() == arity as usize {
                    return Some((op, args));
                }
            }
        }

        None
    }

    /// Lower a primitive operation to LLVM instructions.
    fn lower_primop(
        &mut self,
        op: PrimOp,
        args: &[&Expr],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        match op {
            // Binary arithmetic operations
            PrimOp::Add
            | PrimOp::Sub
            | PrimOp::Mul
            | PrimOp::Div
            | PrimOp::Mod
            | PrimOp::Rem
            | PrimOp::Quot => {
                let lhs = self
                    .lower_expr(args[0])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                let rhs = self
                    .lower_expr(args[1])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                self.lower_binary_arith(op, lhs, rhs)
            }

            // Binary comparison operations
            PrimOp::Eq | PrimOp::Ne | PrimOp::Lt | PrimOp::Le | PrimOp::Gt | PrimOp::Ge => {
                // Check if we're comparing lists - need special handling
                // Since type info may be Error, check structurally if expr is a list
                let is_list = Self::is_list_expr(args[0]);
                if is_list {
                    // List comparison - dispatch to builtin list comparison
                    let lhs = self.lower_expr(args[0])?.ok_or_else(|| {
                        CodegenError::Internal("primop arg has no value".to_string())
                    })?;
                    let rhs = self.lower_expr(args[1])?.ok_or_else(|| {
                        CodegenError::Internal("primop arg has no value".to_string())
                    })?;
                    return self.lower_list_comparison(op, lhs, rhs);
                }

                let lhs = self
                    .lower_expr(args[0])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                let rhs = self
                    .lower_expr(args[1])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                self.lower_comparison(op, lhs, rhs)
            }

            // Binary boolean operations
            PrimOp::And | PrimOp::Or => {
                let lhs = self
                    .lower_expr(args[0])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                let rhs = self
                    .lower_expr(args[1])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                self.lower_binary_bool(op, lhs, rhs)
            }

            // Binary bitwise operations
            PrimOp::BitAnd | PrimOp::BitOr | PrimOp::BitXor | PrimOp::ShiftL | PrimOp::ShiftR => {
                let lhs = self
                    .lower_expr(args[0])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                let rhs = self
                    .lower_expr(args[1])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                self.lower_binary_bitwise(op, lhs, rhs)
            }

            // Unary operations
            PrimOp::Negate | PrimOp::Abs | PrimOp::Signum | PrimOp::Not | PrimOp::Complement => {
                let arg = self
                    .lower_expr(args[0])?
                    .ok_or_else(|| CodegenError::Internal("primop arg has no value".to_string()))?;
                self.lower_unary(op, arg)
            }
        }
    }

    /// Unbox a value to an integer if it's a pointer (boxed int).
    fn unbox_to_int(
        &self,
        val: BasicValueEnum<'ctx>,
    ) -> CodegenResult<inkwell::values::IntValue<'ctx>> {
        match val {
            BasicValueEnum::IntValue(i) => Ok(i),
            BasicValueEnum::PointerValue(p) => {
                // Unbox: pointer stores int value directly using ptr_to_int
                self.builder()
                    .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_int")
                    .map_err(|e| CodegenError::Internal(format!("failed to unbox int: {:?}", e)))
            }
            _ => Err(CodegenError::TypeError(
                "expected int or boxed int".to_string(),
            )),
        }
    }

    /// Box an integer to a pointer.
    fn box_int(
        &self,
        val: inkwell::values::IntValue<'ctx>,
    ) -> CodegenResult<inkwell::values::PointerValue<'ctx>> {
        self.builder()
            .build_int_to_ptr(val, self.type_mapper().ptr_type(), "box_int")
            .map_err(|e| CodegenError::Internal(format!("failed to box int: {:?}", e)))
    }

    /// Lower a binary arithmetic operation.
    fn lower_binary_arith(
        &self,
        op: PrimOp,
        lhs: BasicValueEnum<'ctx>,
        rhs: BasicValueEnum<'ctx>,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Check if we're dealing with integers or floats
        // Handle boxed values (pointers) by unboxing first
        match (lhs, rhs) {
            (BasicValueEnum::IntValue(l), BasicValueEnum::IntValue(r)) => {
                let result = match op {
                    PrimOp::Add => self.builder().build_int_add(l, r, "add"),
                    PrimOp::Sub => self.builder().build_int_sub(l, r, "sub"),
                    PrimOp::Mul => self.builder().build_int_mul(l, r, "mul"),
                    PrimOp::Div | PrimOp::Quot => self.builder().build_int_signed_div(l, r, "div"),
                    PrimOp::Mod | PrimOp::Rem => self.builder().build_int_signed_rem(l, r, "rem"),
                    _ => return Err(CodegenError::Internal("invalid arith op".to_string())),
                };
                result
                    .map(|v| Some(v.into()))
                    .map_err(|e| CodegenError::Internal(format!("failed to build int op: {:?}", e)))
            }
            (BasicValueEnum::FloatValue(l), BasicValueEnum::FloatValue(r)) => {
                let result = match op {
                    PrimOp::Add => self.builder().build_float_add(l, r, "fadd"),
                    PrimOp::Sub => self.builder().build_float_sub(l, r, "fsub"),
                    PrimOp::Mul => self.builder().build_float_mul(l, r, "fmul"),
                    PrimOp::Div | PrimOp::Quot => self.builder().build_float_div(l, r, "fdiv"),
                    PrimOp::Mod | PrimOp::Rem => self.builder().build_float_rem(l, r, "frem"),
                    _ => return Err(CodegenError::Internal("invalid arith op".to_string())),
                };
                result.map(|v| Some(v.into())).map_err(|e| {
                    CodegenError::Internal(format!("failed to build float op: {:?}", e))
                })
            }
            // Handle boxed integers (pointers) - unbox, compute, rebox
            (BasicValueEnum::PointerValue(_), _) | (_, BasicValueEnum::PointerValue(_)) => {
                let l = self.unbox_to_int(lhs)?;
                let r = self.unbox_to_int(rhs)?;
                let result = match op {
                    PrimOp::Add => self.builder().build_int_add(l, r, "add"),
                    PrimOp::Sub => self.builder().build_int_sub(l, r, "sub"),
                    PrimOp::Mul => self.builder().build_int_mul(l, r, "mul"),
                    PrimOp::Div | PrimOp::Quot => self.builder().build_int_signed_div(l, r, "div"),
                    PrimOp::Mod | PrimOp::Rem => self.builder().build_int_signed_rem(l, r, "rem"),
                    _ => return Err(CodegenError::Internal("invalid arith op".to_string())),
                };
                let int_result = result.map_err(|e| {
                    CodegenError::Internal(format!("failed to build int op: {:?}", e))
                })?;
                // Box the result back to pointer for uniform calling convention
                let boxed = self.box_int(int_result)?;
                Ok(Some(boxed.into()))
            }
            _ => Err(CodegenError::TypeError(
                "arithmetic operations require matching numeric types".to_string(),
            )),
        }
    }

    /// Lower a list comparison operation (== or /= for lists).
    /// This generates a loop that compares elements one by one.
    fn lower_list_comparison(
        &mut self,
        op: PrimOp,
        lhs: BasicValueEnum<'ctx>,
        rhs: BasicValueEnum<'ctx>,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let i64_type = tm.i64_type();
        let current_fn = self
            .builder()
            .get_insert_block()
            .and_then(|b| b.get_parent())
            .ok_or_else(|| CodegenError::Internal("no current function".to_string()))?;

        // Create basic blocks
        let entry_block = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no current block".to_string()))?;
        let loop_block = self
            .llvm_context()
            .append_basic_block(current_fn, "list_cmp_loop");
        let both_nil_block = self
            .llvm_context()
            .append_basic_block(current_fn, "list_cmp_both_nil");
        let one_nil_block = self
            .llvm_context()
            .append_basic_block(current_fn, "list_cmp_one_nil");
        let compare_heads_block = self
            .llvm_context()
            .append_basic_block(current_fn, "list_cmp_heads");
        let heads_equal_block = self
            .llvm_context()
            .append_basic_block(current_fn, "list_cmp_heads_eq");
        let done_block = self
            .llvm_context()
            .append_basic_block(current_fn, "list_cmp_done");

        let lhs_ptr = lhs.into_pointer_value();
        let rhs_ptr = rhs.into_pointer_value();

        // Jump to loop
        self.builder()
            .build_unconditional_branch(loop_block)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Loop block: check tags
        self.builder().position_at_end(loop_block);
        let list1_phi = self
            .builder()
            .build_phi(ptr_type, "list1")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        let list2_phi = self
            .builder()
            .build_phi(ptr_type, "list2")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        list1_phi.add_incoming(&[(&lhs_ptr, entry_block)]);
        list2_phi.add_incoming(&[(&rhs_ptr, entry_block)]);

        let list1_ptr = list1_phi.as_basic_value().into_pointer_value();
        let list2_ptr = list2_phi.as_basic_value().into_pointer_value();

        // Get tags
        let tag1 = self
            .builder()
            .build_load(i64_type, list1_ptr, "tag1")
            .map_err(|e| CodegenError::Internal(format!("failed to load tag1: {:?}", e)))?
            .into_int_value();
        let tag2 = self
            .builder()
            .build_load(i64_type, list2_ptr, "tag2")
            .map_err(|e| CodegenError::Internal(format!("failed to load tag2: {:?}", e)))?
            .into_int_value();

        let zero = i64_type.const_int(0, false);
        let is_nil1 = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::EQ, tag1, zero, "is_nil1")
            .map_err(|e| CodegenError::Internal(format!("failed to build cmp: {:?}", e)))?;
        let is_nil2 = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::EQ, tag2, zero, "is_nil2")
            .map_err(|e| CodegenError::Internal(format!("failed to build cmp: {:?}", e)))?;

        // Check if both are nil
        let both_nil = self
            .builder()
            .build_and(is_nil1, is_nil2, "both_nil")
            .map_err(|e| CodegenError::Internal(format!("failed to build and: {:?}", e)))?;
        self.builder()
            .build_conditional_branch(both_nil, both_nil_block, one_nil_block)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Both nil: lists are equal
        self.builder().position_at_end(both_nil_block);
        let true_val = i64_type.const_int(1, false);
        self.builder()
            .build_unconditional_branch(done_block)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // One nil (but not both): check if either is nil
        self.builder().position_at_end(one_nil_block);
        let either_nil = self
            .builder()
            .build_or(is_nil1, is_nil2, "either_nil")
            .map_err(|e| CodegenError::Internal(format!("failed to build or: {:?}", e)))?;
        let false_val = i64_type.const_int(0, false);
        // If either is nil (but not both), lists are not equal
        self.builder()
            .build_conditional_branch(either_nil, done_block, compare_heads_block)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Compare heads - use extract_adt_field which handles the ADT layout
        self.builder().position_at_end(compare_heads_block);
        let head1 = self.extract_adt_field(list1_ptr, 2, 0)?; // arity=2 (Cons), field=0 (head)
        let head2 = self.extract_adt_field(list2_ptr, 2, 0)?;

        // Compare heads as integers (works for primitive types like Int)
        let head1_int = self
            .builder()
            .build_ptr_to_int(head1, i64_type, "head1_int")
            .map_err(|e| CodegenError::Internal(format!("failed to ptr_to_int: {:?}", e)))?;
        let head2_int = self
            .builder()
            .build_ptr_to_int(head2, i64_type, "head2_int")
            .map_err(|e| CodegenError::Internal(format!("failed to ptr_to_int: {:?}", e)))?;
        let heads_equal = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::EQ, head1_int, head2_int, "heads_eq")
            .map_err(|e| CodegenError::Internal(format!("failed to cmp: {:?}", e)))?;

        // If heads not equal, lists not equal
        self.builder()
            .build_conditional_branch(heads_equal, heads_equal_block, done_block)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Heads equal - continue with tails
        self.builder().position_at_end(heads_equal_block);
        let tail1 = self.extract_adt_field(list1_ptr, 2, 1)?; // arity=2 (Cons), field=1 (tail)
        let tail2 = self.extract_adt_field(list2_ptr, 2, 1)?;

        // Update phis and loop back
        list1_phi.add_incoming(&[(&tail1, heads_equal_block)]);
        list2_phi.add_incoming(&[(&tail2, heads_equal_block)]);
        self.builder()
            .build_unconditional_branch(loop_block)
            .map_err(|e| CodegenError::Internal(format!("failed to branch: {:?}", e)))?;

        // Done block: collect result
        self.builder().position_at_end(done_block);
        let result_phi = self
            .builder()
            .build_phi(i64_type, "list_cmp_result")
            .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;
        result_phi.add_incoming(&[(&true_val, both_nil_block)]); // Both nil = equal
        result_phi.add_incoming(&[(&false_val, one_nil_block)]); // One nil = not equal
        result_phi.add_incoming(&[(&false_val, compare_heads_block)]); // Heads not equal

        let result = result_phi.as_basic_value().into_int_value();

        // For /= we need to invert the result
        let final_result = if matches!(op, PrimOp::Ne) {
            let one = i64_type.const_int(1, false);
            self.builder()
                .build_xor(result, one, "invert")
                .map_err(|e| CodegenError::Internal(format!("failed to xor: {:?}", e)))?
        } else {
            result
        };

        Ok(Some(final_result.into()))
    }

    /// Lower a comparison operation.
    fn lower_comparison(
        &self,
        op: PrimOp,
        lhs: BasicValueEnum<'ctx>,
        rhs: BasicValueEnum<'ctx>,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Helper to do int comparison and return boxed result
        let do_int_cmp = |this: &Self,
                          l: inkwell::values::IntValue<'ctx>,
                          r: inkwell::values::IntValue<'ctx>|
         -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
            use inkwell::IntPredicate;
            let pred = match op {
                PrimOp::Eq => IntPredicate::EQ,
                PrimOp::Ne => IntPredicate::NE,
                PrimOp::Lt => IntPredicate::SLT,
                PrimOp::Le => IntPredicate::SLE,
                PrimOp::Gt => IntPredicate::SGT,
                PrimOp::Ge => IntPredicate::SGE,
                _ => return Err(CodegenError::Internal("invalid comparison op".to_string())),
            };
            let cmp = this
                .builder()
                .build_int_compare(pred, l, r, "cmp")
                .map_err(|e| CodegenError::Internal(format!("failed to build int cmp: {:?}", e)))?;

            // Convert i1 to i64 (0 or 1) for consistency with our Bool representation
            let result = this
                .builder()
                .build_int_z_extend(cmp, this.type_mapper().i64_type(), "cmp_ext")
                .map_err(|e| CodegenError::Internal(format!("failed to extend cmp: {:?}", e)))?;

            Ok(Some(result.into()))
        };

        match (lhs, rhs) {
            (BasicValueEnum::IntValue(l), BasicValueEnum::IntValue(r)) => do_int_cmp(self, l, r),
            (BasicValueEnum::FloatValue(l), BasicValueEnum::FloatValue(r)) => {
                use inkwell::FloatPredicate;
                let pred = match op {
                    PrimOp::Eq => FloatPredicate::OEQ,
                    PrimOp::Ne => FloatPredicate::ONE,
                    PrimOp::Lt => FloatPredicate::OLT,
                    PrimOp::Le => FloatPredicate::OLE,
                    PrimOp::Gt => FloatPredicate::OGT,
                    PrimOp::Ge => FloatPredicate::OGE,
                    _ => return Err(CodegenError::Internal("invalid comparison op".to_string())),
                };
                let cmp = self
                    .builder()
                    .build_float_compare(pred, l, r, "fcmp")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to build float cmp: {:?}", e))
                    })?;

                // Convert i1 to i64
                let result = self
                    .builder()
                    .build_int_z_extend(cmp, self.type_mapper().i64_type(), "fcmp_ext")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to extend fcmp: {:?}", e))
                    })?;

                Ok(Some(result.into()))
            }
            // Handle boxed integers (pointers)
            (BasicValueEnum::PointerValue(_), _) | (_, BasicValueEnum::PointerValue(_)) => {
                let l = self.unbox_to_int(lhs)?;
                let r = self.unbox_to_int(rhs)?;
                do_int_cmp(self, l, r)
            }
            _ => Err(CodegenError::TypeError(
                "comparison operations require matching types".to_string(),
            )),
        }
    }

    /// Lower a binary boolean operation.
    fn lower_binary_bool(
        &self,
        op: PrimOp,
        lhs: BasicValueEnum<'ctx>,
        rhs: BasicValueEnum<'ctx>,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Convert to i64 if needed, then perform operation
        let l = self.to_int_value(lhs)?;
        let r = self.to_int_value(rhs)?;

        // Convert to i1 for boolean operations
        let zero = self.type_mapper().i64_type().const_zero();
        let l_bool = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::NE, l, zero, "l_bool")
            .map_err(|e| CodegenError::Internal(format!("failed to convert to bool: {:?}", e)))?;
        let r_bool = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::NE, r, zero, "r_bool")
            .map_err(|e| CodegenError::Internal(format!("failed to convert to bool: {:?}", e)))?;

        let result = match op {
            PrimOp::And => self.builder().build_and(l_bool, r_bool, "and"),
            PrimOp::Or => self.builder().build_or(l_bool, r_bool, "or"),
            _ => return Err(CodegenError::Internal("invalid bool op".to_string())),
        };

        let bool_result = result
            .map_err(|e| CodegenError::Internal(format!("failed to build bool op: {:?}", e)))?;

        // Extend back to i64
        let extended = self
            .builder()
            .build_int_z_extend(bool_result, self.type_mapper().i64_type(), "bool_ext")
            .map_err(|e| CodegenError::Internal(format!("failed to extend bool: {:?}", e)))?;

        Ok(Some(extended.into()))
    }

    /// Lower a binary bitwise operation.
    fn lower_binary_bitwise(
        &self,
        op: PrimOp,
        lhs: BasicValueEnum<'ctx>,
        rhs: BasicValueEnum<'ctx>,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let l = self.to_int_value(lhs)?;
        let r = self.to_int_value(rhs)?;

        let result = match op {
            PrimOp::BitAnd => self.builder().build_and(l, r, "band"),
            PrimOp::BitOr => self.builder().build_or(l, r, "bor"),
            PrimOp::BitXor => self.builder().build_xor(l, r, "bxor"),
            PrimOp::ShiftL => self.builder().build_left_shift(l, r, "shl"),
            PrimOp::ShiftR => self.builder().build_right_shift(l, r, true, "shr"),
            _ => return Err(CodegenError::Internal("invalid bitwise op".to_string())),
        };

        result
            .map(|v| Some(v.into()))
            .map_err(|e| CodegenError::Internal(format!("failed to build bitwise op: {:?}", e)))
    }

    /// Lower a unary operation.
    fn lower_unary(
        &self,
        op: PrimOp,
        arg: BasicValueEnum<'ctx>,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        match op {
            PrimOp::Negate => match arg {
                BasicValueEnum::IntValue(i) => {
                    let result = self.builder().build_int_neg(i, "neg").map_err(|e| {
                        CodegenError::Internal(format!("failed to negate: {:?}", e))
                    })?;
                    Ok(Some(result.into()))
                }
                BasicValueEnum::FloatValue(f) => {
                    let result = self.builder().build_float_neg(f, "fneg").map_err(|e| {
                        CodegenError::Internal(format!("failed to fnegate: {:?}", e))
                    })?;
                    Ok(Some(result.into()))
                }
                _ => Err(CodegenError::TypeError(
                    "negate requires numeric type".to_string(),
                )),
            },
            PrimOp::Abs => {
                match arg {
                    BasicValueEnum::IntValue(i) => {
                        // abs(x) = x < 0 ? -x : x
                        let zero = self.type_mapper().i64_type().const_zero();
                        let is_neg = self
                            .builder()
                            .build_int_compare(inkwell::IntPredicate::SLT, i, zero, "is_neg")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to compare: {:?}", e))
                            })?;
                        let neg = self.builder().build_int_neg(i, "neg").map_err(|e| {
                            CodegenError::Internal(format!("failed to negate: {:?}", e))
                        })?;
                        let result =
                            self.builder()
                                .build_select(is_neg, neg, i, "abs")
                                .map_err(|e| {
                                    CodegenError::Internal(format!("failed to select: {:?}", e))
                                })?;
                        Ok(Some(result))
                    }
                    BasicValueEnum::FloatValue(f) => {
                        // For floats, use llvm.fabs intrinsic or manual comparison
                        let zero = self.type_mapper().f64_type().const_zero();
                        let is_neg = self
                            .builder()
                            .build_float_compare(inkwell::FloatPredicate::OLT, f, zero, "is_neg")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to compare: {:?}", e))
                            })?;
                        let neg = self.builder().build_float_neg(f, "fneg").map_err(|e| {
                            CodegenError::Internal(format!("failed to fnegate: {:?}", e))
                        })?;
                        let result = self
                            .builder()
                            .build_select(is_neg, neg, f, "fabs")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to select: {:?}", e))
                            })?;
                        Ok(Some(result))
                    }
                    _ => Err(CodegenError::TypeError(
                        "abs requires numeric type".to_string(),
                    )),
                }
            }
            PrimOp::Signum => {
                match arg {
                    BasicValueEnum::IntValue(i) => {
                        // signum(x) = x < 0 ? -1 : (x > 0 ? 1 : 0)
                        let zero = self.type_mapper().i64_type().const_zero();
                        let one = self.type_mapper().i64_type().const_int(1, false);
                        let neg_one = self.type_mapper().i64_type().const_int(-1i64 as u64, true);

                        let is_neg = self
                            .builder()
                            .build_int_compare(inkwell::IntPredicate::SLT, i, zero, "is_neg")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to compare: {:?}", e))
                            })?;
                        let is_pos = self
                            .builder()
                            .build_int_compare(inkwell::IntPredicate::SGT, i, zero, "is_pos")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to compare: {:?}", e))
                            })?;

                        let pos_or_zero = self
                            .builder()
                            .build_select(is_pos, one, zero, "pos_or_zero")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to select: {:?}", e))
                            })?;
                        let result = self
                            .builder()
                            .build_select(is_neg, neg_one, pos_or_zero.into_int_value(), "signum")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to select: {:?}", e))
                            })?;

                        Ok(Some(result))
                    }
                    BasicValueEnum::FloatValue(f) => {
                        let zero = f.get_type().const_zero();
                        let one = f.get_type().const_float(1.0);
                        let neg_one = f.get_type().const_float(-1.0);

                        let is_neg = self
                            .builder()
                            .build_float_compare(inkwell::FloatPredicate::OLT, f, zero, "is_neg")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to compare: {:?}", e))
                            })?;
                        let is_pos = self
                            .builder()
                            .build_float_compare(inkwell::FloatPredicate::OGT, f, zero, "is_pos")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to compare: {:?}", e))
                            })?;

                        let pos_or_zero = self
                            .builder()
                            .build_select(is_pos, one, zero, "pos_or_zero")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to select: {:?}", e))
                            })?;
                        let result = self
                            .builder()
                            .build_select(
                                is_neg,
                                neg_one,
                                pos_or_zero.into_float_value(),
                                "fsignum",
                            )
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to select: {:?}", e))
                            })?;

                        Ok(Some(result))
                    }
                    _ => Err(CodegenError::TypeError(
                        "signum requires numeric type".to_string(),
                    )),
                }
            }
            PrimOp::Not => {
                let i = self.to_int_value(arg)?;
                let zero = self.type_mapper().i64_type().const_zero();
                let one = self.type_mapper().i64_type().const_int(1, false);

                // not x = x == 0 ? 1 : 0
                let is_zero = self
                    .builder()
                    .build_int_compare(inkwell::IntPredicate::EQ, i, zero, "is_zero")
                    .map_err(|e| CodegenError::Internal(format!("failed to compare: {:?}", e)))?;
                let result = self
                    .builder()
                    .build_select(is_zero, one, zero, "not")
                    .map_err(|e| CodegenError::Internal(format!("failed to select: {:?}", e)))?;

                Ok(Some(result))
            }
            PrimOp::Complement => {
                let i = self.to_int_value(arg)?;
                let result = self.builder().build_not(i, "complement").map_err(|e| {
                    CodegenError::Internal(format!("failed to complement: {:?}", e))
                })?;
                Ok(Some(result.into()))
            }
            _ => Err(CodegenError::Internal("invalid unary op".to_string())),
        }
    }

    /// Convert a basic value to an int value.
    fn to_int_value(&self, val: BasicValueEnum<'ctx>) -> CodegenResult<IntValue<'ctx>> {
        match val {
            BasicValueEnum::IntValue(i) => Ok(i),
            BasicValueEnum::PointerValue(p) => {
                // Pointer might be a boxed int - convert
                self.builder()
                    .build_ptr_to_int(p, self.type_mapper().i64_type(), "ptr_to_int")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to convert ptr to int: {:?}", e))
                    })
            }
            _ => Err(CodegenError::TypeError(
                "expected integer value".to_string(),
            )),
        }
    }

    /// Lower a function application.
    ///
    /// Handles four cases:
    /// 1. Builtin function (e.g., `head xs`) - generate specialized code
    /// 2. Primitive operation (e.g., `1 + 2`) - generate LLVM instruction
    /// 3. Constructor application (e.g., `Just 42`) - allocate ADT value
    /// 4. Function call - generate call instruction
    fn lower_application(
        &mut self,
        func: &Expr,
        arg: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // First, reconstruct the full application to check for special cases
        let full_app = Expr::App(Box::new(func.clone()), Box::new(arg.clone()), func.span());

        // Check if this is a saturated builtin function
        if let Some((name, builtin_args)) = self.is_saturated_builtin(&full_app) {
            return self.lower_builtin(name, &builtin_args);
        }

        // Check if this is a saturated primitive operation
        if let Some((op, prim_args)) = self.is_saturated_primop(&full_app) {
            return self.lower_primop(op, &prim_args);
        }

        // Check if this is a saturated constructor application
        if let Some((tag, arity, con_args)) = self.is_saturated_constructor(&full_app) {
            return self.lower_constructor_application(tag, arity, &con_args);
        }

        // Not a primop or constructor - proceed with function call
        // Collect all arguments (for curried applications)
        let mut args = vec![arg];
        let mut current = func;

        while let Expr::App(inner_func, inner_arg, _) = current {
            args.push(inner_arg);
            current = inner_func;
        }

        args.reverse();

        // Get the function being called
        match current {
            Expr::Var(var, _) => {
                let name = var.name.as_str();

                // Check if this is a nullary constructor (no args, just a value)
                if let Some((tag, arity)) = self.constructor_info(name) {
                    if arity == 0 {
                        // Nullary constructor like True, False, Nothing, ()
                        return self.lower_constructor_application(tag, 0, &[]);
                    }
                }

                // Check if this is an RTS builtin
                if let Some(rts_id) = self.rts_function_id(name) {
                    let fn_val = self.functions.get(&rts_id).copied().ok_or_else(|| {
                        CodegenError::Internal(format!("RTS function not declared: {}", name))
                    })?;
                    return self.lower_direct_call(fn_val, &args);
                }

                // Check if this is a known top-level function
                if let Some(fn_val) = self.functions.get(&var.id).copied() {
                    return self.lower_direct_call(fn_val, &args);
                }

                // Check if this is a closure in the environment
                if let Some(closure_val) = self.env.get(&var.id).copied() {
                    return self.lower_closure_call(closure_val, &args);
                }

                // Check if this is an imported (external) function from another module
                if let Some(&fn_val) = self.external_functions.get(&var.name) {
                    return self.lower_direct_call(fn_val, &args);
                }

                Err(CodegenError::Internal(format!(
                    "unknown function: {}",
                    name
                )))
            }
            _ => {
                // Indirect call - evaluate the function expression
                let func_val = self.lower_expr(current)?.ok_or_else(|| {
                    CodegenError::Internal("function expression has no value".to_string())
                })?;

                // Treat as closure call
                self.lower_closure_call(func_val, &args)
            }
        }
    }

    /// Lower a direct function call (to a known function).
    fn lower_direct_call(
        &mut self,
        fn_val: FunctionValue<'ctx>,
        args: &[&Expr],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Get the function's expected parameter count (excluding env pointer)
        let fn_type = fn_val.get_type();
        let expected_params = fn_type.count_param_types() as usize;
        let expected_args = if expected_params > 0 {
            expected_params - 1
        } else {
            0
        }; // Subtract env pointer

        // Check for over-application: more args than the function expects
        if args.len() > expected_args {
            // Split args: first part goes to this function, rest goes to the returned closure
            let (fn_args, remaining_args) = args.split_at(expected_args);

            // Call the function with its expected args
            let closure_result = self.lower_direct_call_inner(fn_val, fn_args)?;

            // The result should be a closure - call it with remaining args
            if let Some(closure_val) = closure_result {
                return self.lower_closure_call(closure_val, remaining_args);
            } else {
                return Err(CodegenError::Internal(
                    "function returned no value for over-application".to_string(),
                ));
            }
        }

        // Check for under-application: fewer args than the function expects
        if args.len() < expected_args {
            return self.lower_partial_application(fn_val, args, expected_args);
        }

        // Exact application
        self.lower_direct_call_inner(fn_val, args)
    }

    /// Lower a partial application (under-application) to a PAP closure.
    ///
    /// Creates a PAP wrapper function that takes the remaining args and calls
    /// the original function with all args combined.
    fn lower_partial_application(
        &mut self,
        fn_val: FunctionValue<'ctx>,
        applied_args: &[&Expr],
        expected_args: usize,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();
        let i64_type = tm.i64_type();

        let num_applied = applied_args.len();
        let num_remaining = expected_args - num_applied;

        // Lower the applied arguments
        let was_tail = self.in_tail_position;
        self.in_tail_position = false;

        let mut applied_vals: Vec<(VarId, BasicValueEnum<'ctx>)> = Vec::new();
        for (i, arg_expr) in applied_args.iter().enumerate() {
            if let Some(val) = self.lower_expr(arg_expr)? {
                // Use a dummy VarId for PAP captured args
                applied_vals.push((VarId::new(10000 + i), val));
            }
        }

        self.in_tail_position = was_tail;

        // Create the PAP wrapper function
        // Signature: (ptr env, ptr arg1, ptr arg2, ...) -> ptr
        let fn_name = fn_val.get_name().to_str().unwrap_or("fn");
        let wrapper_name = format!("pap_{}_{}", fn_name, num_applied);

        // Check if wrapper already exists
        let wrapper_fn = if let Some(existing) =
            self.module.llvm_module().get_function(&wrapper_name)
        {
            existing
        } else {
            // Create param types: env + remaining args
            let mut wrapper_param_types: Vec<inkwell::types::BasicMetadataTypeEnum<'ctx>> =
                Vec::new();
            wrapper_param_types.push(ptr_type.into()); // env/closure pointer
            for _ in 0..num_remaining {
                wrapper_param_types.push(ptr_type.into());
            }

            let wrapper_fn_type = ptr_type.fn_type(&wrapper_param_types, false);
            let wrapper_fn =
                self.module
                    .llvm_module()
                    .add_function(&wrapper_name, wrapper_fn_type, None);

            // Build the wrapper function body
            let entry_bb = self.llvm_ctx.append_basic_block(wrapper_fn, "entry");
            let current_bb = self.builder().get_insert_block();

            self.builder().position_at_end(entry_bb);

            // Extract applied args from closure environment
            let closure_ptr = wrapper_fn.get_first_param().unwrap().into_pointer_value();
            let closure_ty = self.closure_type(num_applied as u32);

            let mut call_args: Vec<inkwell::values::BasicMetadataValueEnum<'ctx>> = Vec::new();
            // Original function expects null env for direct calls
            call_args.push(ptr_type.const_null().into());

            // Load applied args from env
            for i in 0..num_applied {
                let env_slot = self
                    .builder()
                    .build_struct_gep(closure_ty, closure_ptr, 2, "env_slot")
                    .map_err(|e| CodegenError::Internal(format!("PAP gep failed: {:?}", e)))?;

                let elem_ptr = unsafe {
                    self.builder()
                        .build_in_bounds_gep(
                            ptr_type.array_type(num_applied as u32),
                            env_slot,
                            &[i64_type.const_zero(), i64_type.const_int(i as u64, false)],
                            &format!("pap_arg_{}", i),
                        )
                        .map_err(|e| {
                            CodegenError::Internal(format!("PAP elem gep failed: {:?}", e))
                        })?
                };

                let arg_val = self
                    .builder()
                    .build_load(ptr_type, elem_ptr, &format!("pap_load_{}", i))
                    .map_err(|e| CodegenError::Internal(format!("PAP load failed: {:?}", e)))?;

                call_args.push(arg_val.into());
            }

            // Add remaining args from wrapper params
            for i in 0..num_remaining {
                let param = wrapper_fn.get_nth_param((i + 1) as u32).unwrap(); // +1 to skip env
                call_args.push(param.into());
            }

            // Call the original function
            let result = self
                .builder()
                .build_call(fn_val, &call_args, "pap_call")
                .map_err(|e| CodegenError::Internal(format!("PAP call failed: {:?}", e)))?
                .try_as_basic_value()
                .basic();

            // Return the result
            if let Some(ret_val) = result {
                self.builder()
                    .build_return(Some(&ret_val))
                    .map_err(|e| CodegenError::Internal(format!("PAP return failed: {:?}", e)))?;
            } else {
                self.builder()
                    .build_return(Some(&ptr_type.const_null()))
                    .map_err(|e| CodegenError::Internal(format!("PAP return failed: {:?}", e)))?;
            }

            // Restore insertion point
            if let Some(bb) = current_bb {
                self.builder().position_at_end(bb);
            }

            wrapper_fn
        };

        // Create closure pointing to the wrapper with applied args as env
        let wrapper_ptr = wrapper_fn.as_global_value().as_pointer_value();
        let closure_ptr = self.alloc_closure(wrapper_ptr, &applied_vals)?;

        Ok(Some(closure_ptr.into()))
    }

    /// Inner implementation of direct call (doesn't handle over-application).
    fn lower_direct_call_inner(
        &mut self,
        fn_val: FunctionValue<'ctx>,
        args: &[&Expr],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Arguments are not in tail position
        let was_tail = self.in_tail_position;
        self.in_tail_position = false;

        // All functions take (env_ptr, args...) for uniform calling convention
        let mut llvm_args = Vec::new();
        // First arg is env/closure pointer (null for direct calls)
        let null_env = self.type_mapper().ptr_type().const_null();
        llvm_args.push(null_env.into());

        // Lower remaining arguments and convert to pointers
        for arg_expr in args {
            if let Some(val) = self.lower_expr(arg_expr)? {
                // Box non-pointer values to pointers for uniform calling convention
                let ptr_val = self.value_to_ptr(val)?;
                llvm_args.push(ptr_val.into());
            }
        }

        // Restore tail position flag
        self.in_tail_position = was_tail;

        // Build the call
        let call = self
            .builder()
            .build_call(fn_val, &llvm_args, "call")
            .map_err(|e| CodegenError::Internal(format!("failed to build call: {:?}", e)))?;

        // Mark as tail call if in tail position
        if self.in_tail_position {
            call.set_tail_call(true);
        }

        Ok(call.try_as_basic_value().basic())
    }

    /// Lower a closure call (indirect call through closure struct).
    fn lower_closure_call(
        &mut self,
        closure_val: BasicValueEnum<'ctx>,
        args: &[&Expr],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();

        // Get closure pointer
        let closure_ptr = match closure_val {
            BasicValueEnum::PointerValue(p) => p,
            _ => {
                return Err(CodegenError::Internal(
                    "closure value is not a pointer".to_string(),
                ))
            }
        };

        // Extract function pointer from closure
        let fn_ptr = self.extract_closure_fn_ptr(closure_ptr)?;

        // Build function type for the call:
        // - First param is the closure pointer (environment)
        // - Remaining params are the arguments
        let mut param_types: Vec<inkwell::types::BasicMetadataTypeEnum<'ctx>> = Vec::new();
        param_types.push(ptr_type.into()); // closure/env pointer

        for _ in args {
            param_types.push(ptr_type.into());
        }

        let fn_type = ptr_type.fn_type(&param_types, false);

        // Arguments are not in tail position
        let was_tail = self.in_tail_position;
        self.in_tail_position = false;

        // Lower arguments
        let mut llvm_args: Vec<inkwell::values::BasicMetadataValueEnum<'ctx>> = Vec::new();
        llvm_args.push(closure_ptr.into()); // Pass closure as first argument (environment)

        for arg_expr in args {
            if let Some(val) = self.lower_expr(arg_expr)? {
                // Convert to pointer for uniform calling convention
                let ptr_val = self.value_to_ptr(val)?;
                llvm_args.push(ptr_val.into());
            }
        }

        // Restore tail position flag
        self.in_tail_position = was_tail;

        // Build indirect call through function pointer
        let call = self
            .builder()
            .build_indirect_call(fn_type, fn_ptr, &llvm_args, "closure_call")
            .map_err(|e| {
                CodegenError::Internal(format!("failed to build closure call: {:?}", e))
            })?;

        // Mark as tail call if in tail position
        if self.in_tail_position {
            call.set_tail_call(true);
        }

        Ok(call.try_as_basic_value().basic())
    }

    /// Lower a constructor application to an ADT value.
    ///
    /// Allocates an ADT value with the given tag and stores the arguments as fields.
    fn lower_constructor_application(
        &mut self,
        tag: u32,
        arity: u32,
        args: &[&Expr],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Allocate the ADT value
        let adt_ptr = self.alloc_adt(tag, arity)?;

        // Store each argument as a field
        for (i, arg_expr) in args.iter().enumerate() {
            if let Some(arg_val) = self.lower_expr(arg_expr)? {
                self.store_adt_field(adt_ptr, arity, i as u32, arg_val)?;
            }
        }

        // Return the pointer to the ADT value
        Ok(Some(adt_ptr.into()))
    }

    /// Lower a let binding.
    fn lower_let(
        &mut self,
        bind: &Bind,
        body: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        match bind {
            Bind::NonRec(var, rhs) => {
                // Lower the right-hand side (NOT in tail position)
                let was_tail = self.in_tail_position;
                self.in_tail_position = false;
                let rhs_result = self.lower_expr(rhs.as_ref())?;
                self.in_tail_position = was_tail;

                if let Some(val) = rhs_result {
                    // Bind the variable
                    self.env.insert(var.id, val);
                }

                // Lower the body (preserves tail position from parent)
                let result = self.lower_expr(body)?;

                // Remove the binding (for proper scoping)
                self.env.remove(&var.id);

                Ok(result)
            }

            Bind::Rec(bindings) => {
                // For recursive let bindings, we lift them to top-level functions.
                // This works because:
                // 1. We declare all the functions first (so they can reference each other)
                // 2. Then we define their bodies
                // 3. The body of the let can then call them

                // Save the current insertion point
                let current_block = self.builder().get_insert_block();

                // First pass: declare all recursive functions
                for (var, _expr) in bindings {
                    // Generate a unique name for the lifted function
                    let lifted_name = format!("{}${}", var.name.as_str(), var.id.index());
                    let fn_type = self.lower_function_type(&var.ty)?;
                    let fn_val = self.module.add_function(&lifted_name, fn_type);
                    self.functions.insert(var.id, fn_val);
                }

                // Second pass: define all recursive functions
                for (var, expr) in bindings {
                    self.lower_recursive_function(var, expr)?;
                }

                // Restore insertion point
                if let Some(block) = current_block {
                    self.builder().position_at_end(block);
                }

                // Lower the body (recursive functions are now available)
                let result = self.lower_expr(body)?;

                // Note: We don't remove the functions from self.functions
                // because they're now top-level and may be needed later.
                // This is fine because VarIds are unique.

                Ok(result)
            }
        }
    }

    /// Lower a recursive function that was lifted from a let binding.
    fn lower_recursive_function(&mut self, var: &Var, expr: &Expr) -> CodegenResult<()> {
        let fn_val = self.functions.get(&var.id).copied().ok_or_else(|| {
            CodegenError::Internal(format!(
                "recursive function not declared: {}",
                var.name.as_str()
            ))
        })?;

        // Create entry block
        let entry = self.llvm_context().append_basic_block(fn_val, "entry");
        self.builder().position_at_end(entry);

        // Handle lambda parameters
        let result = self.lower_function_body(fn_val, expr)?;

        // Check if the current block already has a terminator (e.g., from `error` or `unreachable`)
        // If so, don't add another terminator
        let current_block = self.builder().get_insert_block();
        let has_terminator = current_block
            .map(|bb| bb.get_terminator().is_some())
            .unwrap_or(false);

        if !has_terminator {
            // Build return - convert to pointer if return type is pointer (uniform calling convention)
            let ret_type = fn_val.get_type().get_return_type();
            if let Some(val) = result {
                let ret_val: BasicValueEnum<'ctx> =
                    if ret_type == Some(self.type_mapper().ptr_type().into()) {
                        self.value_to_ptr(val)?.into()
                    } else {
                        val
                    };
                self.builder().build_return(Some(&ret_val)).map_err(|e| {
                    CodegenError::Internal(format!("failed to build return: {:?}", e))
                })?;
            } else {
                self.builder().build_return(None).map_err(|e| {
                    CodegenError::Internal(format!("failed to build return: {:?}", e))
                })?;
            }
        }

        Ok(())
    }

    /// Lower a function body, handling lambda parameters.
    fn lower_function_body(
        &mut self,
        fn_val: FunctionValue<'ctx>,
        expr: &Expr,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // If the expression is a lambda, bind parameters to function arguments
        // Note: param_idx starts at 1 because index 0 is the env/closure pointer
        let mut current = expr;
        let mut param_idx = 1;

        // Unwrap lambdas, type lambdas, and trivial case expressions.
        // - Lambdas (Lam): bind parameter to function argument
        // - Type lambdas (TyLam): erased at runtime, skip
        // - Trivial Case: pattern matching on a variable we just bound, rebind and continue
        loop {
            match current {
                Expr::Lam(param, body, _span) => {
                    // Term lambda - bind parameter to function argument
                    if let Some(arg) = fn_val.get_nth_param(param_idx) {
                        self.env.insert(param.id, arg);
                    }
                    param_idx += 1;
                    current = body.as_ref();
                }
                Expr::TyLam(_tyvar, body, _span) => {
                    // Type lambda - skip (erased at runtime)
                    current = body.as_ref();
                }
                Expr::Case(scrut, alts, _ty, _span) => {
                    // Check if this is a "trivial" case that just rebinds a variable.
                    // This pattern comes from HIR->Core lowering for pattern matching
                    // on function parameters.
                    //
                    // Pattern: case x of { _ -> body } or case x of { y -> body }
                    // where x is a variable we already have bound AND all alternatives are Default.
                    //
                    // IMPORTANT: Only optimize when ALL alternatives are Default.
                    // If there are any literal or constructor patterns, we must do real pattern matching.
                    let all_default = alts.iter().all(|a| matches!(a.con, AltCon::Default));
                    if all_default {
                        if let Expr::Var(scrut_var, _) = scrut.as_ref() {
                            // Use the first Default alternative
                            if let Some(alt) = alts.first() {
                                // If the alternative has a binder, bind it to the same value as scrut
                                for binder in &alt.binders {
                                    if let Some(val) = self.env.get(&scrut_var.id) {
                                        self.env.insert(binder.id, *val);
                                    }
                                }
                                current = &alt.rhs;
                                continue;
                            }
                        }
                    }
                    // Not a trivial case, stop unwrapping
                    break;
                }
                _ => break,
            }
        }

        // Check if there are remaining LLVM parameters that weren't bound to lambdas.
        // This happens for definitions like `add5 = add 5` where the body is not a lambda
        // but the type implies it takes arguments. We need to eta-expand at codegen.
        let total_params = fn_val.count_params() as u32;
        let remaining_params: Vec<_> = (param_idx..total_params)
            .filter_map(|i| fn_val.get_nth_param(i))
            .collect();

        // Lower the body
        let was_tail = self.in_tail_position;
        self.in_tail_position = remaining_params.is_empty(); // Only tail if no eta-expansion needed
        let result = self.lower_expr(current)?;
        self.in_tail_position = was_tail;

        // If there are remaining parameters, the body should evaluate to a closure.
        // Apply the remaining parameters to it (eta-expansion).
        if !remaining_params.is_empty() {
            if let Some(closure_val) = result {
                // The result should be a closure - call it with remaining params
                let tm = self.type_mapper();
                let ptr_type = tm.ptr_type();

                let closure_ptr = match closure_val {
                    BasicValueEnum::PointerValue(p) => p,
                    _ => {
                        return Err(CodegenError::Internal(
                            "eta-expansion: expected closure but got non-pointer".to_string(),
                        ))
                    }
                };

                // Extract function pointer from closure
                let fn_ptr = self.extract_closure_fn_ptr(closure_ptr)?;

                // Build function type for the call
                let mut param_types: Vec<inkwell::types::BasicMetadataTypeEnum<'ctx>> = Vec::new();
                param_types.push(ptr_type.into()); // closure/env pointer
                for _ in &remaining_params {
                    param_types.push(ptr_type.into());
                }
                let fn_type = ptr_type.fn_type(&param_types, false);

                // Build args: closure ptr + remaining params
                let mut llvm_args: Vec<inkwell::values::BasicMetadataValueEnum<'ctx>> = Vec::new();
                llvm_args.push(closure_ptr.into());
                for param in &remaining_params {
                    // Convert to pointer if needed
                    let ptr_val = self.value_to_ptr(*param)?;
                    llvm_args.push(ptr_val.into());
                }

                // Build indirect call
                let call = self
                    .builder()
                    .build_indirect_call(fn_type, fn_ptr, &llvm_args, "eta_call")
                    .map_err(|e| {
                        CodegenError::Internal(format!(
                            "failed to build eta-expansion call: {:?}",
                            e
                        ))
                    })?;

                return Ok(call.try_as_basic_value().basic());
            } else {
                return Err(CodegenError::Internal(
                    "eta-expansion: body has no value".to_string(),
                ));
            }
        }

        Ok(result)
    }

    /// Lower a case expression.
    ///
    /// Handles three cases:
    /// 1. Literal patterns (Int, Char) - switch on the primitive value
    /// 2. Constructor patterns (DataCon) - switch on the tag, extract fields
    /// 3. Default pattern - catch-all fallback
    fn lower_case(
        &mut self,
        scrut: &Expr,
        alts: &[Alt],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Scrutinee is NOT in tail position
        let was_tail = self.in_tail_position;
        self.in_tail_position = false;
        let scrut_val = self
            .lower_expr(scrut)?
            .ok_or_else(|| CodegenError::Internal("scrutinee has no value".to_string()))?;
        self.in_tail_position = was_tail;

        // Check if all alternatives are Default (no actual pattern matching needed)
        // This happens for simple variable patterns like `f n = 42`
        let all_default = alts.iter().all(|alt| matches!(&alt.con, AltCon::Default));
        if all_default && !alts.is_empty() {
            // Just use the first (and likely only) default alternative
            let alt = &alts[0];

            // Bind any pattern variables to the scrutinee value
            for binder in &alt.binders {
                self.env.insert(binder.id, scrut_val);
            }

            // Lower the RHS (inherits tail position from parent case)
            let result = self.lower_expr(&alt.rhs)?;

            // Clean up bindings
            for binder in &alt.binders {
                self.env.remove(&binder.id);
            }

            return Ok(result);
        }

        // Determine if this is a constructor case or a literal case
        let has_datacon = alts
            .iter()
            .any(|alt| matches!(&alt.con, AltCon::DataCon(_)));

        // Check if this is a Bool case (True/False patterns) with an integer scrutinee
        // This happens when the condition is a comparison result
        let is_bool_case = alts.iter().any(|alt| {
            if let AltCon::DataCon(con) = &alt.con {
                let name = con.name.as_str();
                name == "True"
                    || name == "False"
                    || name == "GHC.Types.True"
                    || name == "GHC.Types.False"
            } else {
                false
            }
        });

        if is_bool_case {
            // Bool case - convert scrutinee to integer if needed
            let int_scrut = match scrut_val {
                BasicValueEnum::IntValue(_) => scrut_val,
                BasicValueEnum::PointerValue(p) => {
                    // Boxed boolean - load the tag from the ADT
                    // Bool is arity 0, so ADT structure is { i64 tag, [0 x ptr] }
                    let adt_ty = self.adt_type(0);
                    let tag_ptr = self
                        .builder()
                        .build_struct_gep(adt_ty, p, 0, "bool_tag_ptr")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to get bool tag ptr: {:?}", e))
                        })?;
                    let tag_val = self
                        .builder()
                        .build_load(self.type_mapper().i64_type(), tag_ptr, "bool_tag")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to load bool tag: {:?}", e))
                        })?;
                    tag_val
                }
                _ => scrut_val, // Fall through to datacon handling
            };
            if matches!(int_scrut, BasicValueEnum::IntValue(_)) {
                return self.lower_case_bool_as_int(int_scrut, alts);
            }
        }

        // Get the scrutinee's type for determining binder types
        let scrut_ty = scrut.ty();

        if has_datacon {
            self.lower_case_datacon(scrut_val, alts, &scrut_ty)
        } else {
            self.lower_case_literal(scrut_val, alts)
        }
    }

    /// Lower a case expression with literal patterns.
    fn lower_case_literal(
        &mut self,
        scrut_val: BasicValueEnum<'ctx>,
        alts: &[Alt],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Determine the type of literals in the alternatives
        let has_int_lit = alts
            .iter()
            .any(|alt| matches!(&alt.con, AltCon::Lit(Literal::Int(_))));
        let has_char_lit = alts
            .iter()
            .any(|alt| matches!(&alt.con, AltCon::Lit(Literal::Char(_))));
        let has_float_lit = alts
            .iter()
            .any(|alt| matches!(&alt.con, AltCon::Lit(Literal::Double(_))));
        let has_string_lit = alts
            .iter()
            .any(|alt| matches!(&alt.con, AltCon::Lit(Literal::String(_))));

        // Dispatch based on scrutinee type
        match scrut_val {
            BasicValueEnum::IntValue(i) => self.lower_case_literal_int(i, alts),
            BasicValueEnum::FloatValue(f) => self.lower_case_literal_float(f, alts),
            BasicValueEnum::PointerValue(p) => {
                // Check if the alternatives have integer/char literals - if so, unbox the pointer
                if has_int_lit || has_char_lit {
                    // Pointer contains a boxed integer - unbox it
                    let int_val = self
                        .builder()
                        .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_for_case")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to unbox for case: {:?}", e))
                        })?;
                    self.lower_case_literal_int(int_val, alts)
                } else if has_float_lit {
                    // Pointer contains a boxed float - unbox it
                    let bits = self
                        .builder()
                        .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_float_bits")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to unbox float: {:?}", e))
                        })?;
                    let float_val = self
                        .builder()
                        .build_bit_cast(bits, self.type_mapper().f64_type(), "to_double")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to cast to double: {:?}", e))
                        })?;
                    if let BasicValueEnum::FloatValue(f) = float_val {
                        self.lower_case_literal_float(f, alts)
                    } else {
                        Err(CodegenError::Internal(
                            "expected float value after unboxing".to_string(),
                        ))
                    }
                } else if has_string_lit {
                    // String pattern matching
                    self.lower_case_literal_string(p, alts)
                } else {
                    // Default case or only Default alternatives - assume integer
                    let int_val = self
                        .builder()
                        .build_ptr_to_int(p, self.type_mapper().i64_type(), "unbox_for_case")
                        .map_err(|e| {
                            CodegenError::Internal(format!("failed to unbox for case: {:?}", e))
                        })?;
                    self.lower_case_literal_int(int_val, alts)
                }
            }
            _ => Err(CodegenError::Unsupported(format!(
                "unsupported scrutinee type for literal case: {:?}",
                scrut_val.get_type()
            ))),
        }
    }

    /// Lower a case expression with integer literal patterns.
    fn lower_case_literal_int(
        &mut self,
        scrut_int: IntValue<'ctx>,
        alts: &[Alt],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let current_fn = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no insert block".to_string()))?
            .get_parent()
            .ok_or_else(|| CodegenError::Internal("no parent function".to_string()))?;

        // Create blocks for each alternative
        let mut blocks = Vec::new();
        let merge_block = self
            .llvm_context()
            .append_basic_block(current_fn, "case_merge");

        let mut default_block = None;
        let mut cases = Vec::new();

        for alt in alts {
            let block = self
                .llvm_context()
                .append_basic_block(current_fn, "case_alt");
            blocks.push(block);

            match &alt.con {
                AltCon::Lit(Literal::Int(n)) => {
                    cases.push((
                        self.type_mapper().i64_type().const_int(*n as u64, true),
                        block,
                    ));
                }
                AltCon::Lit(Literal::Char(c)) => {
                    // Use the same integer type as the scrutinee to avoid type mismatches
                    cases.push((
                        scrut_int
                            .get_type()
                            .const_int(*c as u64, false),
                        block,
                    ));
                }
                AltCon::Default => {
                    // Use the FIRST default block as the switch default.
                    // The pattern compiler adds error fallbacks as additional Defaults,
                    // but we want non-matching cases to go to the first (user-defined) default.
                    if default_block.is_none() {
                        default_block = Some(block);
                    }
                }
                _ => {
                    return Err(CodegenError::Unsupported(format!(
                        "unsupported pattern in literal case: {:?}",
                        alt.con
                    )))
                }
            }
        }

        // Build switch
        // If there's no explicit default, create an unreachable block
        let default = if let Some(db) = default_block {
            db
        } else {
            let unreachable_block = self
                .llvm_context()
                .append_basic_block(current_fn, "case_unreachable");
            unreachable_block
        };

        let _switch = self
            .builder()
            .build_switch(scrut_int, default, &cases)
            .map_err(|e| CodegenError::Internal(format!("failed to build switch: {:?}", e)))?;

        // If we created an unreachable block, fill it in
        if default_block.is_none() {
            self.builder().position_at_end(default);
            self.builder().build_unreachable().map_err(|e| {
                CodegenError::Internal(format!("failed to build unreachable: {:?}", e))
            })?;
        }

        // Generate code for each alternative
        self.lower_case_alternatives(alts, &blocks, merge_block)
    }

    /// Lower a case expression with float/double literal patterns.
    /// Uses chained comparisons since LLVM switch doesn't support floats.
    fn lower_case_literal_float(
        &mut self,
        scrut_float: FloatValue<'ctx>,
        alts: &[Alt],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let current_fn = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no insert block".to_string()))?
            .get_parent()
            .ok_or_else(|| CodegenError::Internal("no parent function".to_string()))?;

        let merge_block = self
            .llvm_context()
            .append_basic_block(current_fn, "float_case_merge");

        // Separate literal alts from default
        let mut literal_alts: Vec<(f64, &Alt)> = Vec::new();
        let mut default_alt: Option<&Alt> = None;

        for alt in alts {
            match &alt.con {
                AltCon::Lit(Literal::Float(f)) => literal_alts.push((*f as f64, alt)),
                AltCon::Lit(Literal::Double(d)) => literal_alts.push((*d, alt)),
                AltCon::Default => default_alt = Some(alt),
                _ => {
                    return Err(CodegenError::Unsupported(format!(
                        "unsupported pattern in float case: {:?}",
                        alt.con
                    )))
                }
            }
        }

        // Create all blocks upfront to avoid creating duplicate blocks
        let mut phi_values: Vec<(BasicValueEnum<'ctx>, inkwell::basic_block::BasicBlock<'ctx>)> =
            Vec::new();

        // Create the default/else block
        let default_block = self
            .llvm_context()
            .append_basic_block(current_fn, "float_default");

        // Create comparison blocks (one per literal except the first which uses current block)
        let mut cmp_blocks: Vec<inkwell::basic_block::BasicBlock<'ctx>> = Vec::new();
        for i in 1..literal_alts.len() {
            cmp_blocks.push(
                self.llvm_context()
                    .append_basic_block(current_fn, &format!("float_cmp_{}", i)),
            );
        }

        // Create match blocks (one per literal)
        let mut match_blocks: Vec<inkwell::basic_block::BasicBlock<'ctx>> = Vec::new();
        for i in 0..literal_alts.len() {
            match_blocks.push(
                self.llvm_context()
                    .append_basic_block(current_fn, &format!("float_match_{}", i)),
            );
        }

        // Generate chain of comparisons
        for (i, (val, alt)) in literal_alts.iter().enumerate() {
            // Position at the comparison block
            if i > 0 {
                self.builder().position_at_end(cmp_blocks[i - 1]);
            }
            // i == 0 uses the current block (already positioned there)

            let match_block = match_blocks[i];

            // Determine next block (next comparison or default)
            let next_block = if i + 1 < literal_alts.len() {
                cmp_blocks[i] // cmp_blocks[0] corresponds to float_cmp_1
            } else {
                default_block
            };

            // Build float comparison (ordered equal)
            // Check if it's f32 or f64 by comparing types
            let is_f32 = scrut_float.get_type() == self.type_mapper().f32_type();
            let const_val = if is_f32 {
                self.type_mapper().f32_type().const_float(*val)
            } else {
                self.type_mapper().f64_type().const_float(*val)
            };
            let cmp = self
                .builder()
                .build_float_compare(
                    inkwell::FloatPredicate::OEQ,
                    scrut_float,
                    const_val,
                    "float_eq",
                )
                .map_err(|e| {
                    CodegenError::Internal(format!("failed to build float cmp: {:?}", e))
                })?;

            self.builder()
                .build_conditional_branch(cmp, match_block, next_block)
                .map_err(|e| {
                    CodegenError::Internal(format!("failed to build cond branch: {:?}", e))
                })?;

            // Generate code for match block
            self.builder().position_at_end(match_block);
            if let Some(result) = self.lower_expr(&alt.rhs)? {
                phi_values.push((result, self.builder().get_insert_block().unwrap()));
            }
            self.builder()
                .build_unconditional_branch(merge_block)
                .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        }

        // Generate default block
        self.builder().position_at_end(default_block);
        if let Some(alt) = default_alt {
            // Bind scrutinee to any pattern variables
            for binder in &alt.binders {
                self.env.insert(binder.id, scrut_float.into());
            }
            if let Some(result) = self.lower_expr(&alt.rhs)? {
                phi_values.push((result, self.builder().get_insert_block().unwrap()));
            }
            for binder in &alt.binders {
                self.env.remove(&binder.id);
            }
            self.builder()
                .build_unconditional_branch(merge_block)
                .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        } else {
            // No default - generate unreachable
            self.builder().build_unreachable().map_err(|e| {
                CodegenError::Internal(format!("failed to build unreachable: {:?}", e))
            })?;
        }

        // Build phi in merge block
        self.builder().position_at_end(merge_block);
        if phi_values.is_empty() {
            Ok(None)
        } else {
            let target_type = phi_values[0].0.get_type();

            // Coerce all values to the target type
            let mut coerced_values: Vec<(
                BasicValueEnum<'ctx>,
                inkwell::basic_block::BasicBlock<'ctx>,
            )> = Vec::new();

            for (val, block) in &phi_values {
                if val.get_type() == target_type {
                    coerced_values.push((*val, *block));
                } else {
                    let terminator = block.get_terminator();
                    if let Some(term) = terminator {
                        self.builder().position_before(&term);
                        let coerced = self.coerce_to_type(*val, target_type)?;
                        coerced_values.push((coerced, *block));
                    } else {
                        coerced_values.push((*val, *block));
                    }
                }
            }

            self.builder().position_at_end(merge_block);

            let phi = self
                .builder()
                .build_phi(target_type, "float_case_result")
                .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

            for (val, block) in &coerced_values {
                phi.add_incoming(&[(val, *block)]);
            }

            Ok(Some(phi.as_basic_value()))
        }
    }

    /// Lower a case expression with string literal patterns.
    /// Uses strcmp to compare strings.
    fn lower_case_literal_string(
        &mut self,
        scrut_ptr: PointerValue<'ctx>,
        alts: &[Alt],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let current_fn = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no insert block".to_string()))?
            .get_parent()
            .ok_or_else(|| CodegenError::Internal("no parent function".to_string()))?;

        let merge_block = self
            .llvm_context()
            .append_basic_block(current_fn, "str_case_merge");

        // Get or declare strcmp
        let strcmp_fn = self.get_or_declare_strcmp()?;

        // Separate literal alts from default
        let mut literal_alts: Vec<(&Symbol, &Alt)> = Vec::new();
        let mut default_alt: Option<&Alt> = None;

        for alt in alts {
            match &alt.con {
                AltCon::Lit(Literal::String(s)) => literal_alts.push((s, alt)),
                AltCon::Default => default_alt = Some(alt),
                _ => {
                    return Err(CodegenError::Unsupported(format!(
                        "unsupported pattern in string case: {:?}",
                        alt.con
                    )))
                }
            }
        }

        // Create all blocks upfront to avoid creating duplicate blocks
        let mut phi_values: Vec<(BasicValueEnum<'ctx>, inkwell::basic_block::BasicBlock<'ctx>)> =
            Vec::new();
        let default_block = self
            .llvm_context()
            .append_basic_block(current_fn, "str_default");

        // Create comparison blocks (one per literal except the first which uses current block)
        let mut cmp_blocks: Vec<inkwell::basic_block::BasicBlock<'ctx>> = Vec::new();
        for i in 1..literal_alts.len() {
            cmp_blocks.push(
                self.llvm_context()
                    .append_basic_block(current_fn, &format!("str_cmp_{}", i)),
            );
        }

        // Create match blocks (one per literal)
        let mut match_blocks: Vec<inkwell::basic_block::BasicBlock<'ctx>> = Vec::new();
        for i in 0..literal_alts.len() {
            match_blocks.push(
                self.llvm_context()
                    .append_basic_block(current_fn, &format!("str_match_{}", i)),
            );
        }

        // Generate chain of strcmp comparisons
        for (i, (sym, alt)) in literal_alts.iter().enumerate() {
            // Position at the comparison block
            if i > 0 {
                self.builder().position_at_end(cmp_blocks[i - 1]);
            }
            // i == 0 uses the current block (already positioned there)

            let match_block = match_blocks[i];

            // Determine next block (next comparison or default)
            let next_block = if i + 1 < literal_alts.len() {
                cmp_blocks[i] // cmp_blocks[0] corresponds to str_cmp_1
            } else {
                default_block
            };

            // Create global string constant for the pattern
            let str_const = self
                .module
                .add_global_string(&format!("str_pat_{}", i), sym.as_str());

            // Call strcmp(scrut, pattern)
            let cmp_result = self
                .builder()
                .build_call(
                    strcmp_fn,
                    &[scrut_ptr.into(), str_const.into()],
                    "strcmp_result",
                )
                .map_err(|e| CodegenError::Internal(format!("failed to call strcmp: {:?}", e)))?
                .try_as_basic_value()
                .basic()
                .ok_or_else(|| CodegenError::Internal("strcmp returned void".to_string()))?;

            // strcmp returns 0 for equal strings
            let zero = self.type_mapper().i32_type().const_zero();
            let is_equal = self
                .builder()
                .build_int_compare(
                    inkwell::IntPredicate::EQ,
                    cmp_result.into_int_value(),
                    zero,
                    "str_eq",
                )
                .map_err(|e| CodegenError::Internal(format!("failed to build int cmp: {:?}", e)))?;

            self.builder()
                .build_conditional_branch(is_equal, match_block, next_block)
                .map_err(|e| {
                    CodegenError::Internal(format!("failed to build cond branch: {:?}", e))
                })?;

            // Generate match block
            self.builder().position_at_end(match_block);
            if let Some(result) = self.lower_expr(&alt.rhs)? {
                phi_values.push((result, self.builder().get_insert_block().unwrap()));
            }
            self.builder()
                .build_unconditional_branch(merge_block)
                .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        }

        // Generate default block
        self.builder().position_at_end(default_block);
        if let Some(alt) = default_alt {
            for binder in &alt.binders {
                self.env.insert(binder.id, scrut_ptr.into());
            }
            if let Some(result) = self.lower_expr(&alt.rhs)? {
                phi_values.push((result, self.builder().get_insert_block().unwrap()));
            }
            for binder in &alt.binders {
                self.env.remove(&binder.id);
            }
            self.builder()
                .build_unconditional_branch(merge_block)
                .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        } else {
            self.builder().build_unreachable().map_err(|e| {
                CodegenError::Internal(format!("failed to build unreachable: {:?}", e))
            })?;
        }

        // Build phi in merge block
        self.builder().position_at_end(merge_block);
        if phi_values.is_empty() {
            Ok(None)
        } else {
            let target_type = phi_values[0].0.get_type();

            // Coerce all values to the target type
            let mut coerced_values: Vec<(
                BasicValueEnum<'ctx>,
                inkwell::basic_block::BasicBlock<'ctx>,
            )> = Vec::new();

            for (val, block) in &phi_values {
                if val.get_type() == target_type {
                    coerced_values.push((*val, *block));
                } else {
                    let terminator = block.get_terminator();
                    if let Some(term) = terminator {
                        self.builder().position_before(&term);
                        let coerced = self.coerce_to_type(*val, target_type)?;
                        coerced_values.push((coerced, *block));
                    } else {
                        coerced_values.push((*val, *block));
                    }
                }
            }

            self.builder().position_at_end(merge_block);

            let phi = self
                .builder()
                .build_phi(target_type, "str_case_result")
                .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

            for (val, block) in &coerced_values {
                phi.add_incoming(&[(val, *block)]);
            }

            Ok(Some(phi.as_basic_value()))
        }
    }

    /// Get or declare the strcmp function.
    fn get_or_declare_strcmp(&self) -> CodegenResult<FunctionValue<'ctx>> {
        let name = "strcmp";
        if let Some(fn_val) = self.module.get_function(name) {
            return Ok(fn_val);
        }

        // int strcmp(const char*, const char*)
        let tm = self.type_mapper();
        let fn_type = tm
            .i32_type()
            .fn_type(&[tm.ptr_type().into(), tm.ptr_type().into()], false);
        Ok(self.module.add_function(name, fn_type))
    }

    /// Lower a case expression with constructor patterns.
    fn lower_case_datacon(
        &mut self,
        scrut_val: BasicValueEnum<'ctx>,
        alts: &[Alt],
        scrut_ty: &Ty,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Count existing case_alt blocks before we add more
        let current_fn = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no insert block".to_string()))?
            .get_parent()
            .ok_or_else(|| CodegenError::Internal("no parent function".to_string()))?;
        let existing_blocks: Vec<_> = current_fn.get_basic_block_iter().collect();

        // For constructor patterns, scrutinee must be a pointer (ADT value)
        let scrut_ptr = match scrut_val {
            BasicValueEnum::PointerValue(p) => p,
            BasicValueEnum::IntValue(i) => {
                // If it's an int, it might be a boxed value - try to interpret as ptr
                self.builder()
                    .build_int_to_ptr(i, self.type_mapper().ptr_type(), "scrut_ptr")
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to cast scrutinee: {:?}", e))
                    })?
            }
            _ => {
                return Err(CodegenError::Unsupported(
                    "case on non-pointer value with constructor patterns".to_string(),
                ))
            }
        };

        // Extract the tag from the ADT value
        let tag = self.extract_adt_tag(scrut_ptr)?;

        let current_fn = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no insert block".to_string()))?
            .get_parent()
            .ok_or_else(|| CodegenError::Internal("no parent function".to_string()))?;

        // Create blocks for each alternative
        let mut blocks = Vec::new();
        let merge_block = self
            .llvm_context()
            .append_basic_block(current_fn, "case_merge");

        let mut default_block = None;
        let mut cases = Vec::new();

        // Collect DataCon info for field extraction later
        let mut datacon_info: Vec<Option<&DataCon>> = Vec::new();

        for alt in alts {
            let block = self
                .llvm_context()
                .append_basic_block(current_fn, "case_alt");
            blocks.push(block);

            match &alt.con {
                AltCon::DataCon(con) => {
                    let tag_val = self
                        .type_mapper()
                        .i64_type()
                        .const_int(con.tag as u64, false);
                    cases.push((tag_val, block));
                    datacon_info.push(Some(con));
                    // Register this constructor for later use in constructor applications
                    self.register_constructor(con.name.as_str(), con.tag, con.arity);
                }
                AltCon::Default => {
                    default_block = Some(block);
                    datacon_info.push(None);
                }
                AltCon::Lit(_) => {
                    return Err(CodegenError::Unsupported(
                        "mixed literal and constructor patterns".to_string(),
                    ))
                }
            }
        }

        // Build switch on tag
        // If there's no explicit default, create an unreachable block to indicate exhaustive matching
        let default = if let Some(db) = default_block {
            db
        } else {
            // Create an unreachable block for the default case
            // This avoids having merge_block as a direct successor of the switch
            let unreachable_block = self
                .llvm_context()
                .append_basic_block(current_fn, "case_unreachable");
            unreachable_block
        };

        let _switch = self
            .builder()
            .build_switch(tag, default, &cases)
            .map_err(|e| CodegenError::Internal(format!("failed to build switch: {:?}", e)))?;

        // If we created an unreachable block, fill it in
        if default_block.is_none() {
            self.builder().position_at_end(default);
            self.builder().build_unreachable().map_err(|e| {
                CodegenError::Internal(format!("failed to build unreachable: {:?}", e))
            })?;
        }

        // Generate code for each alternative with field extraction
        let result = self.lower_case_datacon_alternatives(
            alts,
            &blocks,
            merge_block,
            scrut_ptr,
            &datacon_info,
            scrut_ty,
        )?;

        Ok(result)
    }

    /// Lower case alternatives (shared logic for RHS generation).
    ///
    /// Uses a two-pass approach to avoid inserting instructions after terminators:
    /// 1. First pass: lower all RHS expressions and collect (value, block) pairs
    /// 2. Second pass: coerce values if needed, then build branches
    ///
    /// Each alternative's RHS is in tail position if the case expression itself is.
    fn lower_case_alternatives(
        &mut self,
        alts: &[Alt],
        blocks: &[inkwell::basic_block::BasicBlock<'ctx>],
        merge_block: inkwell::basic_block::BasicBlock<'ctx>,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Pass 1: Lower all expressions and collect values WITHOUT building branches
        // Each alternative's RHS is in tail position if the case expression is
        let mut collected: Vec<(
            Option<BasicValueEnum<'ctx>>,
            inkwell::basic_block::BasicBlock<'ctx>,
        )> = Vec::new();

        for (i, alt) in alts.iter().enumerate() {
            self.builder().position_at_end(blocks[i]);

            // RHS is in tail position (inherits from parent case expression)
            let result = self.lower_expr(&alt.rhs)?;

            // Get the ACTUAL current block (lower_expr may have created nested blocks)
            let current_block = self.builder().get_insert_block().ok_or_else(|| {
                CodegenError::Internal("no current block after lower_expr".to_string())
            })?;

            collected.push((result, current_block));
        }

        // Determine target type from first non-None value
        let target_type = collected
            .iter()
            .find_map(|(val, _)| val.map(|v| v.get_type()));

        // Pass 2: Coerce values and build branches
        let mut phi_values: Vec<(BasicValueEnum<'ctx>, inkwell::basic_block::BasicBlock<'ctx>)> =
            Vec::new();

        for (result, block) in collected {
            // Position at the end of the block where the value was produced
            self.builder().position_at_end(block);

            // Only add to phi_values if we will branch to merge_block
            // If the block already has a terminator (e.g., error call with unreachable),
            // it doesn't reach merge_block and shouldn't contribute to the PHI
            if block.get_terminator().is_none() {
                if let Some(val) = result {
                    // Coerce if needed (BEFORE building the branch)
                    let final_val = if let Some(target) = target_type {
                        if val.get_type() != target {
                            self.coerce_to_type(val, target)?
                        } else {
                            val
                        }
                    } else {
                        val
                    };

                    // Get the current block
                    let final_block = self.builder().get_insert_block().ok_or_else(|| {
                        CodegenError::Internal("no current block after coercion".to_string())
                    })?;
                    phi_values.push((final_val, final_block));
                }

                // Build the branch to merge_block
                self.builder()
                    .build_unconditional_branch(merge_block)
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to build branch: {:?}", e))
                    })?;
            }
            // If block already has a terminator, skip it entirely for PHI
        }

        // Build phi node in merge block
        self.builder().position_at_end(merge_block);

        if phi_values.is_empty() {
            Ok(None)
        } else {
            let phi_type = phi_values[0].0.get_type();
            let phi = self
                .builder()
                .build_phi(phi_type, "case_result")
                .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

            for (val, block) in &phi_values {
                phi.add_incoming(&[(val, *block)]);
            }

            Ok(Some(phi.as_basic_value()))
        }
    }

    /// Lower a Bool case expression when the scrutinee is an integer (from comparison).
    /// True is represented as non-zero (typically 1), False as 0.
    ///
    /// Uses a two-pass approach to avoid inserting instructions after terminators.
    fn lower_case_bool_as_int(
        &mut self,
        scrut_val: BasicValueEnum<'ctx>,
        alts: &[Alt],
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        let scrut_int = match scrut_val {
            BasicValueEnum::IntValue(i) => i,
            _ => {
                return Err(CodegenError::Internal(
                    "lower_case_bool_as_int called with non-integer scrutinee".to_string(),
                ))
            }
        };

        let current_fn = self
            .builder()
            .get_insert_block()
            .ok_or_else(|| CodegenError::Internal("no insert block".to_string()))?
            .get_parent()
            .ok_or_else(|| CodegenError::Internal("no parent function".to_string()))?;

        // Find the True and False alternatives
        let mut true_alt = None;
        let mut false_alt = None;
        let mut default_alt = None;

        for alt in alts {
            match &alt.con {
                AltCon::DataCon(con) => {
                    let name = con.name.as_str();
                    if name == "True" || name == "GHC.Types.True" {
                        true_alt = Some(alt);
                    } else if name == "False" || name == "GHC.Types.False" {
                        false_alt = Some(alt);
                    }
                }
                AltCon::Default => {
                    default_alt = Some(alt);
                }
                _ => {}
            }
        }

        // Create blocks
        let true_block = self
            .llvm_context()
            .append_basic_block(current_fn, "bool_true");
        let false_block = self
            .llvm_context()
            .append_basic_block(current_fn, "bool_false");
        let merge_block = self
            .llvm_context()
            .append_basic_block(current_fn, "bool_merge");

        // Compare scrutinee to zero (False = 0, True = non-zero)
        let zero = self.type_mapper().i64_type().const_zero();
        let is_true = self
            .builder()
            .build_int_compare(inkwell::IntPredicate::NE, scrut_int, zero, "is_true")
            .map_err(|e| CodegenError::Internal(format!("failed to build bool cmp: {:?}", e)))?;

        // Branch based on the comparison
        self.builder()
            .build_conditional_branch(is_true, true_block, false_block)
            .map_err(|e| CodegenError::Internal(format!("failed to build cond branch: {:?}", e)))?;

        // Pass 1: Lower both branches and collect values WITHOUT building terminators
        // Each branch RHS inherits tail position from parent case expression

        // True branch
        self.builder().position_at_end(true_block);
        let true_rhs = if let Some(alt) = true_alt {
            self.lower_expr(&alt.rhs)?
        } else if let Some(alt) = default_alt {
            self.lower_expr(&alt.rhs)?
        } else {
            None
        };
        let true_end_block = self.builder().get_insert_block().ok_or_else(|| {
            CodegenError::Internal("no current block after lower_expr".to_string())
        })?;

        // False branch
        self.builder().position_at_end(false_block);
        let false_rhs = if let Some(alt) = false_alt {
            self.lower_expr(&alt.rhs)?
        } else if let Some(alt) = default_alt {
            self.lower_expr(&alt.rhs)?
        } else {
            None
        };
        let false_end_block = self.builder().get_insert_block().ok_or_else(|| {
            CodegenError::Internal("no current block after lower_expr".to_string())
        })?;

        // Determine target type from the first available value
        let target_type = true_rhs
            .map(|v| v.get_type())
            .or_else(|| false_rhs.map(|v| v.get_type()));

        // Pass 2: Coerce values and build branches
        let mut phi_values: Vec<(BasicValueEnum<'ctx>, inkwell::basic_block::BasicBlock<'ctx>)> =
            Vec::new();

        // True branch: coerce and terminate (only if block reaches merge)
        self.builder().position_at_end(true_end_block);
        if true_end_block.get_terminator().is_none() {
            if let Some(val) = true_rhs {
                let final_val = if let Some(target) = target_type {
                    if val.get_type() != target {
                        self.coerce_to_type(val, target)?
                    } else {
                        val
                    }
                } else {
                    val
                };
                let final_block = self.builder().get_insert_block().ok_or_else(|| {
                    CodegenError::Internal("no current block after coercion".to_string())
                })?;
                phi_values.push((final_val, final_block));
            }
            self.builder()
                .build_unconditional_branch(merge_block)
                .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        }

        // False branch: coerce and terminate (only if block reaches merge)
        self.builder().position_at_end(false_end_block);
        if false_end_block.get_terminator().is_none() {
            if let Some(val) = false_rhs {
                let final_val = if let Some(target) = target_type {
                    if val.get_type() != target {
                        self.coerce_to_type(val, target)?
                    } else {
                        val
                    }
                } else {
                    val
                };
                let final_block = self.builder().get_insert_block().ok_or_else(|| {
                    CodegenError::Internal("no current block after coercion".to_string())
                })?;
                phi_values.push((final_val, final_block));
            }
            self.builder()
                .build_unconditional_branch(merge_block)
                .map_err(|e| CodegenError::Internal(format!("failed to build branch: {:?}", e)))?;
        }

        // Build phi node in merge block
        self.builder().position_at_end(merge_block);

        if phi_values.is_empty() {
            Ok(None)
        } else {
            let phi_type = phi_values[0].0.get_type();

            let phi = self
                .builder()
                .build_phi(phi_type, "bool_result")
                .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

            for (val, block) in &phi_values {
                phi.add_incoming(&[(val, *block)]);
            }

            Ok(Some(phi.as_basic_value()))
        }
    }

    /// Lower case alternatives with DataCon patterns (extracts fields and binds variables).
    ///
    /// Uses a two-pass approach:
    /// 1. First pass: lower all RHS expressions and collect (value, block) pairs WITHOUT building branches
    /// 2. Second pass: determine target type, coerce values if needed, then build branches
    fn lower_case_datacon_alternatives(
        &mut self,
        alts: &[Alt],
        blocks: &[inkwell::basic_block::BasicBlock<'ctx>],
        merge_block: inkwell::basic_block::BasicBlock<'ctx>,
        scrut_ptr: PointerValue<'ctx>,
        datacon_info: &[Option<&DataCon>],
        scrut_ty: &Ty,
    ) -> CodegenResult<Option<BasicValueEnum<'ctx>>> {
        // Pass 1: Lower all expressions and collect values WITHOUT building branches
        // We collect (Option<value>, block) so we know which block each value came from
        let mut collected: Vec<(
            Option<BasicValueEnum<'ctx>>,
            inkwell::basic_block::BasicBlock<'ctx>,
        )> = Vec::new();

        for (i, alt) in alts.iter().enumerate() {
            self.builder().position_at_end(blocks[i]);

            // Extract fields and bind to pattern variables
            if let Some(con) = datacon_info[i] {
                let arity = con.arity;

                // Bind each field to its corresponding pattern variable
                for (field_idx, binder) in alt.binders.iter().enumerate() {
                    if field_idx < arity as usize {
                        let field_ptr =
                            self.extract_adt_field(scrut_ptr, arity, field_idx as u32)?;

                        // Determine the field type:
                        // - Use binder.ty if it's not Error
                        // - Otherwise, infer from scrutinee type (e.g., for list elements)
                        let field_ty = if matches!(&binder.ty, Ty::Error) {
                            self.infer_field_type(scrut_ty, con, field_idx)
                        } else {
                            binder.ty.clone()
                        };

                        // Determine if we need to unbox the field
                        let field_val = self.ptr_to_value(field_ptr, &field_ty)?;
                        self.env.insert(binder.id, field_val);
                    }
                }
            }

            // Lower the RHS with bound variables (inherits tail position from parent case)
            let result = self.lower_expr(&alt.rhs)?;

            // Remove bindings (for proper scoping)
            for binder in &alt.binders {
                self.env.remove(&binder.id);
            }

            // Get the ACTUAL current block (lower_expr may have created nested blocks)
            let current_block = self.builder().get_insert_block().ok_or_else(|| {
                CodegenError::Internal("no current block after lower_expr".to_string())
            })?;

            collected.push((result, current_block));
        }

        // Determine target type from first non-None value
        let target_type = collected
            .iter()
            .find_map(|(val, _)| val.map(|v| v.get_type()));

        // Pass 2: Coerce values and build branches
        let mut phi_values: Vec<(BasicValueEnum<'ctx>, inkwell::basic_block::BasicBlock<'ctx>)> =
            Vec::new();

        for (result, block) in collected {
            // Position at the end of the block where the value was produced
            self.builder().position_at_end(block);

            // Only add to phi_values if we will branch to merge_block
            // If the block already has a terminator (e.g., error call with unreachable),
            // it doesn't reach merge_block and shouldn't contribute to the PHI
            if block.get_terminator().is_none() {
                if let Some(val) = result {
                    // Coerce if needed (BEFORE building the branch)
                    let final_val = if let Some(target) = target_type {
                        if val.get_type() != target {
                            self.coerce_to_type(val, target)?
                        } else {
                            val
                        }
                    } else {
                        val
                    };

                    // Get the current block (coercion doesn't change it)
                    let final_block = self.builder().get_insert_block().ok_or_else(|| {
                        CodegenError::Internal("no current block after coercion".to_string())
                    })?;
                    phi_values.push((final_val, final_block));
                }

                // Build the branch to merge_block
                self.builder()
                    .build_unconditional_branch(merge_block)
                    .map_err(|e| {
                        CodegenError::Internal(format!("failed to build branch: {:?}", e))
                    })?;
            }
            // If block already has a terminator, skip it entirely for PHI
        }

        // Build phi node in merge block
        self.builder().position_at_end(merge_block);

        if phi_values.is_empty() {
            Ok(None)
        } else {
            let phi_type = phi_values[0].0.get_type();
            let phi = self
                .builder()
                .build_phi(phi_type, "case_result")
                .map_err(|e| CodegenError::Internal(format!("failed to build phi: {:?}", e)))?;

            for (val, block) in &phi_values {
                phi.add_incoming(&[(val, *block)]);
            }

            Ok(Some(phi.as_basic_value()))
        }
    }

    /// Infer the type of a field from a data constructor based on the scrutinee type.
    ///
    /// This is used when pattern binders have `Ty::Error` type (which happens when
    /// HIR-to-Core lowering doesn't preserve types). We can infer the field types
    /// from the scrutinee type.
    ///
    /// For lists:
    /// - Cons `:` (tag 1, arity 2): field 0 is element type, field 1 is list type
    /// - Nil `[]` (tag 0, arity 0): no fields
    fn infer_field_type(&self, scrut_ty: &Ty, con: &DataCon, field_idx: usize) -> Ty {
        match scrut_ty {
            Ty::List(elem_ty) => {
                // List cons `:` has tag 1, arity 2
                // field 0: head element (elem_ty)
                // field 1: tail (list type)
                if con.tag == 1 && con.arity == 2 {
                    match field_idx {
                        0 => (**elem_ty).clone(), // head: element type
                        1 => scrut_ty.clone(),    // tail: list type
                        _ => Ty::Error,
                    }
                } else {
                    // Nil has no fields
                    Ty::Error
                }
            }
            Ty::Tuple(elem_tys) => {
                // Tuple fields correspond directly to element types
                if field_idx < elem_tys.len() {
                    elem_tys[field_idx].clone()
                } else {
                    Ty::Error
                }
            }
            Ty::App(con_ty, arg_ty) => {
                // For type applications like `Maybe Int`, we need to look up
                // the constructor's field types and substitute type arguments.
                // For now, just propagate the argument type for single-arg constructors.
                if con.arity == 1 && field_idx == 0 {
                    (**arg_ty).clone()
                } else {
                    Ty::Error
                }
            }
            _ => {
                // For other types, we can't infer - return Error and let codegen handle it
                Ty::Error
            }
        }
    }

    /// Convert a pointer to a basic value, unboxing if necessary based on type.
    fn ptr_to_value(
        &self,
        ptr: PointerValue<'ctx>,
        ty: &Ty,
    ) -> CodegenResult<BasicValueEnum<'ctx>> {
        let tm = self.type_mapper();

        match ty {
            Ty::Con(con) => {
                let name = con.name.as_str();
                match name {
                    "Int" | "Int#" | "Int64" => {
                        // Unbox: ptr -> int
                        let int_val = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_int")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox int: {:?}", e))
                            })?;
                        Ok(int_val.into())
                    }
                    "Int32" => {
                        let int_val = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_int")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox int: {:?}", e))
                            })?;
                        let truncated = self
                            .builder()
                            .build_int_truncate(int_val, tm.i32_type(), "trunc_i32")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to truncate: {:?}", e))
                            })?;
                        Ok(truncated.into())
                    }
                    "Bool" => {
                        let int_val = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_bool")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox bool: {:?}", e))
                            })?;
                        let bool_val = self
                            .builder()
                            .build_int_truncate(int_val, tm.bool_type(), "to_bool")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to truncate bool: {:?}", e))
                            })?;
                        Ok(bool_val.into())
                    }
                    "Char" | "Char#" => {
                        let int_val = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_char")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox char: {:?}", e))
                            })?;
                        let char_val = self
                            .builder()
                            .build_int_truncate(int_val, tm.i32_type(), "to_char")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to truncate char: {:?}", e))
                            })?;
                        Ok(char_val.into())
                    }
                    "Float" | "Float#" => {
                        // Unbox: ptr -> bits -> float
                        let bits = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_float_bits")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox float: {:?}", e))
                            })?;
                        let truncated = self
                            .builder()
                            .build_int_truncate(bits, tm.i32_type(), "float_bits_32")
                            .map_err(|e| {
                                CodegenError::Internal(format!(
                                    "failed to truncate float bits: {:?}",
                                    e
                                ))
                            })?;
                        let float_val = self
                            .builder()
                            .build_bit_cast(truncated, tm.f32_type(), "to_float")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to cast to float: {:?}", e))
                            })?;
                        Ok(float_val)
                    }
                    "Double" | "Double#" => {
                        let bits = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_double_bits")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox double: {:?}", e))
                            })?;
                        let double_val = self
                            .builder()
                            .build_bit_cast(bits, tm.f64_type(), "to_double")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to cast to double: {:?}", e))
                            })?;
                        Ok(double_val)
                    }
                    _ => {
                        // For other types (ADTs), keep as pointer
                        Ok(ptr.into())
                    }
                }
            }
            Ty::Prim(prim) => {
                use bhc_types::PrimTy;
                match prim {
                    PrimTy::I64 | PrimTy::U64 => {
                        let int_val = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_i64")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox i64: {:?}", e))
                            })?;
                        Ok(int_val.into())
                    }
                    PrimTy::I32 | PrimTy::U32 => {
                        let int_val = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_int")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox int: {:?}", e))
                            })?;
                        let truncated = self
                            .builder()
                            .build_int_truncate(int_val, tm.i32_type(), "trunc_i32")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to truncate: {:?}", e))
                            })?;
                        Ok(truncated.into())
                    }
                    PrimTy::F32 => {
                        let bits = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_float_bits")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox float: {:?}", e))
                            })?;
                        let truncated = self
                            .builder()
                            .build_int_truncate(bits, tm.i32_type(), "float_bits_32")
                            .map_err(|e| {
                                CodegenError::Internal(format!(
                                    "failed to truncate float bits: {:?}",
                                    e
                                ))
                            })?;
                        let float_val = self
                            .builder()
                            .build_bit_cast(truncated, tm.f32_type(), "to_float")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to cast to float: {:?}", e))
                            })?;
                        Ok(float_val)
                    }
                    PrimTy::F64 => {
                        let bits = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_double_bits")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox double: {:?}", e))
                            })?;
                        let double_val = self
                            .builder()
                            .build_bit_cast(bits, tm.f64_type(), "to_double")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to cast to double: {:?}", e))
                            })?;
                        Ok(double_val)
                    }
                    PrimTy::Char => {
                        let int_val = self
                            .builder()
                            .build_ptr_to_int(ptr, tm.i64_type(), "unbox_char")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to unbox char: {:?}", e))
                            })?;
                        let char_val = self
                            .builder()
                            .build_int_truncate(int_val, tm.i32_type(), "to_char")
                            .map_err(|e| {
                                CodegenError::Internal(format!("failed to truncate char: {:?}", e))
                            })?;
                        Ok(char_val.into())
                    }
                    PrimTy::Addr => Ok(ptr.into()),
                }
            }
            _ => {
                // For function types, type variables, etc., keep as pointer
                Ok(ptr.into())
            }
        }
    }

    /// Convert a Core type to an LLVM function type.
    ///
    /// Uses pointer types for all parameters to enable uniform calling convention
    /// for higher-order functions and closures.
    /// All functions take an env_ptr as the first parameter (even if unused)
    /// to enable uniform closure calling convention.
    fn lower_function_type(&self, ty: &Ty) -> CodegenResult<inkwell::types::FunctionType<'ctx>> {
        let tm = self.type_mapper();
        let ptr_type = tm.ptr_type();

        // Count the number of parameters
        let mut param_count = 0;
        let mut current = ty;

        while let Ty::Fun(_, ret) = current {
            param_count += 1;
            current = ret;
        }

        // All functions take (env_ptr, args...) for uniform closure calling convention
        let mut arg_types: Vec<inkwell::types::BasicMetadataTypeEnum<'ctx>> = Vec::new();
        arg_types.push(ptr_type.into()); // env/closure pointer (may be unused)
        for _ in 0..param_count {
            arg_types.push(ptr_type.into());
        }

        // Return type is also pointer for uniformity
        Ok(ptr_type.fn_type(&arg_types, false))
    }

    /// Convert a Core type to an LLVM basic type (for function return).
    fn lower_basic_type(&self, ty: &Ty) -> CodegenResult<Option<BasicTypeEnum<'ctx>>> {
        let tm = self.type_mapper();
        match ty {
            Ty::Con(con) => {
                let name = con.name.as_str();
                match name {
                    "Int" | "Int#" | "Int64" => Ok(Some(tm.i64_type().into())),
                    "Int32" => Ok(Some(tm.i32_type().into())),
                    "Float" | "Float#" => Ok(Some(tm.f32_type().into())),
                    "Double" | "Double#" => Ok(Some(tm.f64_type().into())),
                    "Char" | "Char#" => Ok(Some(tm.i32_type().into())),
                    // Bool uses i64 for consistency with how comparisons return values
                    "Bool" => Ok(Some(tm.i64_type().into())),
                    "()" | "Unit" => Ok(None), // Unit type has no value
                    _ => {
                        // Unknown type - use a pointer for now
                        Ok(Some(tm.ptr_type().into()))
                    }
                }
            }
            Ty::Prim(prim) => {
                use bhc_types::PrimTy;
                match prim {
                    PrimTy::I32 => Ok(Some(tm.i32_type().into())),
                    PrimTy::I64 => Ok(Some(tm.i64_type().into())),
                    PrimTy::U32 => Ok(Some(tm.i32_type().into())),
                    PrimTy::U64 => Ok(Some(tm.i64_type().into())),
                    PrimTy::F32 => Ok(Some(tm.f32_type().into())),
                    PrimTy::F64 => Ok(Some(tm.f64_type().into())),
                    PrimTy::Char => Ok(Some(tm.i32_type().into())),
                    PrimTy::Addr => Ok(Some(tm.ptr_type().into())),
                }
            }
            Ty::App(f, arg) => {
                // Check for IO () which should map to void
                if let Ty::Con(con) = f.as_ref() {
                    if con.name.as_str() == "IO" {
                        // IO a - check if a is ()
                        if let Ty::Tuple(elems) = arg.as_ref() {
                            if elems.is_empty() {
                                // IO () -> void
                                return Ok(None);
                            }
                        }
                        if let Ty::Con(inner_con) = arg.as_ref() {
                            if inner_con.name.as_str() == "()" {
                                // IO () -> void
                                return Ok(None);
                            }
                        }
                    }
                }
                self.lower_basic_type(f)
            }
            Ty::Fun(_, _) => {
                // Function types are pointers
                Ok(Some(tm.ptr_type().into()))
            }
            Ty::Forall(_, body) => self.lower_basic_type(body),
            Ty::Var(_) => {
                // Type variables are erased - use pointer
                Ok(Some(tm.ptr_type().into()))
            }
            Ty::Tuple(elems) => {
                if elems.is_empty() {
                    // Unit type ()
                    Ok(None)
                } else {
                    // Tuples become pointers for now
                    Ok(Some(tm.ptr_type().into()))
                }
            }
            Ty::List(_) => {
                // Lists become pointers
                Ok(Some(tm.ptr_type().into()))
            }
            Ty::Nat(_) => {
                // Type-level naturals are erased at runtime
                Ok(None)
            }
            Ty::TyList(_) => {
                // Type-level lists are erased at runtime
                Ok(None)
            }
            Ty::Error => Ok(None),
        }
    }

    /// Convert a Core type to an LLVM type (for arguments).
    fn lower_type(&self, ty: &Ty) -> CodegenResult<BasicTypeEnum<'ctx>> {
        self.lower_basic_type(ty)?.ok_or_else(|| {
            CodegenError::TypeError("cannot lower void type to basic type".to_string())
        })
    }

    // Helper accessors
    fn llvm_context(&self) -> &'ctx Context {
        self.llvm_ctx
    }

    fn builder(&self) -> &Builder<'ctx> {
        self.module.builder()
    }

    fn type_mapper(&self) -> &TypeMapper<'ctx> {
        self.module.type_mapper()
    }
}

/// Lower a Core module to an LLVM module.
///
/// The module reference `'m` can be shorter than the context lifetime `'ctx`.
pub fn lower_core_module<'ctx, 'm>(
    ctx: &'ctx LlvmContext,
    module: &'m LlvmModule<'ctx>,
    core_module: &CoreModule,
) -> CodegenResult<()> {
    let mut lowering = Lowering::new(ctx, module);
    lowering.lower_module(core_module)
}

/// Lower a Core module to an LLVM module with multi-module support.
///
/// This variant accepts a module name for symbol mangling and a list of imported
/// symbols from already-compiled modules. Functions are declared with
/// module-qualified names (e.g., `Helper.double`) and extern declarations are
/// added for cross-module references.
pub fn lower_core_module_multimodule<'ctx, 'm>(
    ctx: &'ctx LlvmContext,
    module: &'m LlvmModule<'ctx>,
    core_module: &CoreModule,
    module_name: &str,
    imported_symbols: &[CompiledSymbol],
) -> CodegenResult<()> {
    lower_core_module_multimodule_with_constructors(
        ctx,
        module,
        core_module,
        module_name,
        imported_symbols,
        &[],
    )
}

/// Lower a Core module to LLVM IR in multi-module mode, with imported constructor metadata.
pub fn lower_core_module_multimodule_with_constructors<'ctx, 'm>(
    ctx: &'ctx LlvmContext,
    module: &'m LlvmModule<'ctx>,
    core_module: &CoreModule,
    module_name: &str,
    imported_symbols: &[CompiledSymbol],
    imported_constructors: &[(String, ConstructorMeta)],
) -> CodegenResult<()> {
    let mut lowering = Lowering::new_multimodule(ctx, module, module_name, imported_symbols)?;
    // Register imported constructor metadata so the codegen knows about
    // constructors from other modules (e.g., Types.hs constructors used in Parser.hs).
    for (name, meta) in imported_constructors {
        lowering.register_constructor(name, meta.tag, meta.arity);
    }
    lowering.lower_module(core_module)
}

#[cfg(test)]
mod tests {
    use super::*;

    // Tests would go here
}
