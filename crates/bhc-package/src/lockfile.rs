//! Lockfile format for reproducible builds.
//!
//! The lockfile (`bhc.lock`) records exact dependency versions
//! and sources for reproducible builds across environments.
//!
//! # Format
//!
//! The lockfile uses TOML format:
//!
//! ```toml
//! # This file is automatically generated by BHC.
//! # Do not edit manually.
//! version = 1
//!
//! [[package]]
//! name = "base"
//! version = "1.2.3"
//! source = "registry"
//! checksum = "sha256:abc123..."
//! dependencies = ["ghc-prim"]
//!
//! [[package]]
//! name = "my-lib"
//! version = "0.1.0"
//! source = "git+https://github.com/example/my-lib?rev=abc123"
//! dependencies = ["base", "text"]
//!
//! [[package]]
//! name = "local-dep"
//! version = "0.0.1"
//! source = "path+../local-dep"
//! dependencies = []
//! ```

use camino::{Utf8Path, Utf8PathBuf};
use semver::Version;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use thiserror::Error;

/// Lockfile format version.
pub const LOCKFILE_VERSION: u32 = 1;

/// Lockfile name.
pub const LOCKFILE_NAME: &str = "bhc.lock";

/// Errors that can occur during lockfile operations.
#[derive(Debug, Error)]
pub enum LockfileError {
    /// Lockfile not found.
    #[error("lockfile not found: {0}")]
    NotFound(Utf8PathBuf),

    /// Invalid lockfile format.
    #[error("invalid lockfile: {0}")]
    Invalid(String),

    /// Unsupported lockfile version.
    #[error("unsupported lockfile version: {0} (expected {LOCKFILE_VERSION})")]
    UnsupportedVersion(u32),

    /// Checksum mismatch.
    #[error("checksum mismatch for {package}: expected {expected}, got {actual}")]
    ChecksumMismatch {
        /// Package name.
        package: String,
        /// Expected checksum.
        expected: String,
        /// Actual checksum.
        actual: String,
    },

    /// IO error.
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    /// TOML parsing error.
    #[error("TOML error: {0}")]
    Toml(String),
}

/// Result type for lockfile operations.
pub type LockfileResult<T> = Result<T, LockfileError>;

/// A complete lockfile.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Lockfile {
    /// Lockfile format version.
    pub version: u32,

    /// Locked packages.
    #[serde(default, rename = "package")]
    pub packages: Vec<LockedPackage>,

    /// Metadata about the lockfile.
    #[serde(default, skip_serializing_if = "LockfileMetadata::is_empty")]
    pub metadata: LockfileMetadata,
}

impl Default for Lockfile {
    fn default() -> Self {
        Self::new()
    }
}

impl Lockfile {
    /// Create a new empty lockfile.
    #[must_use]
    pub fn new() -> Self {
        Self {
            version: LOCKFILE_VERSION,
            packages: Vec::new(),
            metadata: LockfileMetadata::default(),
        }
    }

    /// Load a lockfile from a path.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be read or parsed.
    pub fn load(path: impl AsRef<Utf8Path>) -> LockfileResult<Self> {
        let path = path.as_ref();
        let content = std::fs::read_to_string(path).map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                LockfileError::NotFound(path.to_path_buf())
            } else {
                LockfileError::Io(e)
            }
        })?;
        Self::parse(&content)
    }

    /// Parse a lockfile from TOML content.
    ///
    /// # Errors
    ///
    /// Returns an error if the content is not valid.
    pub fn parse(content: &str) -> LockfileResult<Self> {
        let lockfile: Self =
            toml::from_str(content).map_err(|e| LockfileError::Toml(e.to_string()))?;

        // Validate version
        if lockfile.version != LOCKFILE_VERSION {
            return Err(LockfileError::UnsupportedVersion(lockfile.version));
        }

        Ok(lockfile)
    }

    /// Save the lockfile to a path.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be written.
    pub fn save(&self, path: impl AsRef<Utf8Path>) -> LockfileResult<()> {
        let content = self.to_string();
        std::fs::write(path.as_ref(), content)?;
        Ok(())
    }

    /// Convert to TOML string.
    #[must_use]
    pub fn to_string(&self) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str("# This file is automatically generated by BHC.\n");
        output.push_str("# It contains exact versions of all dependencies.\n");
        output.push_str("# Do not edit manually.\n\n");

        // Version
        output.push_str(&format!("version = {}\n", self.version));

        // Packages (sorted for determinism)
        let mut sorted_packages = self.packages.clone();
        sorted_packages.sort_by(|a, b| a.name.cmp(&b.name).then(a.version.cmp(&b.version)));

        for pkg in &sorted_packages {
            output.push_str("\n[[package]]\n");
            output.push_str(&format!("name = \"{}\"\n", pkg.name));
            output.push_str(&format!("version = \"{}\"\n", pkg.version));
            output.push_str(&format!("source = \"{}\"\n", pkg.source));

            if let Some(ref checksum) = pkg.checksum {
                output.push_str(&format!("checksum = \"{checksum}\"\n"));
            }

            if !pkg.dependencies.is_empty() {
                let deps: Vec<String> = pkg
                    .dependencies
                    .iter()
                    .map(|d| format!("\"{d}\""))
                    .collect();
                output.push_str(&format!("dependencies = [{}]\n", deps.join(", ")));
            }

            if !pkg.features.is_empty() {
                let feats: Vec<String> = pkg.features.iter().map(|f| format!("\"{f}\"")).collect();
                output.push_str(&format!("features = [{}]\n", feats.join(", ")));
            }
        }

        // Metadata
        if !self.metadata.is_empty() {
            output.push_str("\n[metadata]\n");
            for (key, value) in &self.metadata.extra {
                output.push_str(&format!("{key} = \"{value}\"\n"));
            }
        }

        output
    }

    /// Add a locked package.
    pub fn add_package(&mut self, package: LockedPackage) {
        // Remove existing entry for same name if present
        self.packages.retain(|p| p.name != package.name);
        self.packages.push(package);
    }

    /// Find a package by name.
    #[must_use]
    pub fn find_package(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.iter().find(|p| p.name == name)
    }

    /// Find a package by name and version.
    #[must_use]
    pub fn find_package_version(&self, name: &str, version: &Version) -> Option<&LockedPackage> {
        self.packages
            .iter()
            .find(|p| p.name == name && &p.version == version)
    }

    /// Check if the lockfile is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.packages.is_empty()
    }

    /// Get the number of locked packages.
    #[must_use]
    pub fn len(&self) -> usize {
        self.packages.len()
    }

    /// Verify all checksums.
    ///
    /// # Errors
    ///
    /// Returns an error if any checksum fails to verify.
    pub fn verify_checksums<F>(&self, compute_checksum: F) -> LockfileResult<()>
    where
        F: Fn(&LockedPackage) -> Option<String>,
    {
        for package in &self.packages {
            if let Some(ref expected) = package.checksum {
                if let Some(actual) = compute_checksum(package) {
                    if expected != &actual {
                        return Err(LockfileError::ChecksumMismatch {
                            package: package.name.clone(),
                            expected: expected.clone(),
                            actual,
                        });
                    }
                }
            }
        }
        Ok(())
    }
}

/// A single locked package entry.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LockedPackage {
    /// Package name.
    pub name: String,

    /// Exact version.
    #[serde(with = "crate::version_serde")]
    pub version: Version,

    /// Source specification.
    pub source: LockedSource,

    /// Content checksum (for registry packages).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,

    /// Locked dependencies (package names).
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dependencies: Vec<String>,

    /// Enabled features.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub features: Vec<String>,
}

impl LockedPackage {
    /// Create a new locked package.
    #[must_use]
    pub fn new(name: impl Into<String>, version: Version, source: LockedSource) -> Self {
        Self {
            name: name.into(),
            version,
            source,
            checksum: None,
            dependencies: Vec::new(),
            features: Vec::new(),
        }
    }

    /// Set the checksum.
    #[must_use]
    pub fn with_checksum(mut self, checksum: impl Into<String>) -> Self {
        self.checksum = Some(checksum.into());
        self
    }

    /// Set the dependencies.
    #[must_use]
    pub fn with_dependencies(mut self, deps: Vec<String>) -> Self {
        self.dependencies = deps;
        self
    }

    /// Set the features.
    #[must_use]
    pub fn with_features(mut self, features: Vec<String>) -> Self {
        self.features = features;
        self
    }
}

/// Source specification for a locked package.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum LockedSource {
    /// Package registry.
    Registry,

    /// Git repository.
    Git {
        /// Repository URL.
        url: String,
        /// Exact revision.
        rev: String,
    },

    /// Local path.
    Path(Utf8PathBuf),
}

impl LockedSource {
    /// Parse a source string.
    #[must_use]
    pub fn parse(s: &str) -> Option<Self> {
        if s == "registry" {
            return Some(Self::Registry);
        }

        if let Some(rest) = s.strip_prefix("git+") {
            // Parse git+https://example.com/repo?rev=abc123
            if let Some((url, query)) = rest.rsplit_once("?rev=") {
                return Some(Self::Git {
                    url: url.to_string(),
                    rev: query.to_string(),
                });
            }
        }

        if let Some(path) = s.strip_prefix("path+") {
            return Some(Self::Path(Utf8PathBuf::from(path)));
        }

        None
    }
}

impl std::fmt::Display for LockedSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Registry => write!(f, "registry"),
            Self::Git { url, rev } => write!(f, "git+{url}?rev={rev}"),
            Self::Path(path) => write!(f, "path+{path}"),
        }
    }
}

impl Serialize for LockedSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for LockedSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        Self::parse(&s).ok_or_else(|| serde::de::Error::custom(format!("invalid source: {s}")))
    }
}

/// Lockfile metadata.
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct LockfileMetadata {
    /// Extra key-value pairs.
    #[serde(flatten)]
    pub extra: BTreeMap<String, String>,
}

impl LockfileMetadata {
    /// Check if the metadata is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.extra.is_empty()
    }
}

/// Find the lockfile in a directory or its parents.
///
/// # Errors
///
/// Returns an error if no lockfile is found.
pub fn find_lockfile(start: impl AsRef<Utf8Path>) -> LockfileResult<Utf8PathBuf> {
    let mut current = start.as_ref().to_path_buf();

    loop {
        let lockfile_path = current.join(LOCKFILE_NAME);
        if lockfile_path.exists() {
            return Ok(lockfile_path);
        }

        match current.parent() {
            Some(parent) => current = parent.to_path_buf(),
            None => return Err(LockfileError::NotFound(start.as_ref().join(LOCKFILE_NAME))),
        }
    }
}

/// Compute SHA-256 checksum of bytes.
#[must_use]
pub fn compute_checksum(data: &[u8]) -> String {
    use std::fmt::Write;
    // Note: In a real implementation, use sha2 crate
    // For now, this is a placeholder
    let mut hasher = SimpleHasher::new();
    hasher.update(data);
    let hash = hasher.finalize();
    let mut result = String::with_capacity(64 + 7);
    result.push_str("sha256:");
    for byte in hash {
        write!(result, "{byte:02x}").unwrap();
    }
    result
}

// Simple hasher placeholder (would use sha2 in real impl)
struct SimpleHasher {
    state: [u8; 32],
}

impl SimpleHasher {
    fn new() -> Self {
        Self { state: [0; 32] }
    }

    fn update(&mut self, data: &[u8]) {
        for (i, byte) in data.iter().enumerate() {
            self.state[i % 32] ^= byte;
        }
    }

    fn finalize(self) -> [u8; 32] {
        self.state
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE_LOCKFILE: &str = r#"
# This file is automatically generated by BHC.
version = 1

[[package]]
name = "base"
version = "1.0.0"
source = "registry"
checksum = "sha256:abc123"
dependencies = ["ghc-prim"]

[[package]]
name = "text"
version = "2.0.0"
source = "registry"
checksum = "sha256:def456"
dependencies = ["base"]
features = ["unicode"]

[[package]]
name = "local-dep"
version = "0.1.0"
source = "path+../local-dep"
dependencies = []
"#;

    #[test]
    fn test_parse_lockfile() {
        let lockfile = Lockfile::parse(SAMPLE_LOCKFILE).unwrap();
        assert_eq!(lockfile.version, 1);
        assert_eq!(lockfile.packages.len(), 3);
    }

    #[test]
    fn test_find_package() {
        let lockfile = Lockfile::parse(SAMPLE_LOCKFILE).unwrap();

        let base = lockfile.find_package("base").unwrap();
        assert_eq!(base.version.to_string(), "1.0.0");
        assert_eq!(base.source, LockedSource::Registry);
        assert_eq!(base.dependencies, vec!["ghc-prim"]);

        let text = lockfile.find_package("text").unwrap();
        assert_eq!(text.features, vec!["unicode"]);

        let local = lockfile.find_package("local-dep").unwrap();
        assert_eq!(
            local.source,
            LockedSource::Path(Utf8PathBuf::from("../local-dep"))
        );
    }

    #[test]
    fn test_locked_source_parsing() {
        assert_eq!(
            LockedSource::parse("registry"),
            Some(LockedSource::Registry)
        );

        assert_eq!(
            LockedSource::parse("git+https://github.com/example/repo?rev=abc123"),
            Some(LockedSource::Git {
                url: "https://github.com/example/repo".to_string(),
                rev: "abc123".to_string(),
            })
        );

        assert_eq!(
            LockedSource::parse("path+../local"),
            Some(LockedSource::Path(Utf8PathBuf::from("../local")))
        );
    }

    #[test]
    fn test_locked_source_roundtrip() {
        let sources = vec![
            LockedSource::Registry,
            LockedSource::Git {
                url: "https://github.com/example/repo".to_string(),
                rev: "abc123".to_string(),
            },
            LockedSource::Path(Utf8PathBuf::from("../local")),
        ];

        for source in sources {
            let s = source.to_string();
            let parsed = LockedSource::parse(&s).unwrap();
            assert_eq!(parsed, source);
        }
    }

    #[test]
    fn test_lockfile_roundtrip() {
        let mut lockfile = Lockfile::new();

        lockfile.add_package(
            LockedPackage::new("test", Version::new(1, 0, 0), LockedSource::Registry)
                .with_checksum("sha256:test123")
                .with_dependencies(vec!["base".to_string()])
                .with_features(vec!["feature1".to_string()]),
        );

        let content = lockfile.to_string();
        let parsed = Lockfile::parse(&content).unwrap();

        assert_eq!(parsed.packages.len(), 1);
        let pkg = &parsed.packages[0];
        assert_eq!(pkg.name, "test");
        assert_eq!(pkg.version.to_string(), "1.0.0");
        assert_eq!(pkg.checksum, Some("sha256:test123".to_string()));
    }

    #[test]
    fn test_unsupported_version() {
        let content = "version = 999\n";
        let result = Lockfile::parse(content);
        assert!(matches!(
            result,
            Err(LockfileError::UnsupportedVersion(999))
        ));
    }
}
